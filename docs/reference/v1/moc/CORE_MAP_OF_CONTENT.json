{
  "generated": "2026-02-23T17:22:30.322626",
  "author": "@darianrosebrook",
  "total_modules": 784,
  "modules": [
    {
      "path": "__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Core Sterling pipeline components.\n\nThis package contains the fundamental building blocks for the Sterling\nneuro-symbolic architecture, including IR serialization, ID registry management,\nand task interfaces.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-16T21:15:38.315998",
        "modified": "2026-01-22T07:53:46.007148",
        "modified_days_ago": 29,
        "lines": 10,
        "size_bytes": 251,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/__init__.py",
      "name": "__init__.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Sterling Benchmarks Package.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.benchmarks.episode_runner",
        "core.benchmarks.evidence_collector",
        "core.benchmarks.evidence_kernel",
        "core.benchmarks.harness_config",
        "core.benchmarks.distributional_gate",
        "core.benchmarks.policy_protocol",
        "core.benchmarks.stochastic_witness",
        "core.benchmarks.conformance_gate",
        "core.benchmarks.robustness_gate"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T03:15:18.583920",
        "modified": "2026-02-15T03:15:18.584416",
        "modified_days_ago": 5,
        "lines": 55,
        "size_bytes": 1554,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/conformance_gate.py",
      "name": "conformance_gate.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\": \"A3/A2/A1/A4: atomicity, isolation, journal, transcript only on commit\n@type:  eval_ which\n\"\"\" 1. A3 check: commit writes CAND, 2. Axi, 4.  No  hidden  router\n",
      "classes": [
        "ConformanceGateConfig",
        "ConformanceViolation",
        "ConformanceGateResult"
      ],
      "functions": [
        "evaluate_conformance_gate",
        "_get_kv_map",
        "_get_pre_kv_map_from_observation",
        "_get_epoch",
        "_get_journal_length",
        "_check_atomicity",
        "_check_abort_isolation",
        "_check_replay_determinism",
        "_check_no_hidden_router",
        "_check_tool_transcript_boundary"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json",
        "core.benchmarks.episode_runner"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T04:53:11.088593",
        "modified": "2026-02-15T04:53:11.088774",
        "modified_days_ago": 5,
        "lines": 495,
        "size_bytes": 17888,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/distributional_gate.py",
      "name": "distributional_gate.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Distributional Certification Gate for stochastic benchmark domains.\n\nValidates that observed stochastic behavior (aggregate slip rates) is\nconsistent with configured probabilities across sufficient evidence volume.\n\nModel B evidence: statistical acceptance test for aggregate claims.\nModel A (replay) lives in stochastic_witness.py.\n\nAuthor: @darianrosebrook",
      "classes": [
        "DistributionalGateConfig",
        "DistributionalGateViolation",
        "DistributionalGateResult"
      ],
      "functions": [
        "evaluate_distributional_gate"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.benchmarks.stochastic_witness"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T00:33:08.835519",
        "modified": "2026-02-15T00:33:08.835696",
        "modified_days_ago": 6,
        "lines": 249,
        "size_bytes": 9473,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/episode_runner.py",
      "name": "episode_runner.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Runs a single episode using a Kernel + Policy pair in the Unified World Harness, producing an EpisodeTrace with per-step evidence.",
      "classes": [
        "StepRecord",
        "EpisodeTrace"
      ],
      "functions": [
        "_build_legal_actions",
        "run_episode"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.benchmarks.evidence_kernel",
        "core.benchmarks.harness_config",
        "core.benchmarks.policy_protocol",
        "core.kernels.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T00:29:34.410947",
        "modified": "2026-02-15T00:29:34.411061",
        "modified_days_ago": 6,
        "lines": 314,
        "size_bytes": 11246,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/escapegame_fixtures.py",
      "name": "escapegame_fixtures.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"EscapeGame\": \"Fixture generation from seeds, deterministic output\n    contract (hard)\"\" with\n    max_ options and\n    tie_break_ rule\n    for invalidating caches\n    with custom\n    is False\n    \"\"\" (optional) returns\n    the contract\n    solution hashes\n    and\n    includes\n    solver\n    state",
      "classes": [
        "TieBreakRule",
        "SolverContractV1",
        "Difficulty",
        "EscapeGameFixtureSpec",
        "EscapeGameFixtureManifestV1",
        "PieceConfig",
        "FixtureGenerator"
      ],
      "functions": [
        "create_fixture_manifest",
        "load_fixture_manifest",
        "save_fixture_manifest",
        "generate_canonical_manifest",
        "verify_fixture_hash"
      ],
      "imports": [
        "__future__",
        "random",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-04T20:42:37.715635",
        "modified": "2026-02-04T22:10:08.580589",
        "modified_days_ago": 16,
        "lines": 535,
        "size_bytes": 17110,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/evidence_collector.py",
      "name": "evidence_collector.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Evidence collector for the Unified World Harness. Aggregates episode outcomes into sorted, hash-verified bundles with toggle-activated validation for tool and seed coverage.",
      "classes": [
        "OutcomeRow",
        "EvidenceCollector"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.benchmarks.episode_runner",
        "core.benchmarks.harness_config"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T04:02:21.913105",
        "modified": "2026-02-08T04:02:21.913276",
        "modified_days_ago": 12,
        "lines": 256,
        "size_bytes": 9933,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/evidence_kernel.py",
      "name": "evidence_kernel.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Defines evidence emission interfaces for benchmark worlds. Requires worlds to emit specific kernel artifacts for verification.",
      "classes": [
        "WorldStep",
        "EvidenceEmitter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T03:53:33.175424",
        "modified": "2026-02-08T03:53:33.175522",
        "modified_days_ago": 12,
        "lines": 42,
        "size_bytes": 1001,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/__init__.py",
      "name": "__init__.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Sterling Fence Benchmark Engine (K6).\n\nFence harness for controlled A/B/C proof runs with certified operator promotion.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.benchmarks.fence.cheating",
        "core.benchmarks.fence.engine",
        "core.benchmarks.fence.k6_runner",
        "core.benchmarks.fence.k6_types",
        "core.benchmarks.fence.operator_selection",
        "core.benchmarks.fence.proof_bundle",
        "core.benchmarks.fence.scenario",
        "core.benchmarks.fence.scenario_gate"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:28:57.152102",
        "modified": "2026-01-22T07:53:46.530194",
        "modified_days_ago": 29,
        "lines": 99,
        "size_bytes": 3012,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/allowed_set.py",
      "name": "allowed_set.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Allowed Apply Set Artifact (K6-E3).\n\nPersists the exact allowlist used at apply time for deterministic replay\nand meaningful hash verification.\n\nAuthor: @darianrosebrook",
      "classes": [
        "AllowedApplySetV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T01:34:34.047793",
        "modified": "2026-01-22T07:53:46.530169",
        "modified_days_ago": 29,
        "lines": 162,
        "size_bytes": 5260,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/baseline_loader.py",
      "name": "baseline_loader.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\": \"Provides immutable input for regression fence baseline (not result). Hashed using episode content. Baseline as input to make (content) hash for episode.  Check, at start and end.  Hashed (must) operator(s) keys.    # Your puzzle's dict values (not a graph).  Check.  Hash-in, raw input (not) includes (raw_ input (heuristics).  Hashed.  Execution environment over (hash_ as input, include (default model_  list[1.",
      "classes": [
        "EpisodeInputOnly",
        "EpisodeResult",
        "LoadedEpisode",
        "BaselineLoadResult"
      ],
      "functions": [
        "_extract_episode_input",
        "_extract_episode_result",
        "load_certification_baseline",
        "validate_regression_fence_preconditions"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.governance.canonical_hash",
        "core.governance.gate_verdict",
        "core.governance.run_intent"
      ],
      "constants": [
        "DEFAULT_REGRESSION_BASELINE_PATH",
        "DEFAULT_DISCRIMINATIVE_BASELINE_PATH",
        "REGRESSION_INPUT_FIELDS",
        "DISCRIMINATIVE_INPUT_FIELDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T15:59:06.591688",
        "modified": "2026-01-25T15:59:06.591792",
        "modified_days_ago": 26,
        "lines": 508,
        "size_bytes": 18055,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/bundle_integrity.py",
      "name": "bundle_integrity.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Enforces bundle self-description, hash normalization, and schema identity checks at all bundle boundaries during K6 proof runs.",
      "classes": [
        "BundleIntegrityResult"
      ],
      "functions": [
        "validate_bundle_self_description",
        "validate_final_bundle_schema_identity",
        "validate_hash_normalization",
        "validate_trace_capture_status",
        "run_go_no_go_checklist"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.canonicalization.hashes"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.760731",
        "modified": "2026-01-22T07:53:46.530049",
        "modified_days_ago": 29,
        "lines": 485,
        "size_bytes": 19064,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/certified_operator_loader.py",
      "name": "certified_operator_loader.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Certified Operator Loader (K6 Phase 2-3).\n\nLoads and promotes certified operators from certificate artifacts for config C.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "_verify_semantic_replay",
        "_compute_state_delta",
        "_deltas_match",
        "load_and_promote_certified_operator"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.artifact_closure",
        "core.induction.artifact_store",
        "core.induction.certificate_builder",
        "core.induction.certificate_verifier",
        "core.induction.closure_allowlist",
        "core.induction.overlay_registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T19:15:07.434989",
        "modified": "2026-02-18T19:15:07.435156",
        "modified_days_ago": 2,
        "lines": 430,
        "size_bytes": 17116,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/cheating.py",
      "name": "cheating.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Provides canonical cheating detection by extracting and verifying edge traversals from SearchNode paths against forbidden relations. Fails to EVIDENCE_INCOMPLETE if any forbidden use is detected. Used for K6 fence benchmark certification.",
      "classes": [
        "CheatingDetectionResult",
        "TraversedEdge",
        "CheatingVerdict"
      ],
      "functions": [
        "requires_edge_traversal",
        "extract_traversed_edges_from_overlays",
        "extract_traversed_edges",
        "analyze_cheating",
        "did_use_forbidden",
        "get_forbidden_relations_used"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-30T11:20:39.249994",
        "modified": "2026-01-22T07:53:46.530164",
        "modified_days_ago": 29,
        "lines": 306,
        "size_bytes": 10738,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/efficiency_evidence.py",
      "name": "efficiency_evidence.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Efficiency Evidence Artifact for K6 benchmark runs capturing work rate, waste, and governance metrics.",
      "classes": [
        "EfficiencyEvidenceV1",
        "EfficiencyCollector"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "datetime",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.093724",
        "modified": "2026-01-22T07:53:46.529923",
        "modified_days_ago": 29,
        "lines": 442,
        "size_bytes": 16951,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/engine.py",
      "name": "engine.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Sterling's fence benchmark engine executes cases from validated manifests. It measures search performance and detects cheating via observables and analysis. Results are machine-parsable and auditable.",
      "classes": [
        "BenchmarkManifest",
        "FenceRunConfig",
        "FenceResult"
      ],
      "functions": [
        "_compute_hash",
        "create_manifest",
        "run_fence_case"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.benchmarks.fence.cheating",
        "core.reasoning.telemetry"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-10T15:57:22.776994",
        "modified": "2026-01-22T07:53:46.530063",
        "modified_days_ago": 29,
        "lines": 264,
        "size_bytes": 9675,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/fence_enforcement_suite.py",
      "name": "fence_enforcement_suite.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "K6.2 Fence Enforcement Suite runs mechanized tests to verify fence enforcement. It generates a FenceEnforcementSuiteResultV1 artifact for bundle inclusion.",
      "classes": [],
      "functions": [
        "run_fence_enforcement_suite"
      ],
      "imports": [
        "__future__",
        "logging",
        "datetime",
        "typing",
        "core.benchmarks.fence.k6_types",
        "core.operators.fence",
        "core.operators.registry",
        "core.reasoning.transactional_apply",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-30T12:38:17.467002",
        "modified": "2026-01-22T07:53:46.529879",
        "modified_days_ago": 29,
        "lines": 188,
        "size_bytes": 8882,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/fence_utils.py",
      "name": "fence_utils.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Helper functions for creating ApplyFence artifacts and validating K6 fence traces. Used by the Sterling benchmark harness for K6 proof runs.",
      "classes": [],
      "functions": [
        "load_apply_fence_from_artifact",
        "create_allowed_set_artifact"
      ],
      "imports": [
        "__future__",
        "core.benchmarks.fence.allowed_set",
        "core.induction.artifact_store",
        "core.operators.fence"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:50:36.105555",
        "modified": "2026-01-22T07:53:46.529907",
        "modified_days_ago": 29,
        "lines": 137,
        "size_bytes": 4884,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/k6_executor.py",
      "name": "k6_executor.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Executes K6 scenario cases using Sterling engine and evaluates success predicates for task types.",
      "classes": [
        "K6ManifestError"
      ],
      "functions": [
        "execute_k6_case",
        "_execute_wordnet_case",
        "_evaluate_success_predicate"
      ],
      "imports": [
        "__future__",
        "logging",
        "os",
        "random",
        "typing",
        "core.benchmarks.fence.policy_loader",
        "core.benchmarks.fence.scenario",
        "core.contracts.governance_status",
        "core.operators.fence",
        "core.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T01:45:34.520117",
        "modified": "2026-01-23T18:07:50.733228",
        "modified_days_ago": 28,
        "lines": 292,
        "size_bytes": 10438,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/k6_performance.py",
      "name": "k6_performance.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Tracks K6.2 performance metrics during execution, including timing and memory usage, for scaled run analysis.",
      "classes": [
        "ConfigTimingMetrics",
        "K6PerformanceMetrics",
        "PerformanceTracker",
        "PhaseTimer"
      ],
      "functions": [
        "get_memory_usage_mb",
        "get_directory_size_mb",
        "timed_execution"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "os",
        "time",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [
        "T"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.093821",
        "modified": "2026-01-22T07:53:46.529804",
        "modified_days_ago": 29,
        "lines": 308,
        "size_bytes": 10288,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/k6_runner.py",
      "name": "k6_runner.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Implements A/ B/ C fence runs using K6 safety checks and overlays; computes deterministic run and operator set hashes for governance; generates run manifests from verified operator and scenario inputs.",
      "classes": [],
      "functions": [
        "compute_operator_set_hash",
        "compute_run_id",
        "get_code_commit",
        "run_config_a",
        "run_config_b",
        "run_config_c",
        "_run_cases"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "subprocess",
        "typing",
        "core.benchmarks.fence.k6_safety_checks",
        "core.benchmarks.fence.k6_types",
        "core.benchmarks.fence.scenario",
        "core.induction.artifact_store",
        "core.induction.overlay_registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 262,
            "content": "# TODO: Get engine version from actual SterlingEngine",
            "file_path": "core/benchmarks/fence/k6_runner.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.201542",
        "modified": "2026-01-22T07:53:46.530123",
        "modified_days_ago": 29,
        "lines": 994,
        "size_bytes": 42094,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/k6_safety_checks.py",
      "name": "k6_safety_checks.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\":\"K6 Safety Checks: TC1 Regression and Invariance Verification. Must use GovernanceContext for strict operations. \n    Regress (witness) for promotion\n    ",
      "classes": [
        "StrictModeRequiresContextError",
        "TC1RegressionResult",
        "InvarianceCheckResult",
        "K6SafetyCheckResult"
      ],
      "functions": [
        "_resolve_governance_params",
        "run_tc1_regression_check",
        "run_invariance_check",
        "run_k6_safety_checks"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.governance.run_intent",
        "core.governance.gate_verdict",
        "core.governance.failure_witness"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.411726",
        "modified": "2026-01-26T06:12:48.411945",
        "modified_days_ago": 25,
        "lines": 807,
        "size_bytes": 33663,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/k6_types.py",
      "name": "k6_types.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\":\"Deterministic run and replay verification evidence configuration and hash derivation for K6 operator traces and allowed inputs.",
      "classes": [
        "FenceMode",
        "FenceConfigV1",
        "RunManifestV1",
        "ResultsSummaryV1",
        "KGDependencyV1",
        "ProofBundleManifestV1",
        "AppliedOperatorTraceV1",
        "OperatorSelectionRecordV1",
        "FenceEnforcementSuiteResultV1",
        "ReplayVerificationResultV1",
        "K6PerConfigEvidenceIndexV1",
        "K6BundleEvidenceIndexV1",
        "K6EvidenceIndexV1"
      ],
      "functions": [
        "ref_semantic_dict",
        "sorted_ref_list"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.202023",
        "modified": "2026-01-22T07:53:46.529992",
        "modified_days_ago": 29,
        "lines": 886,
        "size_bytes": 35589,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/operator_selection.py",
      "name": "operator_selection.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Operator selection rules must be pre-registered and enforced via K6-3 before A/ B/ C runs. Rule criteria include mdl_cost, pass_rate, hash with type and direction. Pre-registered rules prevent post-hoc selection.",
      "classes": [
        "SelectionCriterion",
        "CertifiedOperatorCandidate",
        "OperatorSelectionRule"
      ],
      "functions": [
        "create_default_selection_rule"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T01:14:11.000320",
        "modified": "2026-01-22T07:53:46.530111",
        "modified_days_ago": 29,
        "lines": 249,
        "size_bytes": 8912,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/operator_synthesizer.py",
      "name": "operator_synthesizer.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Operator Synthesizer Shim provides backward-compatible re-export of core.induction.operator_synthesizer symbols for fence imports. It emits a deprecation warning and must be phased out in favor of the canonical implementation.",
      "classes": [],
      "functions": [
        "_emit_deprecation_warning"
      ],
      "imports": [
        "__future__",
        "logging",
        "warnings",
        "core.induction.operator_synthesizer"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-17T21:59:02.227725",
        "modified": "2026-01-22T07:53:46.529890",
        "modified_days_ago": 29,
        "lines": 97,
        "size_bytes": 2442,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/policy_loader.py",
      "name": "policy_loader.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "K6 Policy Loader: Loads policy from ArtifactRef for deterministic A/ B/ C runs. Uses K6PolicyV1 config to enforce search constraints and feature weights.",
      "classes": [
        "K6PolicyV1"
      ],
      "functions": [
        "load_policy_from_ref",
        "create_default_policy"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.artifact_closure",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:50:36.105766",
        "modified": "2026-01-22T07:53:46.530289",
        "modified_days_ago": 29,
        "lines": 173,
        "size_bytes": 5860,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/proof_bundle.py",
      "name": "proof_bundle.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Creates and exports ProofBundle for independent replay verification using K6 evidence indices and manifest.",
      "classes": [
        "ProofBundle"
      ],
      "functions": [
        "ensure_artifact_self_describing",
        "create_proof_bundle",
        "finalize_bundle_with_replay",
        "setup_kg_replay_context",
        "_load_kg_artifact",
        "collect_kg_dependencies_from_registry"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.benchmarks.fence.k6_types",
        "core.canonicalization.hashes",
        "core.canonicalization.json",
        "core.induction.artifact_closure"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.760940",
        "modified": "2026-01-22T07:53:46.529977",
        "modified_days_ago": 29,
        "lines": 843,
        "size_bytes": 35766,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/proof_report_generator.py",
      "name": "proof_report_generator.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Generates a proof report from ProofBundle results and scenario data using K6 and artifact store information. Author: @darianrosebrook.",
      "classes": [
        "ProofReportData"
      ],
      "functions": [
        "_get_git_commit_hash",
        "_get_platform_string",
        "_get_execution_mode",
        "_generate_report_header",
        "generate_proof_report",
        "_load_report_data",
        "_generate_report_markdown"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "os",
        "platform",
        "subprocess",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761144",
        "modified": "2026-01-22T07:53:46.529865",
        "modified_days_ago": 29,
        "lines": 1662,
        "size_bytes": 80989,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/scenario.py",
      "name": "scenario.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Defines scenarios requiring induced operators for K6 proof runs and includes a gate to validate unsolvability by production operators.",
      "classes": [
        "InductionScenarioV1",
        "ScenarioGateResult",
        "ScenarioGateViolation"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T01:13:13.597471",
        "modified": "2026-01-22T07:53:46.530002",
        "modified_days_ago": 29,
        "lines": 111,
        "size_bytes": 3566,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/scenario_gate.py",
      "name": "scenario_gate.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Scenario Gate Runner (K6-1) verifies that a given scenario cannot be solved by production operators before A/ B/ C runs proceed.",
      "classes": [],
      "functions": [
        "run_scenario_gate",
        "_run_baseline_config_a"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.benchmarks.fence.scenario",
        "core.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:50:36.106112",
        "modified": "2026-01-22T07:53:46.530087",
        "modified_days_ago": 29,
        "lines": 262,
        "size_bytes": 9932,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/scenario_qualification.py",
      "name": "scenario_qualification.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Validates cases for K6 proof patterns by checking 2-hop paths and ensuring the operator set matches case assumptions using bounded BFS. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "validate_two_hop_one_budget_scenario",
        "_check_one_hop_reachable",
        "_compute_shortest_path_length",
        "_create_dummy_state",
        "find_wordnet_sibling_cases",
        "ensure_operator_set_alignment"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.benchmarks.fence.scenario",
        "core.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T03:11:40.355143",
        "modified": "2026-01-22T07:53:46.529963",
        "modified_days_ago": 29,
        "lines": 414,
        "size_bytes": 13887,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/selection_recorder.py",
      "name": "selection_recorder.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Records the pre-registered selection rule and certified operator candidates to enforce anti-cherry-pick. Must emit selection record before Config C execution. Used in K6 proof runs.",
      "classes": [
        "CandidateOperator"
      ],
      "functions": [
        "compute_rule_hash",
        "select_operator",
        "create_selection_record",
        "record_and_store_selection",
        "create_test_candidate"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.benchmarks.fence.k6_types",
        "core.induction.artifact_closure",
        "core.induction.artifact_store"
      ],
      "constants": [
        "SELECTION_RULE_V1"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T14:15:58.873783",
        "modified": "2026-01-22T07:53:46.530131",
        "modified_days_ago": 29,
        "lines": 267,
        "size_bytes": 8974,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/shadow_influence.py",
      "name": "shadow_influence.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\":\"Implements deterministic shadow influence scoring without applying operators. Provides audit trail.",
      "classes": [
        "ShadowInfluenceResult",
        "ShadowInfluenceWitness",
        "ShadowInfluenceConfigV2",
        "CandidateBreakdownV2",
        "ShadowInfluenceWitnessV2",
        "ShadowInfluenceCalculator"
      ],
      "functions": [
        "quantize_float",
        "dequantize_float",
        "create_shadow_influence_calculator",
        "serialize_shadow_witness",
        "deserialize_shadow_witness"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "FLOAT_QUANTIZATION_VERSION",
        "QUANTIZATION_FACTOR"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-17T22:04:49.763934",
        "modified": "2026-01-22T07:54:39.899675",
        "modified_days_ago": 29,
        "lines": 585,
        "size_bytes": 20941,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/test_certificate_creator.py",
      "name": "test_certificate_creator.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Creates a minimal test certificate for the SIBLING_ HOP operator in K6 Config C testing. Used to demonstrate capability lift without full operator synthesis.",
      "classes": [],
      "functions": [
        "create_test_certificate_for_sibling_hop"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.artifact_closure",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-30T11:41:19.782899",
        "modified": "2026-01-22T07:53:46.529938",
        "modified_days_ago": 29,
        "lines": 144,
        "size_bytes": 5620,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/test_operator_for_config_c.py",
      "name": "test_operator_for_config_c.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Creates a 2-hop sibling path operator for Config C testing in the K6 benchmarking context. Used to verify state graph hops in Sterling's reasoning.",
      "classes": [],
      "functions": [
        "create_sibling_hop_operator_impl"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.kernels.wordnet",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T12:07:24.302769",
        "modified": "2026-01-22T07:53:46.530082",
        "modified_days_ago": 29,
        "lines": 96,
        "size_bytes": 3891,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/trace_extractor.py",
      "name": "trace_extractor.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Extracts applied operator traces from FenceResult's traversed relations. Validates operator IDs against AllowedApplySetV1. Produces AppliedOperatorTraceV1 artifacts for K6 proof runs.",
      "classes": [
        "TraceExtractionResult",
        "TraceExtractor"
      ],
      "functions": [
        "extract_and_store_traces",
        "create_aggregate_trace_summary"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.benchmarks.fence.k6_types",
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.202613",
        "modified": "2026-01-22T07:53:46.530163",
        "modified_days_ago": 29,
        "lines": 300,
        "size_bytes": 10650,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/fence/trace_validator.py",
      "name": "trace_validator.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Extracts applied operator IDs from K6 traces and validates them against an allowed set for auditability.",
      "classes": [],
      "functions": [
        "extract_applied_operator_ids",
        "validate_fence_compliance",
        "validate_no_shadow_applied",
        "validate_trace_from_manifest"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.benchmarks.fence.allowed_set",
        "core.induction.artifact_store",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T01:38:09.064605",
        "modified": "2026-01-22T07:53:46.530156",
        "modified_days_ago": 29,
        "lines": 230,
        "size_bytes": 8348,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/harness_config.py",
      "name": "harness_config.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Configures and enforces benchmark world episode constraints including observability, deterministic checks, and quarantine requirements.",
      "classes": [
        "WorldHarnessConfig",
        "EpisodeTermination"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T03:47:28.671215",
        "modified": "2026-02-08T03:47:28.671356",
        "modified_days_ago": 12,
        "lines": 75,
        "size_bytes": 2619,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/pn_balanced_episodes.py",
      "name": "pn_balanced_episodes.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\n    \"success\": 0  # no op for REPROOF in\n    # each T task\n# 4.  # divide\n    # verify\n  # nq\n  # balanced\n  #  episode\n    # context (set)\n# 1.  # new\n#  # 0 (set\n    # 1.  # new episode from\n    # 1.  # new\n    # 0 (generate_pretext and test\n    # 0 (task\n    # 0 (front\n    # 1.0  # 1\n    # 0 (epis_  # 1\n    #  # 0 (class.  # 1.  # 0\n    # 1.  # 0\n    # 0  # 0",
      "classes": [
        "PNTaskType",
        "PNType",
        "PNEpisode",
        "BalancedPNConfig",
        "BalancedPNResult"
      ],
      "functions": [
        "compute_hash",
        "generate_is_pn_episode",
        "generate_explain_pn_episode",
        "generate_transform_episode",
        "generate_verify_episode",
        "generate_balanced_pn_episodes",
        "save_balanced_episodes",
        "load_balanced_episodes"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "random",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [
        "PN_EXAMPLES",
        "PN_OPERATORS",
        "TRANSFORM_EXAMPLES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:39:18.577879",
        "modified": "2026-01-22T07:53:46.529817",
        "modified_days_ago": 29,
        "lines": 507,
        "size_bytes": 15681,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/policy_protocol.py",
      "name": "policy_protocol.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Policy selection protocol that receives only Observation and LegalAction lists, enforcing kernel-level observability constraints. Used in the Unified World Harness for action selection without direct access to unobserved state.",
      "classes": [
        "Observation",
        "LegalAction",
        "Policy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T03:47:39.485973",
        "modified": "2026-02-08T03:47:39.486119",
        "modified_days_ago": 12,
        "lines": 78,
        "size_bytes": 2340,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/robustness_gate.py",
      "name": "robustness_gate.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "{\"description\":\"Evaluates episode trace against eight robustness gates: passed, violations, replay, checks, and locked operators for a poisoned curriculum\n",
      "classes": [
        "RobustnessGateConfig",
        "RobustnessViolation",
        "RobustnessGateResult"
      ],
      "functions": [
        "evaluate_robustness_gate",
        "_get_state",
        "_check_no_unvalidated_promotion",
        "_check_scoped_validity",
        "_check_quarantine_isolation",
        "_check_revocation_witnessing",
        "_check_revocation_irreversibility",
        "_check_replay_determinism",
        "_check_tool_transcript_boundary",
        "_check_no_hidden_router"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json",
        "core.benchmarks.episode_runner",
        "core.kernels.poisoned_curriculum"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T10:22:54.942364",
        "modified": "2026-02-15T10:22:54.942519",
        "modified_days_ago": 5,
        "lines": 582,
        "size_bytes": 21476,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "benchmarks/rome_demo.py",
      "name": "rome_demo.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"Runs A* and IDA* search algorithms on a graph at each step.",
      "classes": [
        "SearchStrategy",
        "SearchObservation",
        "SearchResult",
        "RomeSearchRunner",
        "ConvergenceMetrics",
        "RomeDemoResult",
        "RomeComparison"
      ],
      "functions": [
        "random_policy",
        "greedy_degree_policy",
        "bfs_policy",
        "run_rome_demo",
        "run_rome_comparison"
      ],
      "imports": [
        "__future__",
        "logging",
        "random",
        "collections",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.safeguards.oracle_separation",
        "core.worlds.rome_kg"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T03:03:38.788676",
        "modified": "2026-02-16T03:03:38.788812",
        "modified_days_ago": 4,
        "lines": 679,
        "size_bytes": 20914,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "benchmarks/stochastic_witness.py",
      "name": "stochastic_witness.py",
      "category": "K6 fence harness, proof runs, and certification testing",
      "status": "active",
      "description": "Records per-step RNG draws as a replay-verified transcript witness for stochastic benchmark domains. Enables Model A deterministic replay in certifying mode. Author: @darianrosebrook.",
      "classes": [
        "RngTranscriptWitnessV1"
      ],
      "functions": [
        "verify_rng_transcript_replay"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T00:30:25.682048",
        "modified": "2026-02-15T00:30:25.682181",
        "modified_days_ago": 6,
        "lines": 228,
        "size_bytes": 8104,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "canonicalization/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Deterministic canonicalization helpers (stdlib-only).",
      "classes": [],
      "functions": [],
      "imports": [
        "core.canonicalization.errors",
        "core.canonicalization.hashes",
        "core.canonicalization.json",
        "core.canonicalization.semantic",
        "core.canonicalization.witness"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761389",
        "modified": "2026-01-18T02:22:43.017200",
        "modified_days_ago": 33,
        "lines": 43,
        "size_bytes": 1484,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "canonicalization/errors.py",
      "name": "errors.py",
      "category": "Core module",
      "status": "active",
      "description": "Canonicalization error types.",
      "classes": [
        "CanonicalizationError",
        "StrictCanonicalizationError"
      ],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761519",
        "modified": "2026-01-22T07:53:46.530228",
        "modified_days_ago": 29,
        "lines": 11,
        "size_bytes": 280,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "canonicalization/hashes.py",
      "name": "hashes.py",
      "category": "Core module",
      "status": "active",
      "description": "Normalizes and validates various hash formats; strips and counts leading sha256: prefixes without digest validation.",
      "classes": [],
      "functions": [
        "_strip_hash_prefix",
        "_validate_hash_hex",
        "normalize_hash_id",
        "normalize_hash_permissive",
        "extract_hash_value",
        "parse_hash_id",
        "_strip_hash_prefixes",
        "_count_hash_prefixes",
        "validate_sha256_prefixed",
        "validate_sha256_hex64"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.canonicalization.errors"
      ],
      "constants": [
        "_HASH_PREFIX",
        "_HASH_HEX_LEN"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761626",
        "modified": "2026-01-22T07:53:46.530198",
        "modified_days_ago": 29,
        "lines": 291,
        "size_bytes": 9156,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "canonicalization/json.py",
      "name": "json.py",
      "category": "Core module",
      "status": "active",
      "description": "Serializes objects to canonical JSON strings and bytes for consistent comparison.",
      "classes": [],
      "functions": [
        "canonical_json_dumps",
        "canonical_json_bytes"
      ],
      "imports": [
        "__future__",
        "json",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761785",
        "modified": "2026-01-22T07:53:46.530255",
        "modified_days_ago": 29,
        "lines": 33,
        "size_bytes": 736,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "canonicalization/semantic.py",
      "name": "semantic.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides stable semantic canonicalization of dictionaries using type-ordered hashing for deterministic comparison.",
      "classes": [],
      "functions": [
        "_stable_sort_key",
        "semantic_dict_canonicalize",
        "stable_repr"
      ],
      "imports": [
        "__future__",
        "math",
        "typing",
        "core.canonicalization.errors",
        "typing"
      ],
      "constants": [
        "_TYPE_ORDER"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.761892",
        "modified": "2026-01-22T07:53:46.530261",
        "modified_days_ago": 29,
        "lines": 128,
        "size_bytes": 3892,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "canonicalization/versioned_hash.py",
      "name": "versioned_hash.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\": \"Versioned hashing for artifact identity, non-variant. Provide hash and a\n    # (opt) incremental\n    # (hash data\n    (opt) algorithm\n    # An ahash b\n    y for\n    versioned hashes. \n    e.g.,  (optional) hashes\n    # The\n    y  versioning (p)\n    # Hashing algorithm\n    y  scheme\n    #  hash r\n    e, p  r a hash\n    d  e  v  c  e  (  h  a  sh  a  (optional)  : use\n    heur  e  d  v1.  If\n    ver  if   g  (  :  a  sh  a  hash  (  e  version\n    #  a  g  e",
      "classes": [
        "VersionedHasher"
      ],
      "functions": [
        "hash_v1",
        "hash_v2_incremental",
        "versioned_hash",
        "verify_versioned_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [
        "CURRENT_HASH_VERSION"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T18:57:46.349079",
        "modified": "2026-01-23T20:36:52.055322",
        "modified_days_ago": 28,
        "lines": 213,
        "size_bytes": 6325,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "canonicalization/witness.py",
      "name": "witness.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides canonical witness functions for surface and goal signature verification in canonicalization tasks. Required by K1 success predicates and metrics dashboards for metric coherence. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "normalize_surface_for_match_v1",
        "surface_exact_match_v1",
        "compute_goal_signature_v1",
        "goal_signature_match_v1",
        "canonicalize_witness_v1",
        "get_witness_metadata"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "re",
        "unicodedata",
        "typing"
      ],
      "constants": [
        "CANONICALIZE_WITNESS_VERSION",
        "SURFACE_NORM_VERSION",
        "GOAL_SIGNATURE_VERSION",
        "WITNESS_TYPE_SURFACE_EXACT_MATCH",
        "WITNESS_TYPE_GOAL_SIGNATURE"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T02:22:24.655658",
        "modified": "2026-01-18T02:23:06.891627",
        "modified_days_ago": 33,
        "lines": 272,
        "size_bytes": 8867,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling capability capsules.\n\nCapsules are primitive-specific trace schemas and certification gates\nthat sit between domains (obligation specs) and worlds (adapters).\nEach capsule corresponds to one primitive from the catalog (P01-P21).",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.633373",
        "modified": "2026-02-18T20:34:13.633646",
        "modified_days_ago": 2,
        "lines": 6,
        "size_bytes": 245,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/capsule_spec.py",
      "name": "capsule_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "CapsuleSpecV1 defines the normative contract for a promoted capsule adjudicator or gate set extracted from demo. It hashes a canonical payload of its normative fields, excluding metadata, to produce a spec_id via SHA-256.",
      "classes": [
        "InvariantDeclaration",
        "SubstrateTierDecl",
        "SemanticAssumption",
        "CapsuleSpecV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "CAPSULE_SPEC_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.205233",
        "modified": "2026-02-20T09:33:53.205477",
        "modified_days_ago": 0,
        "lines": 320,
        "size_bytes": 11683,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "P01 Capsule: Deterministic Transformation Planning.\n\nTrace schema and signature gates for P01. The capsule owns exactly\nwhat the P01 spec requires: state digests, typed operator traces with\nper-step legality decisions, budget/consumption accounting, and the\nthree signature gates (determinism, boundedness, validity).",
      "classes": [],
      "functions": [],
      "imports": [
        "gates",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.633735",
        "modified": "2026-02-18T20:34:13.633826",
        "modified_days_ago": 2,
        "lines": 40,
        "size_bytes": 988,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/extensions/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "P01 extension gates for obligation-driven realization.\n\nThese are domain-specific extensions that build on the P01 capsule\ntrace schema. They are NOT part of the P01 signature gates \u2014 they\nrepresent additional claim boundaries (obligation coverage, vocabulary\nboundary, refusal audit completeness).",
      "classes": [],
      "functions": [],
      "imports": [
        "obligation_realization"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.633906",
        "modified": "2026-02-18T20:34:13.633988",
        "modified_days_ago": 2,
        "lines": 19,
        "size_bytes": 544,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/extensions/obligation_realization.py",
      "name": "obligation_realization.py",
      "category": "Core module",
      "status": "active",
      "description": "Obligation realization extension gates for P01. Verifies obligation coverage, enforces vocabulary boundary checks, and audits refusals with typed, level-aware records. Only imports from P01 trace types.",
      "classes": [],
      "functions": [
        "check_obligation_coverage",
        "check_vocabulary_boundary",
        "check_refusal_audit"
      ],
      "imports": [
        "__future__",
        "typing",
        "gates",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.634024",
        "modified": "2026-02-18T20:34:13.634193",
        "modified_days_ago": 2,
        "lines": 185,
        "size_bytes": 6184,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/gates.py",
      "name": "gates.py",
      "category": "Core module",
      "status": "active",
      "description": "P01 capsule trace validation via determinism, boundedness, and validity checks. Only P01 trace types are used; extensions handled in obligation_realization.",
      "classes": [
        "P01GateWitness",
        "P01GateBundle"
      ],
      "functions": [
        "check_determinism",
        "check_boundedness",
        "check_validity",
        "run_signature_gates"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.634234",
        "modified": "2026-02-18T20:34:13.634407",
        "modified_days_ago": 2,
        "lines": 189,
        "size_bytes": 5961,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/spec.py",
      "name": "spec.py",
      "category": "Core module",
      "status": "active",
      "description": "This MOC defines the build process for p01 capsule specification in Sterling, ensuring proper import handling and backward compatibility.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.capsules.p01_spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.205564",
        "modified": "2026-02-20T09:33:53.205894",
        "modified_days_ago": 3,
        "lines": 5,
        "size_bytes": 224,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p01/trace_types.py",
      "name": "trace_types.py",
      "category": "Core module",
      "status": "active",
      "description": "P01 trace representation with per-step legality decisions (legal/illegal/unknown), operator effects and produced artifacts, resource accounting (steps, nodes, edges), and refusal audit fields. Schema uses only core.verification. hash utilities for trace serialization.",
      "classes": [
        "P01LegalityDecision",
        "P01ProducedArtifact",
        "P01TransitionStep",
        "P01Budget",
        "P01Consumption",
        "P01PlanTrace"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_PLAN_TRACE_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.634450",
        "modified": "2026-02-18T20:34:13.634673",
        "modified_days_ago": 2,
        "lines": 283,
        "size_bytes": 9932,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p01_spec.py",
      "name": "p01_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "Builds the normative contract for P01, specifying required invariants, substrate tier, assumptions, and verification gates. Ensures trace contract without domain-specific content; placed outside p01/ to avoid runtime import leakage.",
      "classes": [],
      "functions": [
        "build_p01_capsule_spec"
      ],
      "imports": [
        "__future__",
        "core.capsules.capsule_spec"
      ],
      "constants": [
        "_P01_FORMAL_SIGNATURE",
        "_P01_INVARIANTS",
        "_P01_SUBSTRATE_TIERS",
        "_P01_SEMANTIC_ASSUMPTIONS",
        "_P01_EXTENSION_IDS",
        "_P01_VERIFICATION_GATE_IDS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.205958",
        "modified": "2026-02-20T09:33:53.206275",
        "modified_days_ago": 0,
        "lines": 184,
        "size_bytes": 6451,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p06/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "P06 Capsule: Bounded Best-First Search Under Scarcity.\n\nTrace schema, search algorithm, and signature gates for P06. The capsule\nowns the search loop, budget enforcement (all four knobs), deterministic\noperator ordering, frontier cap enforcement with eviction, path\nreconstruction, and per-step statistics.",
      "classes": [],
      "functions": [],
      "imports": [
        "gates",
        "search",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T11:44:59.705728",
        "modified": "2026-02-20T11:44:59.705945",
        "modified_days_ago": 0,
        "lines": 45,
        "size_bytes": 1151,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p06/gates.py",
      "name": "gates.py",
      "category": "Core module",
      "status": "active",
      "description": "P06 Signature Gates: Enforces boundedness, verifies typed failures, checks determinism on P06 capsule traces. Run as part of P06 validation.",
      "classes": [
        "P06GateWitness",
        "P06GateBundle"
      ],
      "functions": [
        "check_boundedness",
        "check_typed_failure",
        "check_determinism",
        "run_gates"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T11:44:59.705983",
        "modified": "2026-02-20T11:44:59.706320",
        "modified_days_ago": 0,
        "lines": 186,
        "size_bytes": 5577,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p06/search.py",
      "name": "search.py",
      "category": "Core module",
      "status": "active",
      "description": "P06 Search Algorithm: Bounded Best-First Search Under Scarcity.\n\nDomain-independent search with frontier capping and eviction. The capsule\nowns all four budget knobs: ``max_ops``, ``max_steps``, ``max_frontier``,\nand ``max_edits_per_step`` -- including deterministic operator ordering\nand per-step truncation.",
      "classes": [],
      "functions": [
        "bounded_best_first_search"
      ],
      "imports": [
        "__future__",
        "heapq",
        "typing",
        "trace_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T11:44:59.706361",
        "modified": "2026-02-20T11:44:59.706618",
        "modified_days_ago": 0,
        "lines": 255,
        "size_bytes": 8737,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p06/trace_types.py",
      "name": "trace_types.py",
      "category": "Core module",
      "status": "active",
      "description": "SearchStatus (SOLVED/EXPANalyzed (step,  opnext_state,  path,  node preconditions,  \n    operator execution status  \n    (SOLed)  \n    search node (state)  \n    expansions;  path,  choice list  \n    (premations)  \n    execution  \n    (pre-) states.  \n    valid  \n    op;  states  \n    path/choice JSON  \n    for    trace  \n    recording of node  \n    status and  \n    expansion  \n    as execution  \n    in event  \n    nodes  \n    (step)  \n    choices.",
      "classes": [
        "SearchStatus",
        "SearchBudgetV1",
        "OpKeyV1",
        "EvictionEventV1",
        "StepStatsV1",
        "SearchResultV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "enum",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_SEARCH_TRACE_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T11:44:59.706670",
        "modified": "2026-02-20T11:44:59.706979",
        "modified_days_ago": 0,
        "lines": 248,
        "size_bytes": 8228,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p06_spec.py",
      "name": "p06_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "P06 Capsule Spec: CapsuleSpecV1 declaration for bounded best-first search.\n\nBuilds the normative contract for P06 \u2014 the goal-conditioned valuation\nunder scarcity capsule. Declares what P06 guarantees (invariants), what\nsubstrate it requires (tier), what assumptions it makes, and what gates\nverify compliance.",
      "classes": [],
      "functions": [
        "build_p06_capsule_spec"
      ],
      "imports": [
        "__future__",
        "core.capsules.capsule_spec"
      ],
      "constants": [
        "_P06_FORMAL_SIGNATURE",
        "_P06_INVARIANTS",
        "_P06_SUBSTRATE_TIERS",
        "_P06_SEMANTIC_ASSUMPTIONS",
        "_P06_VERIFICATION_GATE_IDS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-22T12:13:23.793124",
        "modified": "2026-02-22T12:13:23.793378",
        "modified_days_ago": 0,
        "lines": 173,
        "size_bytes": 6154,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "P22 capsule scaffold.\n\nCapsule modules are domain-agnostic and must not import worlds, demos, or\nexperiments.",
      "classes": [],
      "functions": [],
      "imports": [
        "adapters",
        "canonical_json",
        "capsule_spec",
        "operators_p22_intent",
        "operators_p22a",
        "operators_p22c",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-23T17:16:18.815582",
        "modified": "2026-02-23T17:16:18.815749",
        "modified_days_ago": 0,
        "lines": 56,
        "size_bytes": 1408,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/adapters.py",
      "name": "adapters.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides access to pre-recorded realization assets via fixed mapping. SenseAdapter and RealizeAdapter bridge capsules to external data; fixture adapters load candidate evidence for replay, live adapters interface to real models.",
      "classes": [
        "SenseAdapter",
        "RealizeAdapter",
        "FixtureSenseAdapter",
        "FixtureRealizeAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "pathlib",
        "typing",
        "errors",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-23T17:16:18.815811",
        "modified": "2026-02-23T17:16:18.815931",
        "modified_days_ago": 0,
        "lines": 81,
        "size_bytes": 2711,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/canonical_json.py",
      "name": "canonical_json.py",
      "category": "Core module",
      "status": "active",
      "description": "Deterministic JSON helpers for P22.\n\nThese helpers define canonical serialization used for hashing and replay-grade\nfixtures.",
      "classes": [],
      "functions": [
        "canonical_json_bytes",
        "sha256_prefixed",
        "sha256_json_prefixed"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing"
      ],
      "constants": [
        "_P22_JSON_KWARGS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.578938",
        "modified": "2026-02-21T15:51:43.579132",
        "modified_days_ago": 0,
        "lines": 40,
        "size_bytes": 1296,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/capsule_spec.py",
      "name": "capsule_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "Bridges P22 capsule specification to normative D2 formal specification via build_p22_capsule_spec and p22_spec_digest functions.",
      "classes": [],
      "functions": [
        "build_p22_capsule_spec",
        "p22_spec_digest"
      ],
      "imports": [
        "__future__",
        "typing",
        "primitives_proposed.p22.formal_spec_p22"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T18:09:55.220607",
        "modified": "2026-02-20T18:09:55.223191",
        "modified_days_ago": 0,
        "lines": 18,
        "size_bytes": 404,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/errors.py",
      "name": "errors.py",
      "category": "Core module",
      "status": "active",
      "description": "Typed errors for P22 fail-closed behavior.",
      "classes": [
        "P22Failure",
        "P22Error",
        "P22BudgetExceededError",
        "P22SchemaMismatchError",
        "P22VerificationFailedError"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T18:01:32.253195",
        "modified": "2026-02-20T18:10:47.317129",
        "modified_days_ago": 0,
        "lines": 35,
        "size_bytes": 854,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/operators_p22_intent.py",
      "name": "operators_p22_intent.py",
      "category": "Core module",
      "status": "active",
      "description": "This MOC operator derives a RenderIntent from a committed PerceptState.",
      "classes": [],
      "functions": [
        "derive_render_intent"
      ],
      "imports": [
        "__future__",
        "typing",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-23T17:16:18.815971",
        "modified": "2026-02-23T17:16:18.816091",
        "modified_days_ago": 0,
        "lines": 29,
        "size_bytes": 1008,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/operators_p22a.py",
      "name": "operators_p22a.py",
      "category": "Core module",
      "status": "active",
      "description": "P22-A commit operator scaffolding.",
      "classes": [
        "P22BudgetsV1"
      ],
      "functions": [
        "_poly_to_bbox",
        "_candidate_bbox",
        "_choose_best_by_label",
        "commit_p22a_from_observation"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "errors",
        "types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:11:21.240424",
        "modified": "2026-02-21T15:11:21.240535",
        "modified_days_ago": 0,
        "lines": 107,
        "size_bytes": 3404,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/operators_p22c.py",
      "name": "operators_p22c.py",
      "category": "Core module",
      "status": "active",
      "description": "Verifies P22-C realization using schema and object checks; commits rendered assets only upon successful validation with fail-closed gates.",
      "classes": [],
      "functions": [
        "verify_objects_present",
        "commit_rendered_asset"
      ],
      "imports": [
        "__future__",
        "typing",
        "errors",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-23T17:16:18.816188",
        "modified": "2026-02-23T17:16:18.816308",
        "modified_days_ago": 0,
        "lines": 87,
        "size_bytes": 3285,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/register_p22.py",
      "name": "register_p22.py",
      "category": "Core module",
      "status": "active",
      "description": "provides p22_schema_dir, register_p22_schemas.",
      "classes": [],
      "functions": [
        "p22_schema_dir",
        "register_p22_schemas"
      ],
      "imports": [
        "__future__",
        "pathlib"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:11:21.241028",
        "modified": "2026-02-21T15:11:21.241126",
        "modified_days_ago": 0,
        "lines": 21,
        "size_bytes": 941,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p22/types.py",
      "name": "types.py",
      "category": "Core module",
      "status": "active",
      "description": "Defines MediaAssetRefV1, TimelineRefV1, PerceptCandidateV0 and provides observation_from_dict, render_intent_from_dict.",
      "classes": [
        "MediaAssetRefV1",
        "TimelineRefV1",
        "PerceptCandidateV0",
        "PerceptObservationIRv0",
        "PerceptAtomV1",
        "PerceptStateV1",
        "RenderIntentV1",
        "VerificationFailureV1",
        "VerificationReportV1"
      ],
      "functions": [
        "observation_from_dict",
        "render_intent_from_dict"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "canonical_json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:11:21.241452",
        "modified": "2026-02-21T15:11:21.241722",
        "modified_days_ago": 0,
        "lines": 206,
        "size_bytes": 6213,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "capsules/p25_lo_spec.py",
      "name": "p25_lo_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Morphosyntactic transformation algebra; state of the P25.LO contract for the linguistic state machine.",
      "classes": [],
      "functions": [
        "build_p25_lo_capsule_spec"
      ],
      "imports": [
        "__future__",
        "core.capsules.capsule_spec"
      ],
      "constants": [
        "_P25_LO_FORMAL_SIGNATURE",
        "_P25_LO_INVARIANTS",
        "_P25_LO_SUBSTRATE_TIERS",
        "_P25_LO_SEMANTIC_ASSUMPTIONS",
        "_P25_LO_EXTENSION_IDS",
        "_P25_LO_VERIFICATION_GATE_IDS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-22T12:28:09.420513",
        "modified": "2026-02-22T12:28:09.421642",
        "modified_days_ago": 0,
        "lines": 265,
        "size_bytes": 10239,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Carrier Layer: Hardware-native byte substrate for evidence and computation.\n\nThis package implements the Code32/ByteState carrier substrate (Layer 2 of the\nSterling architecture). V1 provides evidence-only trajectory traces with\ndeterministic replay verification.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.carrier.code32"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T01:10:30.947134",
        "modified": "2026-02-16T01:10:30.947274",
        "modified_days_ago": 5,
        "lines": 34,
        "size_bytes": 925,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/artifact_writer.py",
      "name": "artifact_writer.py",
      "category": "Core module",
      "status": "active",
      "description": "ByteTraceV1 payload writer with atomic file operations and verify-on-write using payload_ hash.",
      "classes": [
        "PayloadHashMismatch",
        "ByteTraceArtifactWriter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "os",
        "tempfile",
        "pathlib",
        "typing",
        "core.carrier.bytetrace"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T02:53:34.057943",
        "modified": "2026-02-16T02:53:34.058094",
        "modified_days_ago": 4,
        "lines": 116,
        "size_bytes": 3988,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "carrier/bytestate.py",
      "name": "bytestate.py",
      "category": "Core module",
      "status": "active",
      "description": "ByteStateV1 encodes semantic state in two planes: identity (Code32 atoms) and status (SlotStatus bytes). Each layer's identity hash is isolated from governance changes by plane separation. Schema bundles use domain-qualified hashes for type safety.",
      "classes": [
        "ByteStateSchema",
        "ByteStateV1"
      ],
      "functions": [
        "compute_schema_bundle_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "core.carrier.code32",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_IDENTITY_HASH_PREFIX",
        "_EVIDENCE_HASH_PREFIX",
        "_SCHEMA_BUNDLE_HASH_PREFIX",
        "BYTESTATE_STATUS_ENCODING_V1"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T10:34:47.421887",
        "modified": "2026-02-16T10:34:47.422311",
        "modified_days_ago": 4,
        "lines": 211,
        "size_bytes": 7548,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/bytetrace.py",
      "name": "bytetrace.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"operator\": \"ByteTrace::V1\\0a, b\" + bytes([_operator_code,  opcodes,  slots, b\" operator slot, b\" + 3 (op / 0 (max) (len 7, b'\\x00' + b' ' slot, b'0' + 7 b' ' slot, 1 g: a hash => (sha256, b' 1, a hash => (sha256), b' 0, a => (sk[0, 3 with check, b' 0 at class, c => (class instance) via hash 0, b\" slot, g: a hash => (shard) @class: ByteTraceEnvelope, b\" (max) 32 (b'0s [l1] (max) b\" slot\" h'  {",
      "classes": [
        "ByteTraceEnvelope",
        "ByteTraceHeader",
        "ByteTraceFooter",
        "ByteTraceV1",
        "ByteTraceBuilder"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "struct",
        "dataclasses",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.code32",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_PAYLOAD_HASH_PREFIX",
        "_MAGIC"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T12:50:56.450948",
        "modified": "2026-02-18T12:50:56.451093",
        "modified_days_ago": 2,
        "lines": 414,
        "size_bytes": 13531,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/code32.py",
      "name": "code32.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"\\x01  b'...' (len=1\n    b'... (len=4\n    b'... (hash input len=32 b'... (shard\n    b'...' (hash, 0, 4,  # 1\n            b'...' (  # 0\n            b'...' (maxlen, other\n            len  slot\n                min len 0; i, a, a\n                JSON b'...' (len=32 - b'... (hash = b'... ( slot\n                . 0\n                    b'...",
      "classes": [
        "SlotStatus",
        "Code32"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "struct",
        "dataclasses",
        "enum"
      ],
      "constants": [
        "PADDING_SENTINEL",
        "INITIAL_STATE_SENTINEL",
        "TERMINAL_SENTINEL"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T17:03:27.777237",
        "modified": "2026-02-16T17:03:27.777352",
        "modified_days_ago": 4,
        "lines": 150,
        "size_bytes": 5198,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/collector.py",
      "name": "collector.py",
      "category": "Core module",
      "status": "active",
      "description": "ByteTraceCollector accumulates StepEvents and compiles them into ByteTraceV1 via compiler or fallback _materialize_step_log(). It enforces event canonization and monotonic step indices, never storing dicts during capture. Used as an inline StepEvent sink.",
      "classes": [
        "ByteTraceCollector"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.carrier.bytetrace",
        "core.carrier.compiler",
        "core.carrier.step_event"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T05:26:40.780164",
        "modified": "2026-02-17T05:26:40.780466",
        "modified_days_ago": 3,
        "lines": 364,
        "size_bytes": 14872,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "carrier/compiler.py",
      "name": "compiler.py",
      "category": "Core module",
      "status": "active",
      "description": "Compilation Boundary: base types for domain payload \u2194 ByteState codec.\n\nThe compilation boundary is the governed interface between dynamic domain\npayloads (Python objects, step logs) and the frozen ByteState substrate.\nCompilation is a pure function: same inputs \u2192 same bytes. Fail-closed on\nany mismatch.\n\nAuthor: @darianrosebrook",
      "classes": [
        "CompilationFailure",
        "StepLogValidationResult",
        "StepLogValidator",
        "RegistrySnapshotV1",
        "DomainCompiler"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.bytetrace",
        "core.carrier.code32",
        "core.carrier.operator_codebook",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_REGISTRY_HASH_PREFIX",
        "_DEFAULT_FORBIDDEN_PATTERNS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T07:18:45.648148",
        "modified": "2026-02-16T07:18:45.648521",
        "modified_days_ago": 5,
        "lines": 399,
        "size_bytes": 14162,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/operator_codebook.py",
      "name": "operator_codebook.py",
      "category": "Core module",
      "status": "active",
      "description": "OperatorCodeBookV1 maps domain actions to unique uint32 codes per epoch, with codebook_hash in ByteTraceHeader to ensure operator code stability and trace interpretability across runs.",
      "classes": [
        "OperatorCodeEntry",
        "OperatorCodeBookV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_CODEBOOK_HASH_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T09:40:35.282534",
        "modified": "2026-02-16T09:40:35.282942",
        "modified_days_ago": 4,
        "lines": 124,
        "size_bytes": 4153,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/packed_frontier.py",
      "name": "packed_frontier.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"operator\": \"core carrier with binding provenance for buffer constructs data\n    via  parsing functions from idempotent operator parsing library.  Parse tree for raw bytes.  Operative checks (guar  g  (current_verse, strict (must  verify).  Packed frontier (well-formed) on receive  check.  Can parse  message  as  (struct for  data  not  optional.",
      "classes": [
        "PackedFrontierV1"
      ],
      "functions": [
        "compute_packed_frontier_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "struct",
        "core.carrier.bytestate",
        "core.proofs.benchmark_artifacts",
        "core.verification.hash_utils"
      ],
      "constants": [
        "MAGIC",
        "VERSION",
        "BYTE_ORDER_LE",
        "MIN_HEADER_LEN",
        "DEFAULT_HEADER_LEN",
        "FLAG_HAS_STATEKEYS",
        "FLAG_HAS_CODEBOOK_HASH",
        "ORDERING_RULE_MAP",
        "ORDERING_RULE_REVERSE",
        "_HEADER_BASE_FMT"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T16:42:52.486866",
        "modified": "2026-02-16T16:42:52.487019",
        "modified_days_ago": 4,
        "lines": 487,
        "size_bytes": 16904,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "carrier/partitioner.py",
      "name": "partitioner.py",
      "category": "Core module",
      "status": "active",
      "description": "BucketPartitioner: Allocates Code32 codes deterministically from concept sets with domain-specific kind overrides for EscapeGame (player=1, blocker=2) and reserved kind local IDs to prevent collisions.",
      "classes": [],
      "functions": [
        "allocate_codes"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.carrier.code32"
      ],
      "constants": [
        "ESCAPEGAME_PLAYER_KIND",
        "ESCAPEGAME_BLOCKER_KIND",
        "ESCAPEGAME_DIRECTION_KIND",
        "LOCAL_ID_CAP"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T14:06:55.809115",
        "modified": "2026-02-16T14:06:55.809338",
        "modified_days_ago": 4,
        "lines": 171,
        "size_bytes": 6344,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/schemas/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Domain-specific ByteState schemas and compilers.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T01:10:32.113149",
        "modified": "2026-02-16T01:10:32.113316",
        "modified_days_ago": 5,
        "lines": 1,
        "size_bytes": 55,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "carrier/schemas/escapegame_schema.py",
      "name": "escapegame_schema.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"compiles EscapeGame state to ByteState with kind (player and blockers.  \n  compiles (internal moves as step log data  \n    (Puzzle piece positions  \n    (0, player id.  \n    (external)  \n    valid board  \n    (state) and  \n    transitions  \n    for  \n    (valid)  \n    (Puzzle)  \n    (optional)  \n    coordinates.",
      "classes": [
        "EscapeGameCompiler"
      ],
      "functions": [
        "cell_index",
        "index_to_cell"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.bytetrace",
        "core.carrier.code32",
        "core.carrier.compiler",
        "core.carrier.operator_codebook",
        "core.carrier.partitioner",
        "core.carrier.step_event"
      ],
      "constants": [
        "EXIT_MARKER_LOCAL_ID",
        "ESCAPEGAME_DOMAIN_BYTE",
        "KIND_PLAYER",
        "KIND_BLOCKER",
        "KIND_DIRECTION",
        "DIRECTION_LEFT",
        "DIRECTION_RIGHT",
        "DIRECTION_UP",
        "DIRECTION_DOWN",
        "BOARD_WIDTH"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T12:06:49.021923",
        "modified": "2026-02-16T12:06:49.022061",
        "modified_days_ago": 4,
        "lines": 434,
        "size_bytes": 16877,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/schemas/mastermind_schema.py",
      "name": "mastermind_schema.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"type\":\"schema\",\"description\":\"...\",\"game_id\":\"mastermind\",\"guess_type\":\"literal\",\"bytecode\":\".",
      "classes": [
        "MastermindCompiler"
      ],
      "functions": [
        "encode_guess",
        "decode_guess",
        "encode_feedback",
        "decode_feedback"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.bytetrace",
        "core.carrier.code32",
        "core.carrier.compiler",
        "core.carrier.operator_codebook",
        "core.carrier.step_event"
      ],
      "constants": [
        "MASTERMIND_DOMAIN_BYTE",
        "KIND_GUESS",
        "KIND_FEEDBACK",
        "KIND_META",
        "MASTERMIND_SCHEMA",
        "_REQUIRED_STEP_FIELDS",
        "_MASTERMIND_STEP_LOG_VALIDATOR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T07:19:11.490182",
        "modified": "2026-02-16T07:19:11.490355",
        "modified_days_ago": 4,
        "lines": 413,
        "size_bytes": 15723,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/schemas/rome_schema.py",
      "name": "rome_schema.py",
      "category": "Core module",
      "status": "active",
      "description": "Compiles Rome domain states and step logs to ByteState/ByteTrace formats using provided schema and codebook.",
      "classes": [
        "RomeCompiler"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "struct",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.bytetrace",
        "core.carrier.code32",
        "core.carrier.compiler",
        "core.carrier.operator_codebook",
        "core.carrier.step_event"
      ],
      "constants": [
        "ROME_DOMAIN_BYTE",
        "ROME_SCHEMA",
        "_REQUIRED_STEP_FIELDS",
        "_ROME_STEP_LOG_VALIDATOR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T07:19:02.528463",
        "modified": "2026-02-16T07:19:02.528743",
        "modified_days_ago": 4,
        "lines": 381,
        "size_bytes": 13725,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/schemas/wordnet_schema.py",
      "name": "wordnet_schema.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Compiles synsets to Code32 via a deterministic finite state machine\n",
      "classes": [
        "WordNetCompiler"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "core.carrier.bytestate",
        "core.carrier.bytetrace",
        "core.carrier.code32",
        "core.carrier.compiler",
        "core.carrier.operator_codebook",
        "core.carrier.step_event"
      ],
      "constants": [
        "WORDNET_DOMAIN_BYTE",
        "WORDNET_SCHEMA",
        "_REQUIRED_STEP_FIELDS",
        "_WORDNET_STEP_LOG_VALIDATOR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T07:19:30.107971",
        "modified": "2026-02-16T07:19:30.108149",
        "modified_days_ago": 4,
        "lines": 385,
        "size_bytes": 13900,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "carrier/step_event.py",
      "name": "step_event.py",
      "category": "Core module",
      "status": "active",
      "description": "Typed step events for inline ByteTrace collection.\n\nKernel-agnostic event protocol: the solver's hot path emits typed\nStepEvents; the orchestrator routes them to a StepEventSink (e.g.\nByteTraceCollector) that decides whether and how to compile them.\n\nThis decouples the solver from ByteState internals: the solver never\nimports Code32, ByteStateSchema, or ByteTraceBuilder.",
      "classes": [
        "InitialStateEvent",
        "TransitionEvent",
        "TerminalEvent",
        "StepEventSink"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T03:01:07.946964",
        "modified": "2026-02-16T03:01:07.947336",
        "modified_days_ago": 4,
        "lines": 84,
        "size_bytes": 2704,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "carrier/telemetry.py",
      "name": "telemetry.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides timing aggregation for compilation path monitoring in L1-L2 boundary. Thread-safe telemetry collection via TelemetrySink. Captures fast path success, compile and validation time in nanoseconds, event count, and optional fallback reason.",
      "classes": [
        "CompilationFailureCode",
        "CompilationTelemetry",
        "TelemetrySink"
      ],
      "functions": [
        "time_ns_call",
        "compile_step_log_with_telemetry"
      ],
      "imports": [
        "__future__",
        "threading",
        "time",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "DEFAULT_DETAILS_CAP"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T05:26:40.780588",
        "modified": "2026-02-17T05:26:40.780733",
        "modified_days_ago": 3,
        "lines": 243,
        "size_bytes": 9110,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "certification/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T02:14:14.406529",
        "modified": "2026-01-25T02:14:14.406529",
        "modified_days_ago": 29,
        "lines": 0,
        "size_bytes": 0,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "certification/discriminative_episode_set.py",
      "name": "discriminative_episode_set.py",
      "category": "Core module",
      "status": "active",
      "description": "Discriminative EpisodeSet: Pinned episode artifacts for CI verification. Provides Deterministic episode content hashes for operator validation.",
      "classes": [
        "InvalidManifestError",
        "DiscriminativeEpisodeSetManifest",
        "DiscriminativeSetVerificationError",
        "DiscriminativeSetVerificationResult"
      ],
      "functions": [
        "compute_episode_content_hashes",
        "_is_placeholder",
        "verify_discriminative_set"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.governance.canonical_hash"
      ],
      "constants": [
        "_PLACEHOLDER_PATTERNS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T05:03:29.511453",
        "modified": "2026-01-25T05:03:29.511592",
        "modified_days_ago": 26,
        "lines": 640,
        "size_bytes": 25323,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/__init__.py",
      "name": "__init__.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "Sterling Contracts Layer.\n\nProvides semantic edits API and invariant checking infrastructure for\nprovenance tracking and anti-drift guardrails.\n\nPer TD-6 Architecture:\n- Operators emit structured SemanticEdits (not ad-hoc mutations)\n- EditDelta tracks pre/post state with provenance\n- Invariants operate on EditDelta for enforceable guardrails\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "_get_invariants",
        "__getattr__"
      ],
      "imports": [
        "core.contracts.goal_signature",
        "core.contracts.governance_status",
        "core.contracts.operator_application",
        "core.contracts.semantic_edits"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T07:13:28.521960",
        "modified": "2026-01-26T07:13:28.522289",
        "modified_days_ago": 25,
        "lines": 204,
        "size_bytes": 5877,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/artifact_identity.py",
      "name": "artifact_identity.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "Authoritative artifact identity core (Layer A) defines and enforces content-based identity for artifacts.",
      "classes": [
        "ArtifactIdentity"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T18:51:15.244925",
        "modified": "2026-01-24T18:51:15.245030",
        "modified_days_ago": 27,
        "lines": 46,
        "size_bytes": 1327,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "contracts/goal_signature.py",
      "name": "goal_signature.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "{\"tokens\": {\"__line__ contains\n  (str) signifies\n  canonical\n  path for\n  tokens\n  verification\n  stage: 0  canonical NLP  (key) \n  only  (signs) 0  tokens\n 0  (se)  for\n  canonical  (se) from  tokens \n 0 (se)  key\n 1  verification\n  returns 0  only\n  (se)  holds \n 1  value\n  returns  the  canonical \n  form to  model.",
      "classes": [
        "TokenizationProvenance",
        "TokenizationProvenanceError",
        "PolarityProvenance",
        "CanonicalizeGoalSignatureV1",
        "SignatureWitness"
      ],
      "functions": [
        "_extract_tokens_lower",
        "_has_negation_token",
        "_has_clitic_copula_token",
        "_has_copula_lexeme",
        "compute_signature_from_tokens",
        "compute_expected_signature",
        "compute_expected_signature_with_provenance",
        "compute_final_signature",
        "compute_final_signature_with_provenance",
        "compute_signature_from_utterance"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "GOAL_SIGNATURE_VERSION",
        "TOKENIZER_SOURCE_DEFAULT",
        "TOKENIZER_SOURCE_SYNTAX_LAYER",
        "BE_FORMS",
        "CLITIC_COPULA_PATTERNS",
        "POLARITY_SOURCE_SEMANTICS",
        "POLARITY_SOURCE_TASK_METADATA",
        "POLARITY_SOURCE_REQUEST_INPUT",
        "POLARITY_SOURCE_SURFACE_INFERENCE",
        "POLARITY_SOURCE_DEFAULT"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-17T03:55:26.874822",
        "modified": "2026-01-22T07:53:46.506742",
        "modified_days_ago": 29,
        "lines": 679,
        "size_bytes": 23344,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/governance_status.py",
      "name": "governance_status.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "{\"status\":\"error status of checks\",\"reason\":\"...\"}\n{\"status\":\"the current status of this item\",\"location\":\"... not found. Check state at promotion mints\n    \"not found\" when checked against the following the checks\n    1. No- after the fact\n    governance status to track\n    the trusted source\n    when found, status not\n    applicable\n    When- status is\n    unverified\n    with reason and no- optional\n    signals are\n    from L2.",
      "classes": [
        "ArtifactBindingStatus",
        "GovernanceCheckStatus",
        "ExecutionStatus",
        "ArtifactRefWithStatus",
        "GovernanceCheckResult",
        "ExecutionStatusResult",
        "CertifyingRunContext"
      ],
      "functions": [
        "validate_artifact_refs_for_strict_mode",
        "validate_governance_checks_for_strict_mode"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [
        "REASON_ORACLE_STUBBED_CONTRADICTION_CHECK",
        "REASON_ORACLE_STUBBED_SAFETY_CHECK",
        "REASON_TIER_NOT_REQUIRED",
        "REASON_VALIDATION_NOT_RUN",
        "REASON_FILES_MISSING",
        "REASON_NOT_IMPLEMENTED",
        "REASON_UNSUPPORTED_TASK_TYPE",
        "REASON_SEARCH_NOT_EXECUTED",
        "REASON_VALUE_HEAD_MODEL_UNPINNED",
        "REASON_VALUE_HEAD_UNAVAILABLE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.412274",
        "modified": "2026-01-26T06:12:48.412484",
        "modified_days_ago": 25,
        "lines": 633,
        "size_bytes": 21801,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "contracts/invariant_fuzzer.py",
      "name": "invariant_fuzzer.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "{\n    \"description\": \"Implements structural fuzzing and semantic adversary testing on rulesets\n    \"\"\"\n    from core import (Kinds, K6, K invariants from core/invariants\n    \"\"\" rule 10 \"\"\"\n    from core import (RuleType, rule, rule classes\n    from core/invariants\n    \"\"\"\n    from core import (assertions, context\n    from core/semantic_edits\n    \"\"\" test track \"\"\"\n    @property\n    derived from  semantic\n    \"\"\"\n    \"\"\" 0  \"\"\"\n    from  core  semantic\n    \"\"\"  test track to  \"\"\"\n    from ...",
      "classes": [
        "SafetyViolationType",
        "SafetyViolation",
        "FuzzingResults",
        "SemanticAdversary",
        "AdversarySuccess",
        "AdversaryFailure",
        "AdversaryResults",
        "StructuralFuzzer",
        "SemanticAdversaryRunner",
        "InvariantCompletenessReport"
      ],
      "functions": [
        "run_invariant_completeness_test"
      ],
      "imports": [
        "__future__",
        "logging",
        "random",
        "traceback",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.contracts.invariants",
        "core.contracts.semantic_edits"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T11:55:34.857135",
        "modified": "2026-01-22T07:53:46.506816",
        "modified_days_ago": 29,
        "lines": 928,
        "size_bytes": 30192,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/invariants.py",
      "name": "invariants.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "Sterling Anti-Drift Guardrails.",
      "classes": [
        "IdentityLock",
        "ProvenanceGate",
        "WordNetConstraintProp",
        "PNConstraintProp",
        "InvariantRegistry",
        "CodeConstraintProp"
      ],
      "functions": [
        "create_default_invariants",
        "create_strict_invariants",
        "create_wordnet_invariants",
        "create_pn_invariants",
        "create_code_invariants"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.contracts.semantic_edits",
        "core.reasoning.transactional_apply"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:31:01.441136",
        "modified": "2026-01-22T07:53:46.506725",
        "modified_days_ago": 32,
        "lines": 742,
        "size_bytes": 25318,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/operator_application.py",
      "name": "operator_application.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "Canonical OperatorApplication Contract.\n\nPRE-10.2: Single canonical runtime class identity for operator application\nlogging and replay across Core + Induction.\n\nThis module is the SINGLE SOURCE OF TRUTH for OperatorApplication.\nAll other modules (state_model, operators/universe) re-export this type.",
      "classes": [
        "OperatorApplication"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "OP_APP_SCHEMA_ID",
        "OP_APP_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T00:27:34.190459",
        "modified": "2026-02-17T10:09:41.572109",
        "modified_days_ago": 3,
        "lines": 292,
        "size_bytes": 11563,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/schema_registry.py",
      "name": "schema_registry.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "Schema registry (draft).\n\nThis module defines canonical schema identities for boundary artifacts.\nIt is intentionally minimal and will become the code-owned source of truth\nfor docs/canonical/schema_registry.md.",
      "classes": [
        "CanonicalSchemaEntry"
      ],
      "functions": [
        "list_schemas",
        "schema_index",
        "get_schema"
      ],
      "imports": [
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:11:21.241934",
        "modified": "2026-02-21T15:11:21.242064",
        "modified_days_ago": 0,
        "lines": 240,
        "size_bytes": 8303,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "contracts/semantic_edits.py",
      "name": "semantic_edits.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "{\"type\":\"semver\",\"start\":\"2024\",\"x5 explicit inputs/outputs. 10\n\"\"\" \n\"\"\" \ndef get_node(nodet_id, \ndef get_schained edit\n\"\"\" \ndef join(\n    node: (lambits\n    Provenance for lamm (return)\n    \"\"\" \n    Provenance value: l, a graph.",
      "classes": [
        "EditType",
        "ProvenanceKind",
        "Provenance",
        "SemanticEdit",
        "EditDelta"
      ],
      "functions": [
        "create_edit",
        "create_add_edge_edit",
        "create_remove_edge_edit",
        "create_set_feature_edit",
        "create_bind_entity_edit",
        "create_set_polarity_edit",
        "create_activate_entity_edit",
        "compute_state_content_hash",
        "compute_trace_hash",
        "compute_state_fingerprint"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "uuid",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [
        "SEMANTIC_EDIT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.971636",
        "modified": "2026-02-21T23:57:28.971780",
        "modified_days_ago": 0,
        "lines": 743,
        "size_bytes": 24183,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "contracts/trace_bundle.py",
      "name": "trace_bundle.py",
      "category": "Semantic contracts and invariants",
      "status": "active",
      "description": "{\"description\":\"Certified trace bundle that provides event timeline. Includes: edge IDs, state, and decisions per node. Contains all objects and relations\n",
      "classes": [
        "CertificationError",
        "CompletenessDeclarationV1",
        "GoalSatisfactionWitnessV1",
        "SearchDecisionWitnessV1",
        "TraceBundleV1"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing",
        "core.induction.artifact_store",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T00:26:13.270660",
        "modified": "2026-01-25T00:26:13.271502",
        "modified_days_ago": 27,
        "lines": 677,
        "size_bytes": 26883,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "diagnostics/goal_clause_coverage.py",
      "name": "goal_clause_coverage.py",
      "category": "Core module",
      "status": "active",
      "description": "Computes goal clause coverage for task instrumentation without relying on reasoning layer. Neutral evaluation of goal fulfillment per clause.",
      "classes": [],
      "functions": [
        "coerce_bool",
        "coerce_int",
        "compute_goal_clause_coverage"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T15:36:12.777330",
        "modified": "2026-01-21T11:21:45.542561",
        "modified_days_ago": 30,
        "lines": 234,
        "size_bytes": 8609,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/__init__.py",
      "name": "__init__.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "Sterling Discourse Module.\n\nImplements discourse-level state and operators for multi-utterance reasoning.\n\nStage H: DiscourseState schema and operators for multi-turn conversations,\ndocument-level reasoning, and cross-utterance coherence.\n\nH.3: Multi-turn dialogue integration with intent system.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.discourse.dialogue",
        "core.discourse.intent_satisfaction",
        "core.discourse.operators",
        "core.discourse.phase_model",
        "core.discourse.state"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:17:56.040906",
        "modified": "2026-01-25T21:17:56.041003",
        "modified_days_ago": 26,
        "lines": 122,
        "size_bytes": 3341,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/dialogue.py",
      "name": "dialogue.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "```json\n{\n    \"intents\": [\n        {\n        \"init_replies_to_intents\": [\n            \"have_not_satisfied\",\n            \"have_not_satisfied\",\n            \"inform\",\n            \" told_him inform us/our intent:\n",
      "classes": [
        "TurnRole",
        "DialoguePhase",
        "IntentSatisfaction",
        "IntentSatisfactionStateMachine",
        "DialogueTurn",
        "IntentTransition",
        "DialogueState",
        "DialogueManager"
      ],
      "functions": [
        "create_default_intent_transitions",
        "create_dialogue_state",
        "get_default_dialogue_manager"
      ],
      "imports": [
        "__future__",
        "logging",
        "uuid",
        "dataclasses",
        "enum",
        "typing",
        "core.discourse.state",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:20:57.572293",
        "modified": "2026-01-22T07:53:46.529167",
        "modified_days_ago": 29,
        "lines": 1072,
        "size_bytes": 37802,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/intent_satisfaction.py",
      "name": "intent_satisfaction.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "Sterling Intent Satisfaction FSM.\n\nTracks goal satisfaction based on TYPED execution outcomes, not lexical cues.\n\nPer the Quality Improvement Roadmap:\n- FSM evidence comes from typed execution outcomes\n- Lexical cues can only influence scoring, never gating\n- Transitions based on goal achievement, constraint satisfaction, bindings\n\nAuthor: @darianrosebrook",
      "classes": [
        "SatisfactionState",
        "TypedEvidence",
        "ExecutionResult",
        "IntentSatisfactionFSM",
        "WeakLexicalFeatures",
        "GoalTracker"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T11:14:30.350909",
        "modified": "2026-01-22T07:53:46.527781",
        "modified_days_ago": 29,
        "lines": 389,
        "size_bytes": 12725,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/operators.py",
      "name": "operators.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "Resolves coreference, links discourse relations, updates topic, and merges segments within discourse states for multi-utterance reasoning.",
      "classes": [],
      "functions": [
        "_canon_precond",
        "_has_discourse_state",
        "_has_multiple_utterances",
        "_has_unresolved_references",
        "_discourse_relation_added",
        "_reference_resolved",
        "apply_resolve_coreference",
        "_find_antecedent",
        "_get_pronoun_features",
        "_check_agreement"
      ],
      "imports": [
        "__future__",
        "copy",
        "logging",
        "typing",
        "core.discourse.state",
        "core.labels.types",
        "core.operators.effects",
        "core.operators.preconditions",
        "core.operators.registry",
        "core.state_model"
      ],
      "constants": [
        "RESOLVE_COREFERENCE_SIG",
        "LINK_DISCOURSE_RELATION_SIG",
        "UPDATE_TOPIC_SIG",
        "MERGE_SEGMENTS_SIG",
        "CLASSIFY_INTENT_SIG",
        "SATISFY_INTENT_SIG",
        "PREDICT_NEXT_INTENT_SIG",
        "TRANSITION_PHASE_SIG"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 497,
            "content": "# TODO: [Strict Inanimate Pronoun Matching] Enforce stricter animacy agreement",
            "file_path": "core/discourse/operators.py"
          },
          {
            "line_number": 708,
            "content": "# TODO: [Discourse Segment Merge Tracking] Use proper discourse state structures",
            "file_path": "core/discourse/operators.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T13:52:27.343431",
        "modified": "2026-02-17T10:09:41.574536",
        "modified_days_ago": 3,
        "lines": 1149,
        "size_bytes": 39056,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/phase_model.py",
      "name": "phase_model.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "Sterling State-Derived Phase Detection.\n\nDerives dialogue phases from MEASURABLE STATE, not surface features.\n\nPer the Quality Improvement Roadmap:\n- Phases derived from goal satisfaction ratio, operator mix, etc.\n- No lexical pattern matching for phase detection\n- Evaluate phase detection only after state signals are stable\n\nAuthor: @darianrosebrook",
      "classes": [
        "PhaseDetectionPhase",
        "PhaseFeatures",
        "PhaseDetectionTurn",
        "PhaseDetectionState",
        "StateDerivedPhaseModel"
      ],
      "functions": [
        "create_phase_detection_state",
        "analyze_phase_distribution"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "PHASE_TRANSITIONS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:17:41.578521",
        "modified": "2026-01-25T21:17:41.578671",
        "modified_days_ago": 26,
        "lines": 343,
        "size_bytes": 11439,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/state.py",
      "name": "state.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "{\"description\":\"Implements discourse-level state tracking with RST-annotated\n    # N\n    EXPLAINS the relation\n    EXPLANs the N\n    EVIDes for each\n    A\n    At test\n    for valid\n    N\n    EXPLains\n    the\n    IN context\n    (new R\n    links\n    a\n    (A and\n    BON (from\n    # syntax\n    analysis\n    for\n    discourse\n    relations of\n    SEQUENCE-> Speech acts\n    The\n    COND\n    content\n    choice\n    and\n    reason\n    verif\n    a\n    an\n    EVID\n    e  N\n    links\n    EXPLains\n    the\n ...",
      "classes": [
        "DiscourseRelationType",
        "CoherenceType",
        "DiscourseRelation",
        "ReferenceChain",
        "TopicState",
        "TopicExtractor",
        "DiscourseSegment",
        "DiscourseState"
      ],
      "functions": [
        "create_discourse_state",
        "add_utterance_to_discourse"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T17:22:56.186955",
        "modified": "2026-01-22T07:53:46.527327",
        "modified_days_ago": 29,
        "lines": 1286,
        "size_bytes": 38526,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "discourse/tasks.py",
      "name": "tasks.py",
      "category": "Dialogue and discourse processing",
      "status": "active",
      "description": "{\"description\":\"Implements multi-utterance reasoning at the discourse stage H. Resolves coreference links in the discourse state. Predefined in DiscourseState with discourse representations. 1. utterance representations, constraints for discourse models.  \nCoreference resolution and linking of pronouns in text.  \nConstr: Each word in the discourse has .  \nFrom any state including variables (heurprag (merge)  \n# Analyze for anaphor phors.  \nContext (e.g a phors.",
      "classes": [
        "DiscourseTask",
        "CoreferenceTask",
        "DiscourseParsingTask",
        "TopicTrackingTask"
      ],
      "functions": [
        "create_coreference_task",
        "create_discourse_parsing_task",
        "create_topic_tracking_task",
        "run_discourse_task"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.discourse.operators",
        "core.discourse.state",
        "core.state_model"
      ],
      "constants": [
        "EXAMPLE_COREFERENCE_TASK",
        "EXAMPLE_DISCOURSE_PARSING_TASK",
        "EXAMPLE_TOPIC_TRACKING_TASK"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T17:24:40.486614",
        "modified": "2026-01-23T17:22:10.739646",
        "modified_days_ago": 28,
        "lines": 518,
        "size_bytes": 16397,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/__init__.py",
      "name": "__init__.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Dynamic Domains Infrastructure.\n\nContent-addressed domain specifications for Sterling's dynamic learning engine.\nDomains are versioned artifacts that declare state schemas, action surfaces,\nsemantic probes, and evaluation contracts.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.domains.action_surface",
        "core.domains.capability_claim_registry",
        "core.domains.capability_descriptor",
        "core.domains.conformance_suite",
        "core.domains.domain_handshake",
        "core.domains.domain_registry",
        "core.domains.domain_spec_v1",
        "core.domains.primitive_registry",
        "core.domains.primitive_spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.206669",
        "modified": "2026-02-20T09:33:53.207144",
        "modified_days_ago": 0,
        "lines": 83,
        "size_bytes": 2358,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/action_surface.py",
      "name": "action_surface.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Defines allowed op surfaces for domain-specific operator constraints. Operators may only use op types in allowed_op_types, target fields in writable_fields or target_namespaces. Read-only fields must not be modified.",
      "classes": [
        "OpType",
        "ActionSurfaceV1"
      ],
      "functions": [
        "create_pn_action_surface",
        "create_wordnet_action_surface",
        "create_escape_action_surface"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:47.275623",
        "modified": "2026-01-27T07:16:47.275767",
        "modified_days_ago": 24,
        "lines": 348,
        "size_bytes": 11606,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/capability_claim_registry.py",
      "name": "capability_claim_registry.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "{\"description\":\"The CapabilityClaimRegistry provides a fail-closed, file-backed index that allows O(1) lookup via (domain, primitive) keys and stores claim metadata with explicit verification states. It answers \"does domain X implement primitive Y?\" by indexing claim entries, not full descriptors, and enforces determinism through sorted entries.\"}",
      "classes": [
        "ClaimVerificationState",
        "CapabilityClaimEntry",
        "CapabilityClaimRegistry"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing",
        "core.domains.capability_descriptor",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.207818",
        "modified": "2026-02-20T09:33:53.208427",
        "modified_days_ago": 0,
        "lines": 596,
        "size_bytes": 23138,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/capability_descriptor.py",
      "name": "capability_descriptor.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "CapabilityDescriptorV1: Content-addressed claim artifact for domain-primitive capability verification. claim_id = sha256(canonical proof fields). Fail-closed: missing proof or non-conformance. Author: @darianrosebrook. Date: January 20, 26.",
      "classes": [
        "DeterminismClass",
        "BudgetDeclaration",
        "CapabilityDescriptorV1",
        "CapabilityDescriptorV2"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "CAPABILITY_DESCRIPTOR_CANON_V1_PREFIX",
        "CAPABILITY_DESCRIPTOR_CANON_V2_PREFIX",
        "KNOWN_DESCRIPTOR_SCHEMAS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.209097",
        "modified": "2026-02-20T09:33:53.209479",
        "modified_days_ago": 0,
        "lines": 615,
        "size_bytes": 24525,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/capsule_spec.py",
      "name": "capsule_spec.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "DEPRECATED: CapsuleSpecV1 is capsule infrastructure, not a domain concept.\n\nMoved to core.capsules.capsule_spec. This module is a compatibility shim.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.capsules.capsule_spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.209871",
        "modified": "2026-02-20T09:33:53.210083",
        "modified_days_ago": 0,
        "lines": 20,
        "size_bytes": 492,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "domains/conformance_suite.py",
      "name": "conformance_suite.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "ConformanceSuiteV1 declares test package, primitive, contract version, and implementation reference for domain conformance validation. Suite ID is SHA256(canonical proof fields; excludes metadata. Used to verify domain claims against specified primitive and contract.",
      "classes": [
        "FixtureRef",
        "EvidenceSchemaRef",
        "ConformanceSuiteV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "CONFORMANCE_SUITE_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T00:32:59.726215",
        "modified": "2026-02-01T00:32:59.726352",
        "modified_days_ago": 20,
        "lines": 267,
        "size_bytes": 9639,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/cpg_gate.py",
      "name": "cpg_gate.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "{\"description\":\"Defines the 9 hard fail-closed CPG gates (CPG-0 to CPG-4 testable checks (all text) against the locked model dump. Lock the entire\n    execution trace\n    #1 to #4 (code: always\n    passes pre-test (Demo) instances.\n    # Pre-proved\n    container\n    #1.",
      "classes": [
        "CPGGateId",
        "CPGVerdictBundle"
      ],
      "functions": [
        "_stable_verdict_projection"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.governance.gate_verdict",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "CPG_VERDICT_BUNDLE_CANON_V1_PREFIX",
        "CPG_CONTRACT_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T11:35:10.277185",
        "modified": "2026-02-19T11:35:10.277602",
        "modified_days_ago": 1,
        "lines": 162,
        "size_bytes": 5613,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/cpg_results.py",
      "name": "cpg_results.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "CPGResultsV1 structures test results deterministically for capability promotion gates by hashing content, excluding metadata such as timestamps, platform, and version.",
      "classes": [
        "CPGResultsV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "CPG_RESULTS_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T11:35:10.277653",
        "modified": "2026-02-19T11:35:10.277984",
        "modified_days_ago": 1,
        "lines": 178,
        "size_bytes": 6973,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/domain_handshake.py",
      "name": "domain_handshake.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Splits DomainDeclarationV1 (primitive claims, budget) from DomainSessionV1 (KG ref, operator pack). DomainDeclarationV1 is content-addressed and immutable after re-certification. DomainSessionV1 is ephemeral per connection.",
      "classes": [
        "PrimitiveClaimRef",
        "DomainDeclarationV1",
        "DomainSessionV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.domains.capability_descriptor",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "DOMAIN_DECLARATION_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T00:34:12.495086",
        "modified": "2026-02-01T00:34:12.495213",
        "modified_days_ago": 20,
        "lines": 324,
        "size_bytes": 11841,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/domain_registry.py",
      "name": "domain_registry.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Domain Registry: Registration and Lookup for DomainSpecs.\n\nProvides singleton registry for DomainSpec artifacts with:\n- Registration by domain_id\n- Lookup by domain_id or kernel_binding\n- Hash integrity validation\n- Deterministic bootstrap from manifest (P2)\n- Registry sealing for governance\n\nP2 Governance: Auto-registration replaced with explicit manifest bootstrap.",
      "classes": [
        "DomainRegistration",
        "DomainRegistryError",
        "DomainNotFoundError",
        "DomainHashMismatchError",
        "DomainAlreadyRegisteredError",
        "DomainRegistry"
      ],
      "functions": [
        "_parse_semver",
        "_semver_sort_key",
        "get_domain_spec",
        "get_domain_for_kernel",
        "register_domain"
      ],
      "imports": [
        "__future__",
        "logging",
        "re",
        "threading",
        "dataclasses",
        "typing",
        "core.domains.domain_spec_v1",
        "core.domains.registry_manifest",
        "core.governance.run_intent",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_SEMVER_PATTERN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:57.032167",
        "modified": "2026-02-01T00:37:46.344965",
        "modified_days_ago": 20,
        "lines": 649,
        "size_bytes": 21768,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/domain_spec_v1.py",
      "name": "domain_spec_v1.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "{\"description\":\"...\",\"divergent\":false,\"isclass\":(export_type,base and abstract methods\n    def by (self): \"\"\" @type depends on / imports: \"\"\" @type depends on imports(\u201cwith\u201d from kernel(\u201cmethod\u201d)\n@type: \"\"\" @type depends on imports(path list, system and call methods\n    def build_model(self) -> (type):\"\" \n    Depends on imports( such as model from pre-defined model module\n    \"\"\" @type\u2026 depends on imports and calls common interface\n    def is (for kernel_ \u201cis\u201d dependent on imports(Imported by...",
      "classes": [
        "KernelBindingV1",
        "FieldID",
        "InvariantDependency",
        "FieldDeclaration",
        "StateSchemaCommitV1",
        "SemanticProbe",
        "ProbeCommitV1",
        "EvaluationContractV1",
        "DomainSpecV1"
      ],
      "functions": [
        "create_pn_domain_spec",
        "create_wordnet_domain_spec"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.domains.action_surface",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "DOMAIN_SPEC_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-01-27T07:16:29.531401",
        "modified": "2026-02-01T00:37:46.344641",
        "modified_days_ago": 20,
        "lines": 818,
        "size_bytes": 29802,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/language_io_domain.py",
      "name": "language_io_domain.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "{\"Language\": \"LanguageIO\", \"reducer\" -> \"reduce\": (envelope, world) validate and\n    return envelope => {object LanguageIO ...",
      "classes": [
        "LanguageIORequest",
        "LanguageIOResponse",
        "LanguageIODomain"
      ],
      "functions": [
        "get_language_io_domain",
        "reset_language_io_domain",
        "is_language_io_request",
        "handle_language_io_message"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.linguistics.io_envelope_v1",
        "core.linguistics.reducer_result_v1",
        "core.linguistics.reducers.intent_reducer_v1",
        "core.linguistics.world_snapshot_v1"
      ],
      "constants": [
        "LANGUAGE_IO_DOMAIN_ID",
        "LANGUAGE_IO_DOMAIN_VERSION",
        "REQUEST_TYPE_REDUCE",
        "REQUEST_TYPE_REDUCE_AND_GROUND",
        "REQUEST_TYPE_PING"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-03T17:53:43.869416",
        "modified": "2026-02-03T17:53:43.869585",
        "modified_days_ago": 17,
        "lines": 315,
        "size_bytes": 10047,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/p22/__init__.py",
      "name": "__init__.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "P22 domain-facing descriptors and primitive spec factory.",
      "classes": [],
      "functions": [],
      "imports": [
        "capability_descriptors_v1",
        "primitive_spec_p22"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T18:05:46.719627",
        "modified": "2026-02-20T18:05:46.723400",
        "modified_days_ago": 0,
        "lines": 13,
        "size_bytes": 370,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "domains/p22/capability_descriptors_v1.py",
      "name": "capability_descriptors_v1.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Defines P22 control plane capabilities including perception and realization constraints via typed descriptors.",
      "classes": [
        "PerceptionCapabilityDescriptorV1",
        "RealizationCapabilityDescriptorV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-20T18:05:46.724335",
        "modified": "2026-02-20T18:05:46.727823",
        "modified_days_ago": 0,
        "lines": 50,
        "size_bytes": 1606,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "domains/p22/primitive_spec_p22.py",
      "name": "primitive_spec_p22.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Builds the P22 primitive spec using the PrimitiveSpecV1 factory.",
      "classes": [],
      "functions": [
        "build_primitive_spec_p22"
      ],
      "imports": [
        "__future__",
        "core.domains.primitive_spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T18:05:46.728954",
        "modified": "2026-02-20T18:05:46.732586",
        "modified_days_ago": 0,
        "lines": 60,
        "size_bytes": 2312,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "domains/primitive_registry.py",
      "name": "primitive_registry.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "Singleton registry for (primitive_id, contract_version) keys; loads from data/primitive_specs/index.json with fallback. Enforces versioned access and fail-closed handling for unknown primitives.",
      "classes": [
        "PrimitiveRegistry"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "threading",
        "pathlib",
        "typing",
        "core.domains.primitive_spec"
      ],
      "constants": [
        "_DEFAULT_DATA_PATH"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T00:29:38.815457",
        "modified": "2026-02-01T00:29:38.815663",
        "modified_days_ago": 20,
        "lines": 172,
        "size_bytes": 6001,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/primitive_spec.py",
      "name": "primitive_spec.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "PrimitiveSpecV1: Data-Driven Obligation Documents for Capability Primitives.\n\nA primitive spec declares what a domain MUST provide to claim a capability\nprimitive. Specs are content-addressed and loadable from data files,\nwith builtin factories as a bootstrap fallback.",
      "classes": [
        "CertificationGateRef",
        "PrimitiveSpecV1"
      ],
      "functions": [
        "build_p01_spec",
        "build_p02_spec",
        "build_p03_spec",
        "build_p04_spec",
        "build_p05_spec"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "PRIMITIVE_SPEC_CANON_V1_PREFIX",
        "BUILTIN_FACTORIES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T00:29:14.358292",
        "modified": "2026-02-01T00:29:14.359872",
        "modified_days_ago": 20,
        "lines": 408,
        "size_bytes": 16654,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/promotion_proposal.py",
      "name": "promotion_proposal.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "{\"description\":\"PromotionProposalV1: Encapsulates promotion evidence into a hash-locked descriptor for domain admission. Only identity and pinned contract fields are included in the proposal hash. Excluded fields prevent nondeterminism for proposal evaluation. Bridge to CapabilityDescriptorV1 requires target domain supplied by caller. Capsule content hashes to proposal id. Isolated system; metadata fields absent in proposal hash. Author tag from execution context.  \n",
      "classes": [
        "PromotionProposalV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.domains.capability_descriptor",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "PROMOTION_PROPOSAL_CANON_V1_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T09:33:53.210181",
        "modified": "2026-02-20T09:33:53.210537",
        "modified_days_ago": 0,
        "lines": 282,
        "size_bytes": 11934,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "domains/registry_manifest.py",
      "name": "registry_manifest.py",
      "category": "Domain specifications and configuration",
      "status": "active",
      "description": "RegistryManifest provides deterministic, content-addressed bootstrapping of domains. It enforces manifest_id as a SHA256 of sorted domain IDs and specs. Registries can only be sealed after prior bootstrap, not auto-generated.",
      "classes": [
        "RegistryManifest",
        "RegistrySealedError",
        "RegistryStateError",
        "AmbiguousKernelLookupError"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:47.488651",
        "modified": "2026-02-01T00:37:46.344432",
        "modified_days_ago": 20,
        "lines": 157,
        "size_bytes": 5075,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "engine/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Engine: Main entrypoint for Sterling reasoning.\n\nModularized engine package.",
      "classes": [],
      "functions": [],
      "imports": [
        "context",
        "core",
        "run_result",
        "registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.762054",
        "modified": "2026-01-24T18:52:11.430186",
        "modified_days_ago": 27,
        "lines": 39,
        "size_bytes": 900,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "engine/context.py",
      "name": "context.py",
      "category": "Core module",
      "status": "active",
      "description": "ExecutionContext manages episode-specific state for the reasoning process, ensuring a single StateGraph is created and passed through all phases. It provides a thread-local environment for consistent execution and enables access to the HypothesisLifecycleController and PriorInfluenceGate for governance during search and emission.",
      "classes": [
        "ExecutionContext"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "time",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.762160",
        "modified": "2026-01-17T20:41:18.801424",
        "modified_days_ago": 34,
        "lines": 97,
        "size_bytes": 4810,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "engine/core.py",
      "name": "core.py",
      "category": "Core module",
      "status": "active",
      "description": "Sterling MOC indexing: SterlingEngine manages world adapters, dispatches tasks with precondition checks, and executes instrumented search to build and validate state graphs for reasoning.",
      "classes": [
        "SterlingEngine"
      ],
      "functions": [
        "create_engine",
        "create_configured_engine"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "hashlib",
        "json",
        "logging",
        "uuid",
        "dataclasses",
        "typing",
        "core.exceptions",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T14:42:44.343851",
        "modified": "2026-02-18T14:42:44.344004",
        "modified_days_ago": 2,
        "lines": 936,
        "size_bytes": 40120,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "engine/registry.py",
      "name": "registry.py",
      "category": "Core module",
      "status": "active",
      "description": "Defines SterlingEngineError, WorldNotRegisteredError, TaskNotSupportedError and provides register_task, register_task_assumptions, get_task_fn.",
      "classes": [
        "SterlingEngineError",
        "WorldNotRegisteredError",
        "TaskNotSupportedError",
        "PreconditionNotMetError"
      ],
      "functions": [
        "register_task",
        "register_task_assumptions",
        "get_task_fn",
        "get_task_assumption_fn"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.762459",
        "modified": "2026-01-21T11:07:23.559433",
        "modified_days_ago": 30,
        "lines": 100,
        "size_bytes": 3163,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "engine/run_result.py",
      "name": "run_result.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Run results include intake artifacts and option digests.   Optional[all]   (digests for each key when present\n    # no digest in\n    # 1.",
      "classes": [
        "RunResultV1"
      ],
      "functions": [
        "_jsonable",
        "_digest",
        "_is_artifact_ref_dict",
        "_sanitize_input_refs",
        "_run_intent_from_governance",
        "_request_payload",
        "_store_state_graph",
        "_store_final_state",
        "_state_graph_to_dict"
      ],
      "imports": [
        "hashlib",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.canonicalization.json",
        "core.contracts.artifact_identity",
        "core.operators.execution_context",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T20:45:07.546879",
        "modified": "2026-01-24T20:45:07.547033",
        "modified_days_ago": 27,
        "lines": 524,
        "size_bytes": 18792,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "environment/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Environment API (Stage O).\n\nThin unifying facade over episode/graph/report infrastructure.\nEnables agent integration without coupling to internal data structures.\n\nPer roadmap 10.3:\n- QuerySpec v0 is minimal and enumerated (named queries only)\n- Handles are content-addressed\n- Summarization is lossless and structured\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.environment.api",
        "core.environment.budget_spec",
        "core.environment.handles",
        "core.environment.query_spec",
        "core.environment.slice"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:25:16.774160",
        "modified": "2026-01-22T07:53:46.507047",
        "modified_days_ago": 29,
        "lines": 31,
        "size_bytes": 806,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "environment/api.py",
      "name": "api.py",
      "category": "Core module",
      "status": "active",
      "description": "EnvironmentAPI provides a unified facade for select, peek, and summarize operations over Sterling's episode and handle infrastructure. All query logic delegates to core modules; adding new artifact types requires core changes only. Budgeted, auditable access to Sterling's episode and handle layers.",
      "classes": [
        "EnvironmentAPI"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "dataclasses",
        "pathlib",
        "typing",
        "core.environment.budget_spec",
        "core.environment.handles",
        "core.environment.query_spec",
        "core.environment.slice"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:29:34.892762",
        "modified": "2026-01-22T07:53:46.507064",
        "modified_days_ago": 29,
        "lines": 1023,
        "size_bytes": 35348,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "environment/budget_spec.py",
      "name": "budget_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "Budget specification for Environment API queries. Enforces resource limits via BudgetSpec and BudgetUsage classes. Truncates results if exceeded.",
      "classes": [
        "BudgetSpec",
        "BudgetUsage"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "BUDGET_MINIMAL",
        "BUDGET_STANDARD",
        "BUDGET_LARGE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:26:30.219530",
        "modified": "2026-01-22T07:53:46.507116",
        "modified_days_ago": 29,
        "lines": 168,
        "size_bytes": 5442,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "environment/handles.py",
      "name": "handles.py",
      "category": "Core module",
      "status": "active",
      "description": "Creates handles for Sterling artifacts using episode_id and schema_version. Ensures handles are content-addressed and stable across serialization. Author: @darianrosebrook.",
      "classes": [
        "HandleType",
        "ArtifactHandle",
        "HandleSet"
      ],
      "functions": [
        "episode_handle",
        "state_graph_node_handle",
        "state_graph_edge_handle",
        "hypothesis_handle",
        "outcome_witness_handle",
        "observation_handle",
        "semantic_delta_handle"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:25:59.887997",
        "modified": "2026-01-22T07:53:46.507106",
        "modified_days_ago": 29,
        "lines": 401,
        "size_bytes": 11613,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "environment/query_spec.py",
      "name": "query_spec.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"A query execution.  >>> QuerySpec: <Query returning a single row\"\n>>> \"state'query' must be a single value from one or more complex queries are not allowed\n>>> only (no variables)\n    (Risk O1):  raise on all 3 types\n    >>>  query  returns\n    (not supported: 5, 8 queries must\n    be 7\n    elements\n    from\n    >>> a 4\n    (function\n    (data): 2\n    >>>  (constr, a\n    simple  query\n    for\n    >>>  query 6\n    >>> append\n    (optional; \n    query for n\n    >>> 4.",
      "classes": [
        "NamedQuery",
        "QuerySpec",
        "QueryResult"
      ],
      "functions": [
        "success_episodes",
        "failure_episodes",
        "episodes_by_task_type",
        "active_hypotheses",
        "proposed_hypotheses",
        "knowledge_edges",
        "observations_for_episode",
        "outcome_witnesses_for_episode",
        "semantic_deltas_for_episode"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.environment.budget_spec",
        "core.environment.handles"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:27:08.943180",
        "modified": "2026-01-22T07:53:46.507082",
        "modified_days_ago": 29,
        "lines": 290,
        "size_bytes": 8376,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "environment/slice.py",
      "name": "slice.py",
      "category": "Core module",
      "status": "active",
      "description": "Creates frozen slices of artifact content with explicit handle, offset, and provenance. Provides structured summaries with typed data and hashable content. Ensures stability across serialization and deterministic access via handle and offset.",
      "classes": [
        "Slice",
        "Summary",
        "SummaryType"
      ],
      "functions": [
        "create_slice",
        "create_empty_slice"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.environment.handles"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:27:45.802485",
        "modified": "2026-01-22T07:53:46.507099",
        "modified_days_ago": 29,
        "lines": 269,
        "size_bytes": 8014,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "exceptions.py",
      "name": "exceptions.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides custom SterlingError classes for failure handling and structured error metadata including error codes and context.",
      "classes": [
        "SterlingError",
        "ConfigurationError",
        "ValidationError",
        "KGError",
        "KGNodeNotFoundError",
        "KGEdgeNotFoundError",
        "KGValidationError",
        "KGSerializationError",
        "IRError",
        "IRParseError",
        "IRValidationError",
        "IRSerializationError",
        "ModelError",
        "ModelLoadError",
        "ModelSaveError",
        "TrainingError",
        "InferenceError",
        "ReasoningError",
        "RuleApplicationError",
        "PlanningError",
        "ReconstructionError",
        "ExternalServiceError",
        "APIError",
        "DatabaseError",
        "FileSystemError",
        "TaskError",
        "TaskTimeoutError",
        "TaskCancelledError",
        "TaskResourceError",
        "InvalidActionError",
        "EpisodeBoundaryViolation",
        "AuditTrailConfigurationError",
        "MissingRequiredWitnessError",
        "WitnessEmissionError"
      ],
      "functions": [
        "handle_exception",
        "with_error_handling"
      ],
      "imports": [
        "typing"
      ],
      "constants": [
        "ERROR_CODES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T22:51:42.021110",
        "modified": "2026-01-24T22:51:42.021283",
        "modified_days_ago": 27,
        "lines": 412,
        "size_bytes": 10554,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "external_ref.py",
      "name": "external_ref.py",
      "category": "Core module",
      "status": "active",
      "description": "ExternalRef provides a content hash-based identity for heavyweight dependencies, allowing state to reference external resources without embedding them. KGRef implements this for knowledge graphs. ExternalRef is immutable and serializable via to_ and from_ snapshot methods.",
      "classes": [
        "ExternalRef"
      ],
      "functions": [
        "get_kg_ref_class",
        "validate_external_ref"
      ],
      "imports": [
        "__future__",
        "abc",
        "typing"
      ],
      "constants": [
        "DEEPCOPY_BUDGET_MS",
        "MAX_STATE_SIZE_GROWTH_BYTES",
        "MAX_SNAPSHOT_SIZE_BYTES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-30T21:26:22.741391",
        "modified": "2026-01-22T07:53:46.007210",
        "modified_days_ago": 29,
        "lines": 205,
        "size_bytes": 6109,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "features.py",
      "name": "features.py",
      "category": "Core module",
      "status": "active",
      "description": "Canonical feature computation for Sterling transition scoring.\n\nThis module provides the single source of truth for feature extraction across\nall training and inference scripts. Any script that computes features for\nthe TransitionScorer MUST use these functions to ensure alignment.",
      "classes": [
        "FeatureModeSpec"
      ],
      "functions": [
        "get_feature_dim",
        "validate_feature_mode",
        "compute_parent_child_features",
        "_feature_cache_key_v1",
        "_make_structural_features_impl",
        "make_structural_features",
        "compute_ir_features",
        "normalize_training_record",
        "format_training_record",
        "analyze_path_monotonicity"
      ],
      "imports": [
        "__future__",
        "math",
        "dataclasses",
        "typing",
        "core.optimization.cache",
        "core.optimization.hashing",
        "core.optimization.quantization"
      ],
      "constants": [
        "_FEATURE_CACHE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:22:22.692748",
        "modified": "2026-01-25T21:22:22.692868",
        "modified_days_ago": 26,
        "lines": 1049,
        "size_bytes": 37112,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "features_grouped.py",
      "name": "features_grouped.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Grouped operator category feature extraction (S/M/P/K/C dimensions from structured model. See GroupFeatureSpec for each  type, tokens and grammar as feature v0 grammar. Each group has right (nouns, verbs, Adjectives, Nouns, Verbs\n    Nouns: \"fence\", verbs main\n    features\n",
      "classes": [
        "GroupFeatureSpec"
      ],
      "functions": [
        "get_group_feature_dim",
        "get_group_feature_names",
        "extract_structural_group_features",
        "extract_meaning_group_features",
        "extract_pragmatic_group_features",
        "extract_knowledge_group_features",
        "extract_control_group_features",
        "extract_group_features",
        "make_grouped_transition_features",
        "get_combined_feature_dim"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.features",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-11T09:42:54.378026",
        "modified": "2026-01-22T07:53:46.006724",
        "modified_days_ago": 29,
        "lines": 507,
        "size_bytes": 17323,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/__init__.py",
      "name": "__init__.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "Governance Module: Context and constraints for certification-critical code paths.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.governance.run_intent",
        "core.governance.governance_context",
        "core.governance.execution_policy",
        "core.governance.gate_verdict",
        "core.governance.failure_witness",
        "core.governance.canonical_hash",
        "core.governance.adapter_strict_guard"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.412853",
        "modified": "2026-01-26T06:12:48.413021",
        "modified_days_ago": 25,
        "lines": 174,
        "size_bytes": 5484,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "governance/adapter_strict_guard.py",
      "name": "adapter_strict_guard.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "Strict-Mode Adapter Protocol Guard (S1.4).\n\nGOVERNANCE (January 2026):\n    This module enforces fail-closed semantics at the adapter dispatch seam.\n    In strict intent (certifying/promotion/replay), adapters that return\n    empty observations or UNKNOWN verification results are treated as failures.",
      "classes": [
        "AdapterStrictModeError",
        "StrictModeConfigurationError",
        "AdapterGuardResult"
      ],
      "functions": [
        "check_emit_observations_strict",
        "check_verify_prediction_strict",
        "_validate_strict_requirements",
        "wrap_emit_observations_strict",
        "wrap_verify_prediction_strict",
        "validate_adapter_for_strict_mode"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T14:47:19.262962",
        "modified": "2026-01-25T14:47:19.263066",
        "modified_days_ago": 27,
        "lines": 629,
        "size_bytes": 24760,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "governance/canonical_hash.py",
      "name": "canonical_hash.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "{\"integrity\": only hash should be\n    #.  (shard, any\n        shas (hash must be\n    deterministic for\n    e.g., 1.  hash(  e2. optional\n    ( 3.  hash(  data\n    (structured input (Puzzle hard\n    to implementer (hash_missing: allows\n    hashes to  user-defined\n    (  a  (  harden/  (  user  ( 1.  hardening\n    (  user  (  optional\n    ( 1.  (  user  (  IN\n    a  structured  (  (  (  (  (  IN user\n  (non  (  (  hard  to  (  user\n  data  (  (  IN  hard  to  (",
      "classes": [
        "CanonicalHashError",
        "EpisodeInputExtractionError",
        "MissingPuzzleFieldsError",
        "EpisodeHashingError",
        "EpisodeInputExtractionError"
      ],
      "functions": [
        "canonical_json_serialize",
        "canonical_json_hash",
        "extract_semantic_payload",
        "compute_semantic_hash",
        "_reject_floats",
        "extract_episode_input",
        "hash_episode_input",
        "compute_puzzle_hash",
        "compute_contract_hash",
        "compute_episode_content_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing"
      ],
      "constants": [
        "CANONICAL_JSON_VERSION",
        "EPISODE_HASH_VERSION",
        "EPISODE_INPUT_FIELDS_VERSION"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:45:25.793896",
        "modified": "2026-01-25T20:45:25.794036",
        "modified_days_ago": 26,
        "lines": 859,
        "size_bytes": 29615,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/execution_policy.py",
      "name": "execution_policy.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "ExecutionPolicy defines rules for when operators may execute in different run_intents. It enforces detection-only attestation in strict mode, banning learned operators from certifying/promotion/replay until runtime enforcement. Policies are STRICT, MONITORED (requires monitored VM), or PERMISSIVE (allows all in dev).",
      "classes": [
        "OperatorOrigin",
        "ExecutionPolicyMode",
        "ExecutionPolicyViolation",
        "ExecutionPolicyError",
        "ExecutionPolicy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.governance.run_intent"
      ],
      "constants": [
        "CERTIFYING_EXECUTION_POLICY",
        "DEV_EXECUTION_POLICY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:12:13.761291",
        "modified": "2026-01-24T23:12:13.761416",
        "modified_days_ago": 27,
        "lines": 301,
        "size_bytes": 10476,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/failure_witness.py",
      "name": "failure_witness.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "GovernanceFailureWitness: Structured witness for strict failures.\n\nSCHEMA VERSION: v2 (January 2026)\n    This module uses schema_id \"sterling.governance_failure_witness.v2\".\n\n    V1 SCHEMA POLICY (S1.1 January 2026):\n    - EMISSION: v1 is FORBIDDEN. No current code path may produce v1 witnesses.\n      All new witnesses MUST use v2 with dual-hash pattern (record_id + semantic_hash).",
      "classes": [
        "GovernanceFailureWitness",
        "WitnessNotDurableError",
        "WitnessRecorder"
      ],
      "functions": [
        "compute_semantic_hash",
        "compute_witness_hash",
        "create_failure_witness",
        "get_witness_recorder",
        "set_witness_recorder",
        "record_and_raise"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "uuid",
        "dataclasses",
        "datetime",
        "typing",
        "core.governance.gate_verdict"
      ],
      "constants": [
        "T",
        "WITNESS_SEMANTIC_FIELDS",
        "WITNESS_METADATA_FIELDS",
        "WITNESS_HASH_DENYLIST"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:45:49.335242",
        "modified": "2026-01-25T20:45:49.335367",
        "modified_days_ago": 26,
        "lines": 653,
        "size_bytes": 25889,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/gate_verdict.py",
      "name": "gate_verdict.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "{\"verdict\": \"SKIPPED\", \"reason\": \"MISSING prerequisite data, not\n    a verdict in strict mode (no-Applicable\n    SKIPPED verdict\n    when it is not\n    a  SKIPPED (missing a\n    PREREQ  missing and\n    fail_  reason_  missing\n    and  verdict\n    (skipped\n    reason_code=MISSING\n    verdict = SKIPPED\n    reason\n    missing_precondition, not\n    fail_  reason code\n    missing\n    baseline\n    verdict\n    SKIPPED  verdict\n    for\n    missing_  reason\n    verdict =  missing\n    reason_  missing\n  ...",
      "classes": [
        "GateVerdict",
        "SkipReason",
        "FailReasonCode",
        "UntypedFailInStrictModeError",
        "SchemaValidationError",
        "GateResult"
      ],
      "functions": [
        "require_pass_or_raise",
        "map_test_result_to_gate_result",
        "validate_gate_result_for_strict_mode",
        "deserialize_gate_result_strict",
        "map_test_result_to_gate_result_for_context",
        "require_pass_or_raise_for_context"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "KNOWN_GATE_RESULT_SCHEMAS",
        "CURRENT_GATE_RESULT_SCHEMA"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.413122",
        "modified": "2026-01-26T06:12:48.413280",
        "modified_days_ago": 25,
        "lines": 1257,
        "size_bytes": 46652,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/governance_context.py",
      "name": "governance_context.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "GovernanceContext: Context Object for Certification-Critical Paths.\n\nEncapsulates governance state (registry, run_intent, artifact_store, witness_recorder)\nand passes it explicitly through certification-critical code paths.\n\nGOVERNANCE (January 2026):\n    GovernanceContext is the SINGLE AUTHORITY for strictness decisions.",
      "classes": [
        "GovernanceContextError",
        "InMemoryWitnessStore",
        "InMemoryArtifactStore",
        "SimpleArtifactRef",
        "ExecutionClass",
        "GovernanceContext"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.governance.run_intent",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:46.380653",
        "modified": "2026-01-27T07:17:46.380799",
        "modified_days_ago": 25,
        "lines": 769,
        "size_bytes": 30834,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "governance/legacy_deprecation.py",
      "name": "legacy_deprecation.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "{\"governance: track via machine-readable artifact, not log\n    - Deprecitation\n    (no m\u0438\u0433\u0440\u0430\u0446\u0438\u044f\n    - telemmataur\n    eated\n    paths: 0\n    verif\n    0\n    run_ e\n    verif\n    telemataur\n    eMIGnated\n    verif 0\n    eMIGn t\n    eWIT\n    eMIGn telemataur\n    eMIGnate\n    verif0\n    eMIGnate\n    eMIGnIT eMIGnate\n    verif0 telemata\n    MIGnIT (no e\n    MIGnIT eMIGnate MIG 0tated\n    MIGnIT eMIGnate",
      "classes": [
        "DeprecatedPathError",
        "DeprecationStage",
        "DeprecationMarker",
        "LegacyUsageSummary",
        "LegacyUsageTracker"
      ],
      "functions": [
        "check_deprecated_path",
        "get_deprecated_path_marker",
        "list_deprecated_paths",
        "check_flip_criterion",
        "finalize_and_write_summary"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "threading",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T15:24:41.404110",
        "modified": "2026-01-25T15:24:41.404228",
        "modified_days_ago": 26,
        "lines": 580,
        "size_bytes": 20348,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/replay/__init__.py",
      "name": "__init__.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "Governance Replay Verification Module.\n\nThis module implements Type A (structural) replay verification for GOV-7.\nIt verifies that a trace bundle is closed under content-addressed references\nand that the claimed proof hash is a deterministic function of fetchable artifacts.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.governance.replay.artifact_resolver",
        "core.governance.replay.verification_result",
        "core.governance.replay.structural_verifier"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T00:27:56.643058",
        "modified": "2026-01-25T00:27:56.643166",
        "modified_days_ago": 27,
        "lines": 68,
        "size_bytes": 2034,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/replay/artifact_resolver.py",
      "name": "artifact_resolver.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "ArtifactResolver enforces schema constraints during lookup and verifies content hash matches identity, failing closed on ambiguity or version mismatch. Schema-constrained resolution only; bare get_by_content_hash is disallowed.",
      "classes": [
        "ArtifactResolutionError",
        "ArtifactNotFoundError",
        "ArtifactHashMismatchError",
        "SchemaAmbiguityError",
        "SchemaMismatchError",
        "SchemaVersionMismatchError",
        "ResolvedArtifact",
        "ArtifactResolver"
      ],
      "functions": [],
      "imports": [
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T00:27:42.512358",
        "modified": "2026-01-25T00:27:42.512502",
        "modified_days_ago": 27,
        "lines": 358,
        "size_bytes": 11728,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "governance/replay/structural_verifier.py",
      "name": "structural_verifier.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "{\"type\": \"Structural\", \"verifier\": {\"state\": \"proof\", \"previous\": {\"$ref\": 4, \"mempirical\": {\"data\": \"\", \"proof\": {\"$ref\": \"formal\" context (each $x$ type\nEach $x required for each referenced item\nProvenance links (or their\n    simple check: root -> A, from\n    verifiable\n    (self)\n    type: th\n    trace\n    check (content- addresses the\n    check (structure)\n    checks (all\n    types\n    verified\n    (structure)\n    with\n    simple\n    veri (content)\n    prove\n    chain-of-thought\n   ...",
      "classes": [
        "StructuralReplayVerifier"
      ],
      "functions": [
        "create_verifier_from_store"
      ],
      "imports": [
        "logging",
        "typing",
        "core.governance.replay.artifact_resolver",
        "core.governance.replay.verification_result",
        "core.induction.artifact_store"
      ],
      "constants": [
        "TRACE_BUNDLE_SCHEMA",
        "STATE_GRAPH_SCHEMA",
        "SEMANTIC_DELTA_SCHEMA",
        "PROOF_DICT_SCHEMA",
        "CURRENT_PROOF_SPEC_ID",
        "CURRENT_PROOF_SPEC_VERSION",
        "SUPPORTED_PROOF_SPEC_VERSIONS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T00:27:05.919326",
        "modified": "2026-01-25T00:27:05.919463",
        "modified_days_ago": 27,
        "lines": 546,
        "size_bytes": 21321,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "governance/replay/verification_result.py",
      "name": "verification_result.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "Provides typed verification result objects for replay with failure codes indicating store corruption, version mismatch, missing artifacts, or schema/implementation drift.",
      "classes": [
        "VerificationFailureCode",
        "VerificationFailureDetail",
        "StructuralVerificationResult"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T00:25:27.891049",
        "modified": "2026-01-25T00:25:27.891204",
        "modified_days_ago": 27,
        "lines": 212,
        "size_bytes": 8899,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "governance/run_intent.py",
      "name": "run_intent.py",
      "category": "Run intents, fail-closed gates, and audit infrastructure",
      "status": "active",
      "description": "{\"RunIntent determines strictness: if RunIntent is strict: raise Certifying errors\nReturn permissive: return GateVerdict.SKIPPED\n    if RunIntent is DEV: return SomeResult, not\n    exceptions. Only\n    if RunIntent is CERTIFYING: raise on missing\n    base line if RunIntent is set to strict\n    This class: missing\n    artifact required in certifying\n    mode: return SKIPPED\n    status only. No\n    warnings for this run\n    intent\n    scope.",
      "classes": [
        "CertifyingModeError",
        "BaselineNotFoundError",
        "EvidenceNotFoundError",
        "ArtifactStoreRequiredError",
        "RunIntent"
      ],
      "functions": [
        "is_strict_mode"
      ],
      "imports": [
        "__future__",
        "enum",
        "typing"
      ],
      "constants": [
        "RUN_INTENT_DEV",
        "RUN_INTENT_CERTIFYING",
        "RUN_INTENT_PROMOTION",
        "RUN_INTENT_REPLAY"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-28T08:23:42.746002",
        "modified": "2026-01-28T08:23:42.746152",
        "modified_days_ago": 23,
        "lines": 299,
        "size_bytes": 9638,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "hashing/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Hashing Contracts Package.\n\nThis package provides explicit hashing contracts for deterministic, reproducible\nhashes across the Sterling codebase. Each contract has specific semantics and\ncallers MUST specify which contract they're using.\n\nGOVERNANCE (January 2026):\n    This module is a COORDINATION POINT for hashing conventions.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.hashing.contracts"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:28:40.460145",
        "modified": "2026-01-25T21:28:40.468913",
        "modified_days_ago": 26,
        "lines": 45,
        "size_bytes": 1421,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "hashing/contracts.py",
      "name": "contracts.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Explicit contracts for stability; ensures #. \n  - strict hex output. \n    - include  - \"UTF-8\" (not \n    -  -  return hex without a \n    - 256 (no \n    explicit  -  current contract (do not \n    change existing  (for  - 256  (separ 256  (e.g. 1. \n    -  returns \n    hash  (with \n    input  (e.g.  data  (an  - 256  (strict) \n    encoding  (spec)  (all  (must \n    see  IRI  - 256 hash \n    (an  data  -  (w  i  - p  reu  e  - 256  (  (strict) \n    -  ascii  (i",
      "classes": [
        "HashContractError",
        "HashContract"
      ],
      "functions": [
        "canonical_json_bytes",
        "canonical_json_str",
        "sha256_hash",
        "compute_content_hash",
        "get_contract_semantics"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "enum",
        "typing"
      ],
      "constants": [
        "CONTRACT_SEMANTICS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:50:43.899634",
        "modified": "2026-01-26T06:50:43.899748",
        "modified_days_ago": 25,
        "lines": 321,
        "size_bytes": 10289,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "id_registry.py",
      "name": "id_registry.py",
      "category": "Core module",
      "status": "active",
      "description": "Manages one-to-one mapping between concept/predicate IDs and RGBA codes. Ensures no ID or RGBA code reuse. Stores distance statistics for validation.",
      "classes": [
        "RGBA",
        "_ColorDistanceStats",
        "IDRegistry"
      ],
      "functions": [
        "_serialize_distance_stats",
        "_deserialize_distance_stats",
        "_append_limited",
        "_rgba_distance",
        "_srgb_to_linear",
        "_rgb_to_lab",
        "_delta_e_ciede2000"
      ],
      "imports": [
        "json",
        "logging",
        "math",
        "collections",
        "dataclasses",
        "itertools",
        "pathlib",
        "typing"
      ],
      "constants": [
        "MAX_DISTANCE_SAMPLES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-16T21:15:47.076323",
        "modified": "2026-01-22T07:53:45.756805",
        "modified_days_ago": 29,
        "lines": 732,
        "size_bytes": 25953,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/__init__.py",
      "name": "__init__.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Sterling Induction Module.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.induction.decision_policy",
        "core.induction.hypothesis",
        "core.induction.hypothesis_program",
        "core.induction.hypothesis_proposer",
        "core.induction.hypothesis_refiner",
        "core.induction.hypothesis_scoring",
        "core.induction.hypothesis_selection",
        "core.induction.invariance_checker",
        "core.induction.k1_metrics",
        "core.induction.lifecycle_controller"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:30.339143",
        "modified": "2026-01-27T07:16:30.339458",
        "modified_days_ago": 27,
        "lines": 226,
        "size_bytes": 6245,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/abc_comparison.py",
      "name": "abc_comparison.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "ABC Comparison: Shadow Non-Causality Gate.\n\nThis module provides the ABCComparisonResult dataclass and shadow non-causality\nvalidation logic for promotion.\n\nGOVERNANCE (January 2026):\n    The shadow non-causality gate ensures that Config B (shadow/candidate)\n    does not materially exceed Config A (baseline).",
      "classes": [
        "InsufficientEpisodesError",
        "PairedOutcome",
        "ABCComparisonResult",
        "ShadowNonCausalityError"
      ],
      "functions": [
        "compute_mcnemar_statistic",
        "compute_wilson_confidence_interval",
        "check_shadow_non_causality",
        "check_shadow_non_causality_from_outcomes"
      ],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "DEFAULT_SHADOW_LEAK_THRESHOLD",
        "MIN_EPISODES_FOR_CONFIDENCE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T02:35:18.850684",
        "modified": "2026-01-25T02:35:18.850825",
        "modified_days_ago": 26,
        "lines": 524,
        "size_bytes": 19235,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/aging_policy.py",
      "name": "aging_policy.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"eviction\": \"reasons for evicted hypotheses\n  \"reasons for the 3C\n 4.  LIF ... 3.   fail  state\n 5.  REPE  DED  age and  reason\n  ev  i  c   h  e  G  REASON\n  G  REASON   fail\n  state  REAS  s   usages and  REASON   failed space\n  REASON   failed space\n  REASON   failed\n  REASON   failed\n  REASON   failed\n  ev  i  c   failed\n  REASON   failed\n  ev    reason tracki  n  g  REASON  failed\n  REASON  failed\n  ev  i  c   fail\n  REASON  fail\n  REASON  fail",
      "classes": [
        "EvictionReason",
        "AgingPolicyConfig",
        "AgingRecord",
        "EvictionEvent",
        "AgingManifest",
        "PriorStoreSnapshotRef",
        "AgingPolicyController"
      ],
      "functions": [
        "apply_regression_check_to_dossier"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T21:22:57.690682",
        "modified": "2026-01-24T21:22:57.690832",
        "modified_days_ago": 27,
        "lines": 1053,
        "size_bytes": 37200,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/artifact_closure.py",
      "name": "artifact_closure.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Computes a deterministic artifact closure hash from the required schema and content artifacts referenced by the operator sketch; excludes locator fields from semantic identity.",
      "classes": [
        "ArtifactRefV1",
        "ArtifactClosure"
      ],
      "functions": [
        "_extract_schema_version",
        "_compute_closure_hash"
      ],
      "imports": [
        "__future__",
        "re",
        "dataclasses",
        "typing",
        "core.memory.certification"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T07:53:31.969185",
        "modified": "2026-02-17T10:09:41.574503",
        "modified_days_ago": 3,
        "lines": 377,
        "size_bytes": 16104,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/artifact_store.py",
      "name": "artifact_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\n  \"type\": \"K5\",\n  \"key\": (pack, map (str, dict) -> (str, Any) \n  -> (str, dict) \n  -> (str, dict) \n  -> (str, dict) \n  -> (str, dict  (optional) \n  -> (str, dict) \n        store as (class) \n        with (self) \n        get (self) \n        return (class) \n        \"\"\"\n        \"\"\" \n        Key (str) graph.",
      "classes": [
        "ArtifactBundleV1",
        "ArtifactStore"
      ],
      "functions": [
        "_extract_schema_version",
        "_schema_dir_name",
        "_content_addressed_relpath",
        "compute_content_hash_hex",
        "compute_content_hash",
        "normalize_sha256_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "re",
        "dataclasses",
        "pathlib",
        "typing",
        "core.canonicalization",
        "core.induction.artifact_closure"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.762616",
        "modified": "2026-01-22T23:15:02.680384",
        "modified_days_ago": 29,
        "lines": 596,
        "size_bytes": 21971,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/baseline_mode.py",
      "name": "baseline_mode.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"operator\": {\"fromConfiguralses with customizations from the operational\n    second- configuration for Baseline run. When a run\n    ( wrapping a configuration to run. \"\"\"\n    \"\"\" grid\n    MDL witnesses per mode\n    \"\"\" each\n    witness in data_1 (no op for\n    the t execution\n    (no execution\n    \"\"\" just execution \"\"\"\n    ( structural)\n    execution\n    \"\"\" config for\n    a run \"\"\"\n    (optional)\n    witnesses.\n    \"\"\" each config\n    option\n    the a run\n    \"\"\"\n    - exactly.",
      "classes": [
        "BaselineMode",
        "BaselineWitnessAssertion",
        "BaselineModeSpec"
      ],
      "functions": [
        "emit_prior_read_witness",
        "emit_policy_weight_mutation_witness",
        "emit_hypothesis_proposal_witness",
        "emit_mdl_scoring_witness",
        "emit_learning_activity_witness",
        "compute_spec_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-29T06:58:18.702511",
        "modified": "2026-01-29T06:58:18.702609",
        "modified_days_ago": 22,
        "lines": 514,
        "size_bytes": 17789,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/baseline_runner.py",
      "name": "baseline_runner.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"Runs episodes with enforced baseline metrics and witnesses\",\n  \"Run\" 1\n  \"Run\" result\n\" for each scenario\n\" \n\"Validate\" witnesses, \n\" \n\" metrics\n\"Validate operator \n    execution\n\"Validate\" whether \n    failures\n    \"assert\"\n    \"Isolation\" \n    steps\n    \"witnesses\"\n    \"\"\"Run the\n    scenario in \n    validation\n    \"\"\"Run the baseline and validate \"\"\"Run for \n    isolation\n\"\"\"\n    \"\"\"Run in \n    mode\n    \"\"\"Validate metrics and \n    proposals\n    \"\"\"Validate \n   ...",
      "classes": [
        "EpisodeRunResult",
        "ScenarioRunResult",
        "BaselineRunner",
        "WorldEpisodeRunner",
        "_EscapePhase1Adapter",
        "EscapeEpisodeRunner",
        "_WordNetPhase1Adapter",
        "WordNetEpisodeRunner",
        "_PNPhase1Adapter",
        "PNEpisodeRunner",
        "_DiscoursePhase1Adapter",
        "DiscourseEpisodeRunner"
      ],
      "functions": [
        "_compute_roundtrip_witness",
        "get_world_runner",
        "run_scenario_with_baseline"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "time",
        "dataclasses",
        "datetime",
        "typing",
        "core.governance.run_intent",
        "core.induction.baseline_mode"
      ],
      "constants": [
        "ESCAPE_OPERATOR_FAMILIES",
        "ESCAPE_SCOPE_KEY",
        "WORDNET_OPERATOR_FAMILIES",
        "WORDNET_SCOPE_KEY",
        "PN_OPERATOR_FAMILIES",
        "PN_SCOPE_KEY",
        "DISCOURSE_OPERATOR_FAMILIES",
        "DISCOURSE_SCOPE_KEY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.373811",
        "modified": "2026-01-30T12:05:14.374110",
        "modified_days_ago": 21,
        "lines": 3424,
        "size_bytes": 131330,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/batch_induction_helpers.py",
      "name": "batch_induction_helpers.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Wires evidence weights into batch induction workflows. Author: @darianrosebrook",
      "classes": [],
      "functions": [
        "wire_episode_weights_into_controller"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.induction.evidence_weighting"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T01:18:36.511198",
        "modified": "2026-01-21T11:07:23.574194",
        "modified_days_ago": 30,
        "lines": 59,
        "size_bytes": 1883,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/certificate_builder.py",
      "name": "certificate_builder.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Certificate Builder: Build TD-12/MS certificates from ArtifactClosure.\n\nK5: Certificate is a wrapper around a stored ArtifactClosure, not embedded.\nUses hash-first pattern end-to-end: canonicalize \u2192 hash \u2192 store \u2192 create refs.\n\nAuthor: @darianrosebrook\nDate: December 2025",
      "classes": [
        "OperatorCertificate"
      ],
      "functions": [
        "_compute_content_hash",
        "build_operator_certificate"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T23:14:52.780521",
        "modified": "2026-01-23T15:28:31.041021",
        "modified_days_ago": 28,
        "lines": 335,
        "size_bytes": 14567,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/certificate_verifier.py",
      "name": "certificate_verifier.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Certificate verifier checks TD-12/MS certificates by validating schema, hashes, and closure completeness from artifacts. Supports integrity verification without re-execution; warnings are detected but do not block certification.",
      "classes": [
        "VerificationIssue",
        "VerificationResult"
      ],
      "functions": [
        "verify_operator_certificate",
        "verify_operator_certificate_with_registry",
        "extract_schema_version_from_id",
        "_verify_schema_versions",
        "_verify_ruleset_versions"
      ],
      "imports": [
        "__future__",
        "re",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T23:33:32.807728",
        "modified": "2026-02-17T10:09:41.653569",
        "modified_days_ago": 3,
        "lines": 453,
        "size_bytes": 16961,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/certificates.py",
      "name": "certificates.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Normalizes certificate payloads to full OperatorCertificate format for consistent interface use across the codebase.",
      "classes": [
        "CertificateNormalizationError"
      ],
      "functions": [
        "_artifact_store_load",
        "is_certificate_wrapper",
        "is_full_operator_certificate",
        "normalize_operator_certificate"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-28T21:36:14.377582",
        "modified": "2026-01-22T07:53:46.454424",
        "modified_days_ago": 29,
        "lines": 129,
        "size_bytes": 4664,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/closure_allowlist.py",
      "name": "closure_allowlist.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "provides validate_closure_schema_allowlist.",
      "classes": [],
      "functions": [
        "_iter_closure_refs",
        "_validate_schema_ref",
        "_validate_schema_versions_map",
        "validate_closure_schema_allowlist"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.induction.certificate_verifier"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-07T08:52:39.600221",
        "modified": "2026-01-21T11:21:45.567680",
        "modified_days_ago": 30,
        "lines": 92,
        "size_bytes": 3119,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/counting_prior_store.py",
      "name": "counting_prior_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"CountingPriorStore: Observes PriorStore writes via two-phase observer protocol. Tracks writes_committed and store_changed via hash comparison. Generates PriorStoreWitnesses for training/eval validation. Supports frozen mode with preflight checks that block writes are rejected. Produces canonical \"did write\" events for audit(logs) and metrics include(only) the committed writes as evidence. Can emit store changes as\n  events.   (with logs) for objects.",
      "classes": [
        "FreezeViolationError",
        "CountingPriorStore"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-28T20:39:40.204075",
        "modified": "2026-01-28T20:39:40.204225",
        "modified_days_ago": 23,
        "lines": 274,
        "size_bytes": 9581,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/decision_policy.py",
      "name": "decision_policy.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Implements typed decision system using reason codes for hypothesis lifecycle. Enforces IND-DEC-1 (no influence without eligibility) and IND-DEC-2 (deterministic scoring).",
      "classes": [
        "DecisionPolicyConfig",
        "HypothesisDecisionPolicy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.hypothesis_scoring"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T12:30:32.553784",
        "modified": "2026-01-22T07:53:46.454385",
        "modified_days_ago": 29,
        "lines": 230,
        "size_bytes": 8652,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/delta_clustering.py",
      "name": "delta_clustering.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\": \"Delta clustering using structural signatures (op_category, op_types, target_fields) to group deltas into clusters for operator inference. Each cluster defines a canonical op signature, e.g., {'set enum', 'update', 'insert' ops from delta. Groups similar structural patterns, e.g., {'kill', 'move', 'ms' by shared sig (empty). Every clustering enforces all elements of a cluster must be a subset of base set of all common sigs. Each delta a set. D: {set of (op, set of fields.",
      "classes": [
        "DeltaStructuralSignature",
        "DeltaCluster",
        "DeltaClusteringEngine"
      ],
      "functions": [
        "extract_delta_ops",
        "compute_structural_signature",
        "infer_operator_sketch_from_cluster",
        "_infer_preconditions",
        "_infer_effects",
        "_op_type_to_effect",
        "_infer_parameter_slots",
        "_generate_operator_name"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "collections",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.203285",
        "modified": "2026-01-22T07:53:46.478066",
        "modified_days_ago": 29,
        "lines": 748,
        "size_bytes": 25965,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/delta_pack.py",
      "name": "delta_pack.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "DeltaPack normalizes EditDelta objects for operator induction input to the promotion pipeline. Its hash excludes metadata, using commutative partitioning of edits. Only accepted input format for operator synthesis.",
      "classes": [
        "DeltaPack"
      ],
      "functions": [
        "normalize_delta",
        "_partition_edits_by_type",
        "_sort_edits_within_partition",
        "compute_delta_pack_hash",
        "_canonical_edit_representation"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.contracts.semantic_edits"
      ],
      "constants": [
        "NORMALIZATION_RULESET_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:22.161498",
        "modified": "2026-01-22T07:53:46.454178",
        "modified_days_ago": 29,
        "lines": 314,
        "size_bytes": 10787,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/derivation_run_manifest.py",
      "name": "derivation_run_manifest.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"schema\":...}\n@import \"sterling.utter.utter_v1.0 JSON\n}/governance_v3_json (optional)\n@context_ \"Garden\" and only if\n  present\n@for_  each  task when\n  needed by schema 512\n\"\"\"  \"\"\"  # DO NOT\n  #  A non-optional\n\"\"\"  \"\"\" # A model\n    # Schema  for here\n    \"\"\"  \"\"\"  # A model\n    \"\"\"  # A model\n    \"\"\"  # A model\n",
      "classes": [
        "DerivationRunManifestV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.contracts.governance_status",
        "core.induction.artifact_store",
        "core.induction.hashing"
      ],
      "constants": [
        "DERIVATION_RUN_MANIFEST_SCHEMA_ID",
        "DERIVATION_RUN_MANIFEST_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T15:34:25.166622",
        "modified": "2026-01-23T18:07:50.876567",
        "modified_days_ago": 28,
        "lines": 240,
        "size_bytes": 9244,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "induction/determinism_witness.py",
      "name": "determinism_witness.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "DeterminismWitness captures layer-specific hashes to localize where failures occur in the MOC pipeline. It includes hashes for input selection, execution (search/operators/world), and measurement (metrics, success).",
      "classes": [
        "DeterminismWitness"
      ],
      "functions": [
        "compute_episode_id_list_hash",
        "compute_result_vector_hash",
        "compute_primary_metrics_hash",
        "compute_scenario_config_hash",
        "create_determinism_witness"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T12:53:03.966785",
        "modified": "2026-01-06T14:31:08.843263",
        "modified_days_ago": 45,
        "lines": 237,
        "size_bytes": 8216,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/dialogue_rollout_scenario.py",
      "name": "dialogue_rollout_scenario.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"DialogueRollout induction scenario: outputs observation/goal/label triples from episodes. Each episode returns a (obs, action, state,  outcome, metrics) \n  -  @class DialogueRollout. \n  -  @dataclass Dialogue state observed context = (state_ observed state + outcome_rationale, hypothesis, inference: observe evidence, track goals, assume not validated, architected as context\n -  <   from  model (stage represented  \n 3 simple  \n    rule- all  (scored) rule- simple  eval loop  \n    ",
      "classes": [
        "DialogueScenarioConfig",
        "DialogueLabeledExample",
        "SessionSplit",
        "DialogueScenarioMetrics",
        "DialogueRolloutInductionScenario"
      ],
      "functions": [
        "compute_session_split",
        "compute_scenario_metrics",
        "create_dialogue_scenario",
        "create_scenario_from_episodes"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:34:22.784548",
        "modified": "2026-01-22T07:53:46.454225",
        "modified_days_ago": 29,
        "lines": 872,
        "size_bytes": 30985,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/e2e_certification_pipeline.py",
      "name": "e2e_certification_pipeline.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"A JSON desript from eD induc eD tions on ne\n  xAmple from  induc eGes from  induc e  tional\n```",
      "classes": [
        "CertificateEmissionMode",
        "CertificationPipelineConfig",
        "InductionResult",
        "CertificationResult",
        "MinimalHypothesisIR",
        "MinimalArtifactClosure",
        "MinimalCertificate",
        "E2ECertificationPipeline"
      ],
      "functions": [
        "run_e2e_certification",
        "verify_certificate_determinism"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "time",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-08T17:22:42.868824",
        "modified": "2026-01-22T07:53:46.454021",
        "modified_days_ago": 29,
        "lines": 889,
        "size_bytes": 34355,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_attestation.py",
      "name": "episode_attestation.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\n    \"Merkle_ade_dit_h(sen)\n    stant_tes and ariphering\n}\n    idem and ations\n}",
      "classes": [
        "EpisodeHashRecord",
        "EpisodeBatchRoot",
        "EpisodeAttestationRef",
        "EpisodeProvenanceIndex"
      ],
      "functions": [
        "compute_merkle_root",
        "create_episode_batch_root",
        "extend_certificate_with_episodes",
        "verify_certificate_episodes"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.canonicalization"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T12:37:22.369521",
        "modified": "2026-01-22T07:53:46.503952",
        "modified_days_ago": 29,
        "lines": 515,
        "size_bytes": 16988,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_commitment.py",
      "name": "episode_commitment.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Episode Commitment Schema (v0) defines the canonical episode payload for deterministic hashing by including only semantic content (task, result, operator applications, semantic deltas) and excludes non-semantic metadata (timestamps, run_id, model/KG paths, config). It ensures hash stability across runs by sorting and canonicalizing included fields.",
      "classes": [
        "EpisodeCommitmentV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.hashing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T15:34:09.670060",
        "modified": "2026-01-21T11:21:45.545818",
        "modified_days_ago": 30,
        "lines": 218,
        "size_bytes": 7553,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_induction_input.py",
      "name": "episode_induction_input.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Episode Induction Input: Canonical ingestion path for offline and online induction.\n\nThis module provides a unified interface for loading episodes and converting them\nto observations for hypothesis proposal. Both offline batch tools and online engine\nuse the same ingestion path to prevent incompatible data shapes.",
      "classes": [
        "EpisodeInductionInput",
        "CorpusHygieneReport"
      ],
      "functions": [
        "filter_deltas_to_committed_path",
        "compute_operator_distribution",
        "validate_corpus_hygiene",
        "check_evidence_shape_hygiene"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T15:47:56.589053",
        "modified": "2026-01-18T01:09:51.832466",
        "modified_days_ago": 34,
        "lines": 630,
        "size_bytes": 25552,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_loader_helpers.py",
      "name": "episode_loader_helpers.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Helper functions for loading episodes for offline induction. Converts LoggedEpisode to EpisodeInductionInput formats. Generates a deterministic CorpusPatternReport from loaded episodes and deltas.",
      "classes": [
        "CorpusPatternReport"
      ],
      "functions": [
        "logged_episodes_to_induction_inputs",
        "logged_episode_to_prior_dict",
        "load_episodes_with_hygiene_validation",
        "load_episodes_for_induction",
        "load_semantic_deltas_from_episodes",
        "load_corpus_for_induction",
        "analyze_corpus_patterns"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "pathlib",
        "typing",
        "core.induction.episode_induction_input",
        "core.reasoning.episode_loader"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T16:33:25.780103",
        "modified": "2026-01-21T11:21:45.547959",
        "modified_days_ago": 30,
        "lines": 626,
        "size_bytes": 24538,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_loader_induction.py",
      "name": "episode_loader_induction.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Loads episodes as EpisodeInductionInput, supporting streaming and batch induction with strict semantic delta extraction and operator application. Validates episode hygiene to prevent garbage input.",
      "classes": [],
      "functions": [
        "load_episode_induction_inputs",
        "stream_episode_induction_inputs",
        "_extract_semantic_deltas_from_episode",
        "_extract_semantic_deltas_from_record",
        "_extract_operator_applications_from_episode",
        "_extract_operator_applications_from_record",
        "load_semantic_deltas_from_episodes"
      ],
      "imports": [
        "__future__",
        "json",
        "pathlib",
        "typing",
        "core.induction.episode_induction_input",
        "core.ir.semantic_delta_ir",
        "core.operators.universe",
        "core.reasoning.episode_loader"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T15:48:09.910347",
        "modified": "2026-01-07T12:29:31.325030",
        "modified_days_ago": 44,
        "lines": 261,
        "size_bytes": 8327,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_manifest.py",
      "name": "episode_manifest.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "EpisodeManifestV0 tracks which episodes contributed to prior derivation. It provides a hashable, immutable record of episode inputs for traceability and verification in the promotion pipeline.",
      "classes": [
        "EpisodeManifestV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.artifact_store"
      ],
      "constants": [
        "EPISODE_MANIFEST_SCHEMA_ID",
        "EPISODE_MANIFEST_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T15:52:58.723648",
        "modified": "2026-01-21T11:07:45.600944",
        "modified_days_ago": 30,
        "lines": 88,
        "size_bytes": 2949,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_set.py",
      "name": "episode_set.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"content\": \"A\"    # frozen_set\n    def  \"\"\"    # 20\n    set  and 5\n    \"\"\"    # hash for\n    set  for 5  \"\"\" 20\n    \"\"\" 5  \"\"\"  # 100  episodes\n    from  episode  \"\"\" 20\n    \"\"\" 5  \"\"\"  (set in the 1  \"\"\"\n    # 100\n    \"\"\" 20  \"\"\"\n    # 1A  \"\"\" 5  \"\"\"  \"\"\"\n    # 4  \"\"\"  \"\"\" 5  \"\"\"  \"\"\"\n    # 1  \"\"\"  \"\"\"\n    \"\"\" 1  \"\"\"  \"\"\"\n    \"\"\" 5  \"\"\" 1  \"\"\"  \"\"\"\n    \"\"\" 1  \"\"\" 5\n    \"\"\"\n    \"\"\" 1  \"\"\"  ",
      "classes": [
        "EpisodeSetError",
        "ConfigurationError",
        "PoolBundle",
        "EpisodeSetIntegrityError",
        "EpisodeRecordV1",
        "EpisodeSetV1"
      ],
      "functions": [
        "_compute_pool_content_hash",
        "compute_episode_set_hash",
        "compute_episode_hash",
        "compute_split",
        "compute_train_eval_split",
        "_generate_escape_episode",
        "_load_wordnet_synset_pool",
        "_generate_wordnet_episode",
        "_load_pn_sentence_pool",
        "_load_discourse_scenario_pool"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "random",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing"
      ],
      "constants": [
        "EPISODE_SET_SCHEMA_VERSION",
        "DEFAULT_SEED",
        "TRAIN_SPLIT_RATIO",
        "EPISODE_GENERATORS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:05:46.454435",
        "modified": "2026-01-30T11:05:46.454579",
        "modified_days_ago": 21,
        "lines": 1075,
        "size_bytes": 39932,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/episode_split.py",
      "name": "episode_split.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Deterministically splits episodes into train/eval partitions using episode_ id or commitment hash. Ensures no leakage between partitions. Author: @darianrosebrook.",
      "classes": [
        "SplitMembership"
      ],
      "functions": [
        "split_episodes_train_eval",
        "verify_split_no_leakage"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "T"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T22:07:16.198428",
        "modified": "2026-01-21T11:21:45.549015",
        "modified_days_ago": 30,
        "lines": 145,
        "size_bytes": 5048,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/evidence_weighting.py",
      "name": "evidence_weighting.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "return \"Evidence Weighting\": 0.1 (when) via Outcome Witness... (neural net)\n    weight (for n node post-processing\n    \"evidence\" weight (evidence weight in inference\n    post-processing, normalized.    weights (e.g., \"evidence\" weight (how) in inference\n    return (pass through outcome (when) weight (model) of what\n    node (witness) score\n    at each step: (witness) this step\n    weight (from  (evidence) within Source node post-processing\n    of step\n    \"\"\"\n    return (",
      "classes": [
        "EvidenceWeightingConfig",
        "EpisodeEvidenceWeightV0"
      ],
      "functions": [
        "compute_coverage_score_dialogue",
        "compute_coverage_score_navigation",
        "compute_coverage_score",
        "compute_evidence_weight",
        "compute_episode_evidence_weight",
        "compute_episode_weights",
        "extract_episode_id_from_observation"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.induction.outcome_witness"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T01:08:25.987429",
        "modified": "2026-01-21T11:21:45.549678",
        "modified_days_ago": 30,
        "lines": 328,
        "size_bytes": 10601,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/file_artifact_store.py",
      "name": "file_artifact_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Backward compatibility alias for ArtifactStore. Provides FileArtifactStore wrapping ArtifactStore for legacy code. K5 refactored to use ArtifactStore only.",
      "classes": [
        "FileArtifactStore"
      ],
      "functions": [],
      "imports": [
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:08:33.357486",
        "modified": "2026-01-22T07:53:46.459942",
        "modified_days_ago": 29,
        "lines": 25,
        "size_bytes": 808,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/fixture_manifest.py",
      "name": "fixture_manifest.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "FixtureManifest enforces deterministic fixture selection by content hashes (fixture_hashes, snapshot_hashes) to prevent drift; ensures fixture set hashes are computed from actual content, not names.",
      "classes": [
        "FixtureManifest"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T22:58:58.671096",
        "modified": "2026-01-03T12:03:34.943677",
        "modified_days_ago": 48,
        "lines": 188,
        "size_bytes": 7047,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/gates/__init__.py",
      "name": "__init__.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Gates Package: Governance gates for induction pipeline.\n\nGOVERNANCE (P0-1c - January 2026):\n    Gates live in core/induction/gates/ to avoid dependency inversion.\n    Promotion lane owns gating; benchmarks are downstream consumers.\n\nAuthor: @darianrosebrook\nDate: January 2026",
      "classes": [],
      "functions": [],
      "imports": [
        "core.induction.gates.efficiency_delta_gate"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T06:45:53.350186",
        "modified": "2026-01-27T06:45:53.350303",
        "modified_days_ago": 24,
        "lines": 26,
        "size_bytes": 654,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/gates/efficiency_delta_gate.py",
      "name": "efficiency_delta_gate.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Deterministic sign test (no ci) to show failure\n    # 0.0 with\n    ",
      "classes": [
        "EfficiencyPairingKeyError",
        "EfficiencyDeltaGateConfig",
        "EvalResult",
        "PairedMetrics",
        "EfficiencyDeltaGateResult"
      ],
      "functions": [
        "_compute_episode_set_hash",
        "_pair_results",
        "_compute_effect_size",
        "check_efficiency_delta_gate"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing",
        "core.governance.gate_verdict",
        "core.induction.k1_metrics"
      ],
      "constants": [
        "DEFAULT_EFFICIENCY_GATE_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:15:34.246434",
        "modified": "2026-01-27T07:15:34.247012",
        "modified_days_ago": 24,
        "lines": 609,
        "size_bytes": 21660,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/generalization_bar.py",
      "name": "generalization_bar.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Validates operator sketches using multi-example generalization bar with unique normalized delta content and invariant witness emission.",
      "classes": [
        "ValidationError",
        "InvarianceViolationError"
      ],
      "functions": [
        "validate_with_generalization_bar",
        "_get_unique_normalized_hashes",
        "_has_relevant_support"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:22.161645",
        "modified": "2026-01-22T07:53:46.454339",
        "modified_days_ago": 29,
        "lines": 238,
        "size_bytes": 8931,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/goal_outcome_schema.py",
      "name": "goal_outcome_schema.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Defines minimal required fields for GOAL_OUTCOME join-key observations. Coverage computed separately from terminal state and goal context. Prevents schema changes and hidden dependencies.",
      "classes": [],
      "functions": [
        "validate_goal_outcome_payload",
        "get_goal_outcome_schema"
      ],
      "imports": [
        "typing"
      ],
      "constants": [
        "GOAL_OUTCOME_SCHEMA_VERSION"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T00:46:07.889553",
        "modified": "2026-01-05T07:03:12.327170",
        "modified_days_ago": 46,
        "lines": 119,
        "size_bytes": 4117,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/golden_corpus_provider.py",
      "name": "golden_corpus_provider.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Golden Corpus FixtureProvider loads fixtures from static corpus using GoldenFixtureDescriptor and commits to content hashes. Implements ValidationFixtureProvider protocol. Verifies canonical operator_args during loading. Fails closed semantics for missing files or hash mismatches.",
      "classes": [
        "GoldenCorpusFixtureProvider"
      ],
      "functions": [
        "_default_fixture_dir"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "pathlib",
        "typing",
        "core.induction.fixture_manifest",
        "core.induction.golden_fixture_descriptor"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T07:54:19.703703",
        "modified": "2026-01-22T07:53:46.454158",
        "modified_days_ago": 29,
        "lines": 348,
        "size_bytes": 13416,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/golden_fixture_descriptor.py",
      "name": "golden_fixture_descriptor.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Computes a canonical representation of the descriptor for a golden fixture, serializes fields for test case and snapshot reference, excludes the computed hash during creation. Used for golden artifact comparison without introducing circularity.",
      "classes": [
        "GoldenFixtureDescriptor"
      ],
      "functions": [
        "canonicalize_operator_args",
        "compute_fixture_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [
        "DESCRIPTOR_SCHEMA_ID",
        "DESCRIPTOR_SCHEMA_VERSION",
        "FLOAT_PRECISION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T23:00:01.891135",
        "modified": "2026-01-22T07:53:46.454534",
        "modified_days_ago": 29,
        "lines": 284,
        "size_bytes": 9770,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hashing.py",
      "name": "hashing.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Provides canonical hashing for episode commitments, code bundles, config dicts, and general payloads using consistent JSON normalization. Ensures hash determinism to prevent drift.",
      "classes": [],
      "functions": [
        "compute_hash_dict",
        "hash_code_bundle",
        "hash_episode_commitment",
        "hash_single_file"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "pathlib",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T15:33:57.568668",
        "modified": "2026-01-21T11:07:45.601875",
        "modified_days_ago": 30,
        "lines": 132,
        "size_bytes": 3677,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/heldout_manifest.py",
      "name": "heldout_manifest.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Creates a content-addressed manifest of held-out episodes for paired evaluation between baseline and candidate. Ensures consistent episode IDs for testing.",
      "classes": [
        "HeldOutManifest"
      ],
      "functions": [
        "create_heldout_manifest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T10:43:24.062356",
        "modified": "2026-01-21T11:07:45.602242",
        "modified_days_ago": 30,
        "lines": 174,
        "size_bytes": 6609,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis.py",
      "name": "hypothesis.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"HypothesisIR represents a learned rule or program hypothesis. Provenance tracked via graph edges; node content hash not applied. Predictive features: semantic hashes, operator, model meta, not in hash, potential\nReturn the only a JSON object for a deterministic output (no random)\nState (not StateID.",
      "classes": [
        "HypothesisStatus",
        "HypothesisIR",
        "PredictionIR",
        "InvarianceWitnessIR"
      ],
      "functions": [
        "infer_witness_kind",
        "create_hypothesis",
        "create_prediction",
        "create_witness"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "WITNESS_KIND_BY_INVARIANT"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.203615",
        "modified": "2026-01-22T07:53:46.454368",
        "modified_days_ago": 29,
        "lines": 572,
        "size_bytes": 21948,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_build_failure.py",
      "name": "hypothesis_build_failure.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "HypothesisBuildFailure reasons and ProposalBatch structure for tracking why hypotheses could not be constructed from evidence during induction.",
      "classes": [
        "HypothesisBuildFailure",
        "ProposalBatch"
      ],
      "functions": [
        "_canonicalize_dict"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.induction.hypothesis"
      ],
      "constants": [
        "INSUFFICIENT_EVIDENCE",
        "MISSING_REQUIRED_FIELDS",
        "CLUSTER_TOO_SMALL",
        "SKETCH_INFERENCE_FAILED",
        "HYPOTHESIS_CONVERSION_FAILED",
        "BUDGET_EXHAUSTED",
        "TIME_EXCEEDED",
        "UNKNOWN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.763020",
        "modified": "2026-01-21T11:21:45.553923",
        "modified_days_ago": 30,
        "lines": 191,
        "size_bytes": 6994,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_policy_translator.py",
      "name": "hypothesis_policy_translator.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Strictly validates hypothesis evidence during translation; rejects revoked hypothesis with structured extraction; uses global operator inventory for validation.",
      "classes": [
        "StrictFailureCode",
        "TranslationResult",
        "HypothesisPolicyTranslator"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "typing",
        "core.induction.hypothesis",
        "core.induction.policy_ir",
        "core.operators.inventory"
      ],
      "constants": [
        "UNIVERSAL_OPERATOR_IDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.203897",
        "modified": "2026-01-23T14:52:26.921533",
        "modified_days_ago": 28,
        "lines": 822,
        "size_bytes": 39385,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_program.py",
      "name": "hypothesis_program.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"Hypothesis programs are executed from registered interpreters.  \"\"\"\nReturn type-compatible\n    structures. \"\"\"\n    TC-10: deterministic\n    failures; code reference\n    execution.  \"\"\"\n    Built-in operator\n    tests.",
      "classes": [
        "HypothesisProgramError",
        "UnknownProgramKindError",
        "ProgramExecutionError",
        "ProgramResult",
        "HypothesisProgram",
        "BaseHypothesisProgram",
        "OperatorPatternProgram",
        "EntityRelationProgram",
        "TransformationRuleProgram",
        "HypothesisProgramInterpreter"
      ],
      "functions": [
        "get_default_interpreter",
        "register_program_kind"
      ],
      "imports": [
        "__future__",
        "abc",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass",
        "runtime_checkable"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.763385",
        "modified": "2026-01-22T07:53:46.454273",
        "modified_days_ago": 29,
        "lines": 641,
        "size_bytes": 21974,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_proposer.py",
      "name": "hypothesis_proposer.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Hypothesis Proposer acts as a legacy wrapper for the core.induction.proposer module, enabling proposal generation for hypothesis induction.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.induction.proposer"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.763650",
        "modified": "2026-01-14T16:11:39.763750",
        "modified_days_ago": 37,
        "lines": 27,
        "size_bytes": 640,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_refiner.py",
      "name": "hypothesis_refiner.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Hypothesis refinement operator (BUD-IND-2 strategies, enforcing monotonic improvement or exploratory mode per refinement.  \nfrom BUD-IND-2 for each step  \n",
      "classes": [
        "RefinementType",
        "RefinementMetrics",
        "RefinementResult",
        "RefinementBudget",
        "RefinementStrategy",
        "SpecializationStrategy",
        "GeneralizationStrategy",
        "ExceptionHandlingStrategy",
        "HypothesisRefiner"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T09:45:12.458345",
        "modified": "2026-01-22T07:53:46.478172",
        "modified_days_ago": 29,
        "lines": 641,
        "size_bytes": 20157,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_scoring.py",
      "name": "hypothesis_scoring.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"type\": \"Hypothesis\",\n    \"Hypothesis_tested_scores (strict)\n    \"NO_Score_final &  a; scores are derived from test + success\n    (strict)\n    tests can only yield certain scores\n    (strict)\n    optional\n    (strict)\n    \"WANT\"-marked step solely (if test_ step\n    \"NO_ test\n    \"NO- return\n    \"ONLY\"\n    (return)\n    \"EXHAShm (strict) (returnable)\n    \"YIELD_ID_ when\n    \"TEST\"\n    \"RETURN\"  (score_test\n    \"EXACT\"\n    \"NO-  test\n    \"DEP\"\n    \"Y\" and only\n    \"Yield\" when\n    \"TEST\"\n   ...",
      "classes": [
        "MDLBreakdownV1",
        "FitSummaryV1",
        "StabilitySummaryV1",
        "UtilitySummaryV1",
        "NoveltySummaryV1",
        "EligibilitySummaryV1",
        "DecisionV1",
        "HypothesisScorecardV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "REASON_NO_INTERPRETER",
        "REASON_NO_TESTED_PREDICTIONS",
        "REASON_INVARIANCE_UNTESTED",
        "REASON_INVARIANCE_FAIL",
        "REASON_DETERMINISM_FAIL",
        "REASON_BUDGET_EXCEEDED",
        "REASON_UNSAFE_APPLICATION",
        "REASON_FAIL_RATE_HIGH",
        "REASON_UNKNOWN_RATE_HIGH",
        "REASON_WITNESS_SEVERITY_HIGH"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:13:36.147990",
        "modified": "2026-01-22T07:53:46.459785",
        "modified_days_ago": 29,
        "lines": 253,
        "size_bytes": 9108,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_selection.py",
      "name": "hypothesis_selection.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Ranks and selects hypotheses using fit (primary), MDL (tie-breaker, only for eligible hypotheses, does not affect world transitions. Ranks hypotheses using fit + inverted MDL for ranking with fit as primary. Uses stability as secondary.  ",
      "classes": [
        "SelectionScore",
        "SelectionPolicyConfig",
        "HypothesisSelectionPolicy",
        "HypothesisInfluence"
      ],
      "functions": [
        "compute_hypothesis_influence"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T09:40:42.813696",
        "modified": "2026-01-22T07:53:46.454292",
        "modified_days_ago": 29,
        "lines": 409,
        "size_bytes": 13081,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/hypothesis_state.py",
      "name": "hypothesis_state.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "HypothesisState: Optional extension to StateNode for induced hypotheses.\n\nFollows Pattern C (KGRef model): Lightweight reference + external storage.\nFull HypothesisIR objects live in StateGraph nodes and episode artifacts.\n\nThis is an OPTIONAL extension attached to StateNode (backward compatible).\nStateNode.hypothesis_state defaults to None.",
      "classes": [
        "HypothesisState"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T00:58:14.787728",
        "modified": "2026-01-22T07:53:46.454017",
        "modified_days_ago": 29,
        "lines": 190,
        "size_bytes": 6680,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/induction_readiness_tripwires.py",
      "name": "induction_readiness_tripwires.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Induction Readiness Tripwires module that computes and checks induction readiness via hard and soft metrics, failing loudly if hard gates not met; enables tuning with configurable thresholds for deltas and proposals.",
      "classes": [
        "InductionReadinessMetrics",
        "InductionReadinessConfig"
      ],
      "functions": [
        "compute_induction_readiness_metrics",
        "check_induction_readiness",
        "validate_induction_readiness"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T07:08:52.451658",
        "modified": "2026-01-21T11:21:45.559357",
        "modified_days_ago": 30,
        "lines": 287,
        "size_bytes": 10519,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/induction_session.py",
      "name": "induction_session.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Accumulates observations and hypotheses across episodes. Separates episode governance from session-level induction (pooling, aggregation).",
      "classes": [
        "InductionSession"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T18:41:05.370056",
        "modified": "2026-01-21T11:21:45.559662",
        "modified_days_ago": 30,
        "lines": 147,
        "size_bytes": 5434,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/invariance_checker.py",
      "name": "invariance_checker.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Cross-Example Invariance Checker (TC-8, ARCH-IND-1).\n\nChecks that a hypothesis satisfies invariants across all demonstrations.\nA hypothesis must pass invariance checks before it can be applied to held-out inputs.\n\nKey invariants:\n- TC-8: Cross-example invariance gate - hypotheses must satisfy declared\n        invariants across all demonstrations before held-out application.",
      "classes": [
        "InvariantCheckResult",
        "InvarianceDiagnostics",
        "CrossExampleInvarianceResult",
        "InvariantChecker",
        "PredictionConsistencyChecker",
        "TestOutcomeMonotonicityChecker",
        "NoExceptionChecker",
        "CrossExampleInvarianceChecker"
      ],
      "functions": [
        "_get_state_hash",
        "create_default_checker"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-08T17:42:04.709253",
        "modified": "2026-01-22T07:53:46.499348",
        "modified_days_ago": 30,
        "lines": 899,
        "size_bytes": 36599,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/k1_evaluation_ir.py",
      "name": "k1_evaluation_ir.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "K1 Evaluation IR captures the closure of K1 reruns, including held-out tasks, policies, engine configuration, and seed for deterministic evaluation. Enables certificate verification by re-running with same closure.",
      "classes": [
        "K1EvaluationIR"
      ],
      "functions": [
        "compute_engine_config_hash",
        "_canonicalize_sweep_context"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T18:35:53.259958",
        "modified": "2026-01-21T11:07:45.606937",
        "modified_days_ago": 30,
        "lines": 187,
        "size_bytes": 7086,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/k1_metrics.py",
      "name": "k1_metrics.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Computes paired deltas and significance per regime using exact permutation test\n \"\"\" \n    Test regime requires: 3. Power analysis\n    This is a strict test of K1a (not) fixe d 3.    Test statistic and 2 benchmark's a governance. Bench: K1 (presence of gate crbug/fix. 4. K1a presence\n    bench fails e2.    When e2e 3.  This component\n    -- bench.    Execution shuffling (the baseline)\n    (fix) e. Bench failure\n    type: fail fast; severity/power.",
      "classes": [
        "K1PairingKeyError",
        "PowerFloorConfig",
        "SignificanceOutcome",
        "UniformSignificanceResult",
        "SuccessRateDelta",
        "SignificanceResult"
      ],
      "functions": [
        "compute_uniform_significance",
        "compute_success_rate_delta",
        "_compute_paired_bootstrap_ci",
        "test_statistical_significance",
        "sign_test",
        "_exact_binomial_p_value",
        "_binomial_cdf_tail",
        "_log_binomial_coefficient",
        "wilcoxon_signed_rank_test",
        "_compute_bootstrap_seed"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "math",
        "random",
        "statistics",
        "dataclasses",
        "enum",
        "typing",
        "core.worlds.base"
      ],
      "constants": [
        "DEFAULT_POWER_FLOOR"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:29:12.734622",
        "modified": "2026-01-25T21:30:59.494154",
        "modified_days_ago": 26,
        "lines": 948,
        "size_bytes": 35708,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/k1_substrate_extractor.py",
      "name": "k1_substrate_extractor.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Extracts test substrates from episode logs as TestSubstrateEnvelope. Uses semantic deltas and minimal domain-specific payloads (WordNet, PN, Dialogue) without reconstructing full states. Verifies determinism via consistent episode-to-substrate mapping and evaluation criteria from task/goal spec, not episode results.",
      "classes": [],
      "functions": [
        "extract_test_substrates_from_episode",
        "verify_substrate_extraction_determinism",
        "_extract_wordnet_payload",
        "_extract_wordnet_evaluation_criteria",
        "_extract_pn_payload",
        "_extract_pn_evaluation_criteria",
        "_extract_dialogue_payload",
        "_extract_dialogue_evaluation_criteria"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.k1_test_substrate"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T09:45:51.015627",
        "modified": "2026-01-21T11:21:45.563274",
        "modified_days_ago": 30,
        "lines": 462,
        "size_bytes": 16078,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/k1_test_substrate.py",
      "name": "k1_test_substrate.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "K1 test substrate provides schema-versioned, hash-committed payloads for world-specific verification without reconstructing full state. Envelope stores only required evidence and evaluation criteria, not episode results. Deterministic hashing via canonical payload structure.",
      "classes": [
        "TestSubstrateEnvelope",
        "WordNetSubstratePayload",
        "PnSubstratePayload",
        "DialogueSubstratePayload"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.763842",
        "modified": "2026-01-21T11:21:45.563923",
        "modified_days_ago": 30,
        "lines": 270,
        "size_bytes": 10361,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/lifecycle_controller.py",
      "name": "lifecycle_controller.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\": \"Manages the full hypothesis lifecycle: proposal, testing, selection, and final use as proven operator within a search node (TC). On successful proposal, creates new nodes for so choice. On failure, retry logic operators.  # Optional: some path(s)  #  #  try: each operator.  #  Try and only if operator/success. # Some path - #  #  try: (no-op) while backtracking.  #  #  try: each node. #  try: each search step.  #  try: when to expand.",
      "classes": [
        "HypothesisLifecycleConfig",
        "HypothesisLifecycleState",
        "HypothesisLifecycleController"
      ],
      "functions": [
        "create_lifecycle_controller"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.hypothesis"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-28T12:13:18.196117",
        "modified": "2026-01-28T12:13:18.196273",
        "modified_days_ago": 23,
        "lines": 1913,
        "size_bytes": 77155,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/minimal_test_adapter.py",
      "name": "minimal_test_adapter.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Certifies minimal StateNode test results for Stage K K0 without full state reconstruction. Satisfies W-TEST-1 and allows K0 gate passage. Used in the induction pipeline for hypothesis testing.",
      "classes": [
        "MinimalTestAdapter"
      ],
      "functions": [
        "create_minimal_state_node",
        "create_minimal_test_adapter"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T19:00:05.493318",
        "modified": "2026-01-21T11:07:45.610974",
        "modified_days_ago": 30,
        "lines": 172,
        "size_bytes": 5242,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/ms_artifact_store.py",
      "name": "ms_artifact_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Backward compatibility alias for ArtifactStore. K5 refactor: MSArtifactStore is now just ArtifactStore. Provides legacy import mapping for existing induction code.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.induction.artifact_store"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T09:23:53.709028",
        "modified": "2026-01-22T07:53:46.478090",
        "modified_days_ago": 29,
        "lines": 12,
        "size_bytes": 303,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/nontriviality_gates.py",
      "name": "nontriviality_gates.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Stage K, with \u2265 1  (strict progress and leverage)\n    If K then K can only if\n    test_ observations like (an  # Each K means K: 10% test(k=3.0  # ntest_k quality(evidence weight) 10\n    # 10  # open vs closed and 10%  # closed per 40\n    test operations  # 100% operators\n    # 90 inferences for 90% of 100% certain\n    # 70% confidence\n    from 80% 60\n    # 50%  for K2 validation\n    \"\"\" # 80% 90% 90 governance\n    (interpretation 90%  D 80\n    deterministic\n    pass 90% 99  #...",
      "classes": [
        "NonTrivialityMetrics",
        "NonTrivialityGates",
        "NonTrivialityViolation",
        "NonTrivialityResult",
        "InductionReadinessResult",
        "DeterminismWitness",
        "BaselineDeterminismResult"
      ],
      "functions": [
        "compute_nontriviality_metrics",
        "validate_nontriviality",
        "check_induction_readiness"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-08T17:40:44.031067",
        "modified": "2026-01-17T18:49:21.861533",
        "modified_days_ago": 34,
        "lines": 704,
        "size_bytes": 26315,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/operator_sketch.py",
      "name": "operator_sketch.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Implement hash-stable core definition for operator sketches as input to MIR.\n    @class{stringified key patterns, abstract syntax tree, operator sequence for each node.    @abstract syntax*.\n    @class{string,**kwargs} instances L* for each new-abstract class (type)*\n    def create_node(self)     returns str and node's args.\n    def get_node(ark, ,  value,  type values,  and  optional sqrt keys for each  node.\n    def test_ast(  abstract syntax  for  test inputs.",
      "classes": [
        "InferredClause",
        "ParameterSlot",
        "OperatorSketchCoreIR",
        "TierTransition",
        "ScenarioImprovement",
        "RegressionCheck",
        "OperatorSketchDossierIR"
      ],
      "functions": [
        "create_operator_sketch",
        "verify_hash_stability"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "datetime",
        "typing",
        "core.induction.program_canonicalization"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:22.161755",
        "modified": "2026-01-22T07:53:46.478039",
        "modified_days_ago": 29,
        "lines": 791,
        "size_bytes": 31217,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/operator_synthesizer.py",
      "name": "operator_synthesizer.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\": \"Synthesis of 1.0  (op_ return  (\\\\nops for each  X  return\\\\type: \\\\(\\\\text{op_string\\\\ (\\\\text{apply} each  op\\\\type\\\\ interpret for nop_dsl\\\\ interpret\\\\op for n\\\\ data\\\\ interpret  (\\\\text{apply} op\\\\text{graph}(sketch_data) \\\\to  graph  (\\\\traverse) op\\\\  return\\\\type\\\\ (\\\\node_set\\\\of\\\\  (\\\\text{apply}  (\\\\text{graph}, state\\\\  of\\\\node\\\\text{apply}  (\\\\text{graph} (\\\\node,  apply\\\\node\\\\type\\\\ interpret\n\\\\node evaluation \\\\of  sketch and  graph\\\\ finalize\\\\op  \\\\to ...",
      "classes": [
        "Opcode",
        "BytecodeInstruction",
        "OperatorBytecodeV1",
        "SynthesisError",
        "UnsupportedConstructError",
        "CompilationError",
        "KernelProvider",
        "PNKernelProvider",
        "SynthesisResult",
        "BytecodeCompiler",
        "BytecodeInterpreter",
        "ExecutionContext",
        "OperatorSynthesizer"
      ],
      "functions": [
        "create_synthesizer"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "DSL_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-19T22:34:33.173521",
        "modified": "2026-01-22T07:53:46.443157",
        "modified_days_ago": 29,
        "lines": 1592,
        "size_bytes": 56148,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/orchestrator.py",
      "name": "orchestrator.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Enforces Stage K induction pipeline: delta \u2192 sketch \u2192 sandbox \u2192 certify \u2192 promote. Only PromotionService can create PromotionToken for certified path. All operators must traverse this lane; no bypass. Author: @darianrosebrook, Date: December 25.",
      "classes": [
        "PipelineEvent",
        "InductionOrchestrator",
        "PromotionGateViolation"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.204190",
        "modified": "2026-01-22T07:53:46.454326",
        "modified_days_ago": 29,
        "lines": 1287,
        "size_bytes": 55016,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/outcome_witness.py",
      "name": "outcome_witness.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "```python\nfrom core reasoning.operators import semantic operators domain\nfrom core. reasoning import deductive_knowledge graph operators domain (MAND, MOR, NOT for each type, state, context (evidence, execution: Python, exact matches (subgoal, operator, domain, and effect, context (not) (Python) state: match (premobject: return type (python). A. resolution\n",
      "classes": [
        "OutcomeWitnessExtractionError",
        "StateResolver",
        "InlineStateResolver",
        "ObjectStoreStateResolver",
        "OutcomeWitnessV0"
      ],
      "functions": [
        "_set_object_store_resolver_warned",
        "select_terminal_node_deterministic",
        "reconcile_goal_satisfaction",
        "infer_task_family",
        "extract_evidence_handles",
        "extract_goal_context_from_episode",
        "get_goal_schema",
        "get_coverage_schema",
        "extract_dialogue_coverage",
        "extract_navigation_coverage"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_OBJECT_STORE_RESOLVER_WARNED"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-05T00:54:14.491624",
        "modified": "2026-01-23T17:28:26.860621",
        "modified_days_ago": 28,
        "lines": 946,
        "size_bytes": 35802,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/overlay_registry.py",
      "name": "overlay_registry.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "OverlayRegistry provides a read-only overlay over the base OperatorRegistry. K4.1 enforces that only the overlay may be modified; the base registry is immutable during sandbox validation. P0 Governance (A.4) requires all operator applications to pass a single enforcement layer, preventing bypass in certifying contexts.",
      "classes": [
        "OverlayBypassError",
        "OverlayRegistry"
      ],
      "functions": [
        "_call_precondition_predicate",
        "_call_operator_impl"
      ],
      "imports": [
        "__future__",
        "inspect",
        "logging",
        "typing",
        "core.contracts.governance_status"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:51:36.665831",
        "modified": "2026-01-24T23:51:36.666007",
        "modified_days_ago": 27,
        "lines": 585,
        "size_bytes": 22054,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/pn_rollout_scenario.py",
      "name": "pn_rollout_scenario.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"PN rollouts must satisfy  K1.0. Episodes for  - explicit 4. Observations for  G  - 1.  str to 2. \nPN  - 3. \n  - 4.  str - 5.  G  - 1. \n    - 2.  G  - 3. 4.  str - 5.  G  - 0.  K1.  str - 2. \n    G 3. 4. 5. 0. \n    require 1. 4.  - 5. 0. 1. \n    G 2. 3. \n    return type: 4. 5. \n    G 0 1. \n    G 2. \n    G 3. 5",
      "classes": [
        "PNScenarioConfig",
        "PNLabeledExample",
        "PNSessionSplit",
        "PNScenarioMetrics",
        "PNRolloutInductionScenario"
      ],
      "functions": [
        "create_pn_scenario"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-16T08:40:02.230121",
        "modified": "2026-01-21T11:07:45.619932",
        "modified_days_ago": 30,
        "lines": 1078,
        "size_bytes": 46115,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/pn_semantic_metrics.py",
      "name": "pn_semantic_metrics.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Computes semantic correctness metrics for Stage K using deterministic normalization. For canonicalize tasks with correctness_witness_type 'goal_signature_v1', signature_match_rate is authoritative. Surface exact match is diagnostic only. Mismatch cases are bucketed. Measures per PN task type.",
      "classes": [],
      "functions": [
        "normalize_pn_task_type",
        "normalize_pn_surface",
        "_bucket_surface_mismatch",
        "compute_pn_semantic_metrics"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T18:10:46.966342",
        "modified": "2026-01-21T11:21:45.550419",
        "modified_days_ago": 30,
        "lines": 407,
        "size_bytes": 17765,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "induction/policy_ir.py",
      "name": "policy_ir.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"policy_id\",\"description\":str -> (not a key in the class (max keys)\n    # a key\\.",
      "classes": [
        "PolicyIR",
        "PolicySelectorResult"
      ],
      "functions": [
        "matches_scope",
        "compute_scope_hash",
        "create_policy",
        "create_baseline_policy",
        "select_policy_for_task",
        "_count_policies_with_same_specificity",
        "_select_most_specific",
        "_merge_policy_weights"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "SCOPE_CONTRACT_VERSION",
        "SELECTOR_CONTRACT_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.204514",
        "modified": "2026-01-21T11:21:45.551831",
        "modified_days_ago": 30,
        "lines": 729,
        "size_bytes": 29329,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/policy_scope.py",
      "name": "policy_scope.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"global\": {\"tasks\": 2.  # task keys\n    # A 1.  # te  # Minimal  task_  data structure\n    # 1.  task\n    #  with 2.  (optional)\n    # 1.  # 1.  audit  (return 0  # 0.  audit  (return 0  # 0  (optional)\n    # 2. 0  # 0  and 1  # 0  return 0  # 0  # Minimal  return  on  # 0  # 1  audit  (return 0  # 0  # 0  # 0  # 2.  process  and  # 0  # 0  # 0  # 0  # 2",
      "classes": [
        "ScopeMode",
        "DerivationMethod",
        "EvidenceDistribution",
        "PolicyScopeV1",
        "HeldoutSlice"
      ],
      "functions": [
        "create_global_scope",
        "create_task_type_scope",
        "create_task_family_scope",
        "parse_cli_scope",
        "derive_scope_from_evidence",
        "filter_heldout_by_scope",
        "_get_episode_id",
        "_get_task_type",
        "_build_task_metadata",
        "_compute_slice_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "POLICY_SCOPE_CONTRACT_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T16:16:44.023813",
        "modified": "2026-01-21T11:21:45.553162",
        "modified_days_ago": 30,
        "lines": 856,
        "size_bytes": 32088,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/policy_snapshot.py",
      "name": "policy_snapshot.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Captures episode policy parameters for reproducibility and governance auditing. Generates a hash of effective policy and a unique snapshot_id for indexing. Enables fail-closed verification and drift detection.",
      "classes": [
        "PolicySnapshot"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "datetime",
        "typing",
        "core.induction.decision_policy",
        "core.induction.hypothesis_selection",
        "core.induction.lifecycle_controller",
        "core.induction.prior_influence_gate"
      ],
      "constants": [
        "POLICY_SNAPSHOT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:50:46.788679",
        "modified": "2026-01-22T07:53:46.499307",
        "modified_days_ago": 29,
        "lines": 279,
        "size_bytes": 12780,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/policy_to_prior.py",
      "name": "policy_to_prior.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Converts certified K1 PolicyIR artifacts to PriorIR for persistent storage.",
      "classes": [],
      "functions": [
        "policy_ir_to_prior_ir"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.policy_ir",
        "core.induction.prior_ir"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-07T13:20:21.991391",
        "modified": "2026-01-21T11:07:23.612158",
        "modified_days_ago": 30,
        "lines": 139,
        "size_bytes": 5228,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/policy_weights_artifact.py",
      "name": "policy_weights_artifact.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\": \"Policy weights artifact for M in EscapeGame's edge-learned weights persist\n    in a 1.0  (base and 1.0 (struct)\n    \"\"\"Return all\n        \"\"\" serializable\n        graph: EMA hyperparameters\n        on 1st0 (only)\n    \"\"\" hyperparameters, inputs\n        to 0 (not)\n    \"\"\"State:  (all  (discrete)  observations.",
      "classes": [
        "EdgeWeightState",
        "PathAlgebraConfigSnapshot",
        "PolicyWeightsArtifactV0",
        "PolicyWeightsDiffV0",
        "CausalAblationWitness"
      ],
      "functions": [
        "_edge_key_to_str",
        "_str_to_edge_key",
        "create_policy_weights_artifact",
        "compute_weights_diff",
        "prepare_weights_for_evaluation",
        "shuffle_learned_weight_tuples",
        "zero_learned_weights"
      ],
      "imports": [
        "__future__",
        "json",
        "dataclasses",
        "datetime",
        "typing",
        "core.induction.artifact_store",
        "random"
      ],
      "constants": [
        "EVAL_BASELINE_W_NOVELTY",
        "EVAL_BASELINE_VISIT_COUNT",
        "EVAL_BASELINE_LAST_USED_STEP"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:15.481858",
        "modified": "2026-01-27T07:16:15.481975",
        "modified_days_ago": 24,
        "lines": 729,
        "size_bytes": 25307,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prediction_spec_registry.py",
      "name": "prediction_spec_registry.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "PredictionSpecRegistry stores PredictionSpec keyed by (world_id, program_kind) with explicit initialization via build_prediction_spec_registry. Fail-closed: Missing spec prevents K1 execution. Registry built with pure functions.",
      "classes": [
        "PredictionSpec",
        "PredictionSpecRegistry"
      ],
      "functions": [
        "build_prediction_spec_registry"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T09:43:54.122308",
        "modified": "2026-01-21T11:21:45.554206",
        "modified_days_ago": 30,
        "lines": 207,
        "size_bytes": 6573,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prediction_specs/__init__.py",
      "name": "__init__.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Prediction Specs: World-specific prediction encoding and verification.\n\nAuthor: @darianrosebrook\nDate: January 2026",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T09:53:03.517298",
        "modified": "2026-01-06T14:31:06.945240",
        "modified_days_ago": 45,
        "lines": 6,
        "size_bytes": 124,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prediction_specs/pn_operator_pattern.py",
      "name": "pn_operator_pattern.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Encodes OPERATOR_ PATTERN hypotheses for PN domain and verifies them using the PN WorldAdapter. Provides prediction and validation for operator pattern in PN programs.",
      "classes": [
        "PredictionEncodingError",
        "PredictionVerificationError",
        "PnOperatorPatternSpec"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.k1_test_substrate",
        "core.induction.prediction_spec_registry",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-08T14:24:53.607197",
        "modified": "2026-01-21T11:21:45.555264",
        "modified_days_ago": 30,
        "lines": 167,
        "size_bytes": 5969,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prediction_specs/wordnet_operator_pattern.py",
      "name": "wordnet_operator_pattern.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "WordNetOperatorPatternSpec encodes and verifies OPERATOR_ PATTERN hypotheses using a WordNetWorldAdapter and TestResultIR checks.",
      "classes": [
        "PredictionEncodingError",
        "PredictionVerificationError",
        "WordNetOperatorPatternSpec"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.induction.k1_test_substrate",
        "core.induction.prediction_spec_registry",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T09:53:21.788920",
        "modified": "2026-01-21T11:21:45.555824",
        "modified_days_ago": 30,
        "lines": 227,
        "size_bytes": 8548,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_artifact_envelope.py",
      "name": "prior_artifact_envelope.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Prior Artifact Envelope v0 stores governance metadata (lineage, derivation config, code identity) separately from evolving payload. Used to track and validate prior artifacts during the promotion pipeline.",
      "classes": [
        "PriorArtifactEnvelopeV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.canonicalization",
        "core.induction.artifact_closure",
        "core.induction.artifact_store",
        "core.induction.prior_ir"
      ],
      "constants": [
        "PRIOR_ARTIFACT_ENVELOPE_SCHEMA_ID",
        "PRIOR_ARTIFACT_ENVELOPE_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.764574",
        "modified": "2026-01-21T11:07:45.622790",
        "modified_days_ago": 30,
        "lines": 233,
        "size_bytes": 10460,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_derivation.py",
      "name": "prior_derivation.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Derives operator priors from episode outcomes (success, failure, total uses, scope metrics, returns only JSON, operator statistics\n\\\"\\\"\\\" (\\\" runtime features store states only derived from \\\"...",
      "classes": [
        "OperatorFamilyStats",
        "PriorCandidate",
        "PriorDerivationConfig",
        "PriorDerivationEngine"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "inspect",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.induction.prior_ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.764838",
        "modified": "2026-01-22T07:53:46.454116",
        "modified_days_ago": 29,
        "lines": 641,
        "size_bytes": 25613,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_index.py",
      "name": "prior_index.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Prior Index v0 provides a global mapping from prior_hash to artifact references. Sprint 2.5 enables restart-safe discovery without store-side queries. Entries are serialized and sorted by prior_hash for deterministic access.",
      "classes": [
        "PriorIndexV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.artifact_closure",
        "core.induction.artifact_store"
      ],
      "constants": [
        "PRIOR_INDEX_SCHEMA_ID",
        "PRIOR_INDEX_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T14:20:51.084750",
        "modified": "2026-01-21T11:07:45.623927",
        "modified_days_ago": 30,
        "lines": 112,
        "size_bytes": 3475,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_influence_gate.py",
      "name": "prior_influence_gate.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Prior Influence Gate: Boosts operator scores using decayed PriorStore results. Prior influence is additive and clamped by safety envelope. Boosts are episode-specific and recorded in PriorInfluenceIR for auditability. Prior influence application is deterministic and traceable via episode bundles. PriorInfluence is applied per-episode, per-operator. PriorStore queries operator behavior.",
      "classes": [
        "PriorInfluenceConfig",
        "PriorInfluenceGate"
      ],
      "functions": [
        "apply_prior_influence_to_operator_score"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.prior_ir",
        "core.induction.prior_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T21:57:39.487213",
        "modified": "2026-01-22T07:53:46.461219",
        "modified_days_ago": 29,
        "lines": 557,
        "size_bytes": 23055,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_ir.py",
      "name": "prior_ir.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "to  represent complex  and  structures\n    for  (content  hashing with  C-  (external)  references\n    as  a  (content addressing in  schema for  unstructured  from  shared  state\n    keys  for  each  component  (hashable)  in  one  per  component\n    has  one  per  rule\n    with  rule\n    to  match  and  identity\n    of  (content  addressable)\n    in  a  verifiable\n    way  content  address\n    data  (non-  se  (hash)  and  must  be  verifiable\n    by  content  address and  structure\n    with ...",
      "classes": [
        "PayloadKind",
        "ArtifactRef",
        "EvidenceManifest",
        "OperatorPriorityPayload",
        "SketchTemplatePayload",
        "SafetyEnvelope",
        "PriorIR",
        "PriorInfluenceIR"
      ],
      "functions": [
        "quantize_float",
        "ref_sort_key"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "MICRO"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T21:58:36.720914",
        "modified": "2026-01-22T07:53:46.454202",
        "modified_days_ago": 29,
        "lines": 530,
        "size_bytes": 20855,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_key_types.py",
      "name": "prior_key_types.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Canonical key types for prior indexing and querying. Sprint 2.5 prevents identity drift by normalizing key types at the type level. All prior keys use these canonical types instead of raw strings.",
      "classes": [],
      "functions": [
        "normalize_scope_key",
        "normalize_family_tag"
      ],
      "imports": [
        "typing",
        "core.reasoning.prior_scope"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T15:52:45.288971",
        "modified": "2026-01-21T11:07:45.609285",
        "modified_days_ago": 30,
        "lines": 71,
        "size_bytes": 1925,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_store.py",
      "name": "prior_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Prior Store module implements artifact storage and resolution for certified prior artifacts. Stores are content-addressable by hash and epistemic proof objects. Non-repeating content hashes for deterministic storage. (IV) via Evidence to model/ operator proofs. Write Gated Recommon (T1) operator storage. Gated access (T1) for operator proofs. Gated signatures. (see I, W3 from e2 OR C. Each (R) eXtence (I) access 3. G: Have current key. Provenance links.",
      "classes": [
        "PriorStoreObserver",
        "PriorLineageInputs",
        "ArtifactStore",
        "PriorStoreConfig",
        "PriorStore"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "typing",
        "core.induction.prior_ir",
        "core.induction.prior_store_errors"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-28T15:44:19.413242",
        "modified": "2026-01-28T15:44:19.413388",
        "modified_days_ago": 23,
        "lines": 1245,
        "size_bytes": 49898,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_store_errors.py",
      "name": "prior_store_errors.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Prior store errors: structured exceptions for prior artifact operations. Sprint 2.5 introduces fail-closed error handling for governance invariants.",
      "classes": [
        "PriorArtifactError",
        "PriorArtifactDecodeError",
        "PriorArtifactNotFoundError",
        "PriorIndexNotFoundError",
        "PriorIndexConcurrencyError",
        "PriorDerivationCodeHashError",
        "PriorDerivationEpisodeHashMissingError"
      ],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T14:21:01.926972",
        "modified": "2026-01-21T11:21:45.560179",
        "modified_days_ago": 30,
        "lines": 90,
        "size_bytes": 2939,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_training_loop.py",
      "name": "prior_training_loop.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Prior Training Loop: Batch training step for prior derivation.\n\nSprint 2.5: Separate training loop module (offline batch, not online learning).",
      "classes": [
        "DerivationRunResult"
      ],
      "functions": [
        "is_certified_episode",
        "filter_episodes_by_criteria",
        "run_prior_training_step"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.induction.artifact_store",
        "core.induction.derivation_run_manifest",
        "core.induction.prior_derivation",
        "core.induction.prior_store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-04T15:34:44.675231",
        "modified": "2026-01-21T11:21:45.561047",
        "modified_days_ago": 30,
        "lines": 529,
        "size_bytes": 21547,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/prior_verifier.py",
      "name": "prior_verifier.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Verifies TC-11 v0 prior artifacts by checking schema, payload hash, episode manifest, config hash, and identity; returns VerificationResult on failure.",
      "classes": [
        "VerificationResult",
        "PriorVerifierV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.canonicalization",
        "core.canonicalization.errors",
        "core.induction.artifact_closure",
        "core.induction.artifact_store",
        "core.induction.episode_manifest",
        "core.induction.prior_artifact_envelope"
      ],
      "constants": [
        "TC11V0_ENVELOPE_MISSING",
        "TC11V0_SCHEMA_MISMATCH",
        "TC11V0_PAYLOAD_HASH_MISMATCH",
        "TC11V0_MANIFEST_MISSING",
        "TC11V0_MANIFEST_HASH_MISMATCH",
        "TC11V0_CONFIG_HASH_MISMATCH",
        "TC11V0_CODE_IDENTITY_MISSING"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.765437",
        "modified": "2026-01-21T11:07:45.612838",
        "modified_days_ago": 30,
        "lines": 212,
        "size_bytes": 8920,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/program_canonicalization.py",
      "name": "program_canonicalization.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"get\", \"Punctuation tokens (punctu at all STripped (no spaces\n    \"whitespace\"  and known token\n    to canonical\n    (except in strings, even if surrounding\n    of a token a\n    Punctuation is\n    \"known\" characth\n    \"punctu at all\n    STAnd only\n    semantic tokens\n    \"punctuation\"\n    (if modified\n    by per token (no lemming whitespace\n    in semantically\n    ignore\n    key (not   to   semantic\n    meaning\n    (per lemming\n    key  (no semantically\n    Punct\n    \"  whitespace\"\n   ...",
      "classes": [
        "CanonicalizationMode"
      ],
      "functions": [
        "get_canonicalization_spec",
        "quantize_float",
        "dequantize_float",
        "canonicalize_operator_pattern",
        "canonicalize_entity_relation",
        "canonicalize_transformation_rule",
        "_canonicalize_generic_dict",
        "canonicalize_program_body",
        "compute_program_hash",
        "tokenize_canonical_program"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "typing"
      ],
      "constants": [
        "CANONICALIZATION_VERSION",
        "PUNCTUATION_HANDLING",
        "NON_SEMANTIC_TOKENS",
        "WHITESPACE_HANDLING",
        "CASE_HANDLING",
        "FLOAT_PRECISION",
        "FLOAT_SCALE"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.204942",
        "modified": "2026-01-22T07:53:46.499272",
        "modified_days_ago": 29,
        "lines": 614,
        "size_bytes": 21226,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "induction/promotion_blocker.py",
      "name": "promotion_blocker.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "PromotionBlockerV1: Content-Addressed Promotion Failure Artifacts.\n\nProvides structured, content-addressed failure artifacts for promotion\ndecisions. These blockers can be ingested by Stage K for audit trails.",
      "classes": [
        "PromotionBlockerCode",
        "PromotionBlockerV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "BLOCKER_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:32.001841",
        "modified": "2026-01-27T07:17:32.002154",
        "modified_days_ago": 24,
        "lines": 262,
        "size_bytes": 8622,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/promotion_decision.py",
      "name": "promotion_decision.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "PromotionDecisionRecord captures promotion event context referencing the certificate that enabled the promotion, including MDL scores and threshold checks. It is immutable and does not embed the certificate. Used for governance and auditing.",
      "classes": [
        "PromotionDecisionRecord"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-29T00:27:31.628509",
        "modified": "2026-01-22T07:53:46.499273",
        "modified_days_ago": 29,
        "lines": 149,
        "size_bytes": 5997,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/promotion_gate.py",
      "name": "promotion_gate.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "PromotionGateV1 validates promotions against governance contracts; PromotionGateV2 enforces fail-closed schema with mandatory v2 certificates. Missing or invalid fields fail promotion. Legacy mode only for migration.",
      "classes": [
        "PromotionGateResult",
        "PromotionGateV1",
        "PromotionGateError"
      ],
      "functions": [
        "validate_promotion_gate_v2",
        "validate_promotion_gate_v2_with_verifier",
        "validate_promotion_gate_v1_legacy"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-20T08:40:38.968549",
        "modified": "2026-01-22T07:53:46.443048",
        "modified_days_ago": 29,
        "lines": 496,
        "size_bytes": 17675,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/promotion_lane.py",
      "name": "promotion_lane.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Promotion Lane: Event-driven boundary for shadow store and promotion.\n\nHandles all persistence and promotion operations, keeping HypothesisLifecycleController\n\"pure-ish\" (reasons, doesn't persist).\n\nP0 Governance (A.1): Placeholder Hash Elimination\n    This module previously used placeholder hashes (sha256:0000...) for missing\n    sandbox reports.",
      "classes": [
        "RegressionFenceError",
        "FenceWitness",
        "PromotionLane"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.contracts.governance_status",
        "core.governance.run_intent",
        "core.governance.legacy_deprecation",
        "core.induction.promotion_lane_events",
        "core.operators.operator_ir_verifier",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:02:27.329805",
        "modified": "2026-01-25T20:02:27.329953",
        "modified_days_ago": 26,
        "lines": 1339,
        "size_bytes": 59948,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/promotion_lane_events.py",
      "name": "promotion_lane_events.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Promotion events drive the transition of operator sketches through validation, testing, and certification in the promotion lane. PromotionResult tracks status, receipt, reasons, and attempt details.",
      "classes": [
        "SketchProposed",
        "SketchTested",
        "EvidenceRecorded",
        "PromotionEligible",
        "PromotionAttempted",
        "PromotionSucceeded",
        "PromotionFailed",
        "PromotionResult"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:40:20.827726",
        "modified": "2026-01-24T23:40:20.827860",
        "modified_days_ago": 27,
        "lines": 158,
        "size_bytes": 5132,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/__init__.py",
      "name": "__init__.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Hypothesis Proposer Package.\n\nModularized implementation of hypothesis proposal strategies (BUD-IND-1).",
      "classes": [],
      "functions": [],
      "imports": [
        "base",
        "budget",
        "manager",
        "strategies.delta_generalization",
        "strategies.entity_relation",
        "strategies.operator_induction",
        "strategies.operator_sequence",
        "strategies.semantic_delta"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.765824",
        "modified": "2026-01-14T16:11:39.765922",
        "modified_days_ago": 37,
        "lines": 25,
        "size_bytes": 820,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/base.py",
      "name": "base.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Defines ProposalStrategy.",
      "classes": [
        "ProposalStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.765958",
        "modified": "2026-01-21T11:07:23.615319",
        "modified_days_ago": 30,
        "lines": 41,
        "size_bytes": 935,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/budget.py",
      "name": "budget.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Enforces proposal limits per episode for hypothesis induction. Tracks proposed hypotheses and time spent. Prevents overruns via max_hypotheses, max_time_seconds, and max_observations_per_hypothesis.",
      "classes": [
        "ProposalBudget"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.766086",
        "modified": "2026-01-14T16:11:39.766183",
        "modified_days_ago": 37,
        "lines": 37,
        "size_bytes": 1241,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/manager.py",
      "name": "manager.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "HypothesisProposer generates hypotheses from observations using configured strategies and enforces proposal budgets for controlled search.",
      "classes": [
        "HypothesisProposer"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "typing",
        "core.induction.hypothesis_build_failure"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.766222",
        "modified": "2026-01-21T11:21:45.565343",
        "modified_days_ago": 30,
        "lines": 247,
        "size_bytes": 9906,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/strategies/delta_generalization.py",
      "name": "delta_generalization.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Proposes hypotheses by generalizing state deltas. Finds patterns in observations and uses a proposal budget.",
      "classes": [
        "DeltaGeneralizationStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.205365",
        "modified": "2026-01-18T12:31:34.437433",
        "modified_days_ago": 33,
        "lines": 108,
        "size_bytes": 3633,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/strategies/entity_relation.py",
      "name": "entity_relation.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Defines EntityRelationStrategy.",
      "classes": [
        "EntityRelationStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.205558",
        "modified": "2026-01-18T12:31:29.301370",
        "modified_days_ago": 33,
        "lines": 80,
        "size_bytes": 2581,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/strategies/operator_induction.py",
      "name": "operator_induction.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "This strategy proposes operator sketches by analyzing delta observations. It follows the pipeline of deltas to clusters, then sketches, and finally hypotheses. Evidence fingerprints ensure proposal validity.",
      "classes": [
        "OperatorInductionStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "re",
        "collections",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.205767",
        "modified": "2026-01-18T12:31:34.437900",
        "modified_days_ago": 36,
        "lines": 331,
        "size_bytes": 14147,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/strategies/operator_sequence.py",
      "name": "operator_sequence.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Defines OperatorSequenceStrategy.",
      "classes": [
        "OperatorSequenceStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.206155",
        "modified": "2026-01-18T12:31:34.437420",
        "modified_days_ago": 33,
        "lines": 80,
        "size_bytes": 2806,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/proposer/strategies/semantic_delta.py",
      "name": "semantic_delta.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Proposes operator sketches from SemanticDeltaIRv0 observations using delta clustering. Generates hypotheses within the induction pipeline.",
      "classes": [
        "SemanticDeltaInductionStrategy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.206362",
        "modified": "2026-01-18T12:31:34.437451",
        "modified_days_ago": 33,
        "lines": 133,
        "size_bytes": 4920,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/reason_emitter.py",
      "name": "reason_emitter.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Turns measured facts into stable reason codes by extracting HypothesisFacts and ReasonSignalConfig data, ensuring policy is decoupled from the core logic. Emits deterministic reason codes from named signals, maintaining taxonomy stability and auditability.",
      "classes": [
        "HypothesisFacts",
        "ReasonSignalConfigV1",
        "ReasonSignalsV1",
        "ReasonCodeEmitterV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "SIGNAL_TO_REASON_CODE_V1"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T12:38:13.292198",
        "modified": "2026-01-22T07:53:46.454159",
        "modified_days_ago": 29,
        "lines": 316,
        "size_bytes": 10793,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/sandbox_report.py",
      "name": "sandbox_report.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "SandboxReport: Verifiable behavior artifact for operator sketch validation in the K4.0 promotion pipeline.",
      "classes": [
        "TestCaseResult",
        "AggregateStats",
        "SandboxReportCore",
        "SandboxReportMeta",
        "SandboxReport"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "datetime",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.767373",
        "modified": "2026-01-22T07:53:46.454255",
        "modified_days_ago": 29,
        "lines": 323,
        "size_bytes": 10677,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/sandbox_run_manifest.py",
      "name": "sandbox_run_manifest.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "SandboxRunManifest records environment pins to ensure replay determinism in the promotion pipeline.",
      "classes": [
        "SandboxRunManifest"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "platform",
        "sys",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:11:49.731740",
        "modified": "2026-01-22T07:53:46.454242",
        "modified_days_ago": 29,
        "lines": 124,
        "size_bytes": 3942,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/sandbox_runner.py",
      "name": "sandbox_runner.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "SandboxRunner executes operator sketches deterministically using StateSnapshot references. Test cases are built from StateNode with serialized input state. Results are ordered by test_ id and use deterministic replay boundaries.",
      "classes": [
        "TestCase",
        "SandboxRunner"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "os",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.682904",
        "modified": "2026-02-17T10:09:41.653522",
        "modified_days_ago": 3,
        "lines": 769,
        "size_bytes": 29965,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/sandbox_store.py",
      "name": "sandbox_store.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "SandboxReportStore stores SandboxReport artifacts using the ArtifactStore interface. It enables retrieval and maintains reference links for reports.",
      "classes": [
        "SandboxReportStore"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "core.induction.artifact_store",
        "core.induction.sandbox_report"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:08:37.746586",
        "modified": "2026-01-22T07:53:46.454110",
        "modified_days_ago": 29,
        "lines": 84,
        "size_bytes": 2216,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/scenario_suite.py",
      "name": "scenario_suite.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Scenario Suite configuration management for P1-5 induction. Suite config is written in YAML. \"\"\"\n\" is file content, no execute\n\"\"\" Suite config schema for \"\"\" 1. \"\"\"\n    \"\"\"Use case: \"\"\" for get_ executed \"\"\" (strict) \"\"\" and data \"\"\" test \"\"\" schema\n    \"\"\" defined.",
      "classes": [
        "SuiteConfigError",
        "ClaimCapability",
        "ThresholdType",
        "ClaimDirection",
        "ClaimTier",
        "ClaimApplicability",
        "CapabilityWitness",
        "PredeclaredClaimV1",
        "ScenarioConfigV1",
        "SuiteConfigV1",
        "OverfitMetricV1"
      ],
      "functions": [
        "_parse_scenario",
        "_parse_claim",
        "compute_config_hash",
        "load_suite_config",
        "save_suite_config"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing",
        "yaml",
        "core.governance.run_intent"
      ],
      "constants": [
        "SUITE_SCHEMA_VERSION",
        "KNOWN_CAPABILITIES",
        "VALID_THRESHOLD_TYPES",
        "VALID_DIRECTIONS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-28T19:43:30.915840",
        "modified": "2026-01-28T19:43:30.916043",
        "modified_days_ago": 23,
        "lines": 779,
        "size_bytes": 26594,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/scoped_k1_comparison.py",
      "name": "scoped_k1_comparison.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"Sterling\": \"Scoped K1 comparison enables discriminative evaluation of scopes (World, Task, Regime\n    divergence_test: str = \"\"\"\n    \"\"\"Return type:  (a test\n    ",
      "classes": [
        "ScopeType",
        "DivergenceType",
        "ScopeResult",
        "DivergenceResult",
        "DivergenceConfig",
        "ScopedK1ComparisonResult"
      ],
      "functions": [
        "detect_divergence",
        "compare_scoped_k1",
        "compare_task_scopes",
        "compare_world_scopes",
        "compare_regime_scopes"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.induction.k1_metrics",
        "core.worlds.base"
      ],
      "constants": [
        "DEFAULT_DIVERGENCE_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:41:16.625047",
        "modified": "2026-01-22T07:53:46.454354",
        "modified_days_ago": 29,
        "lines": 525,
        "size_bytes": 16903,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/scorecard_computation.py",
      "name": "scorecard_computation.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Computes HypothesisScorecardV1 from hypothesis, evidence, and test results. Ensures IND-SCORE-1 (transparency) and IND-DEC-2 (deterministic scoring).",
      "classes": [
        "HypothesisScorecardComputer"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "core.induction.hypothesis_scoring",
        "core.induction.reason_emitter"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:50:46.789404",
        "modified": "2026-01-22T07:53:46.492100",
        "modified_days_ago": 29,
        "lines": 652,
        "size_bytes": 25242,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/semantic_delta_observation_bridge.py",
      "name": "semantic_delta_observation_bridge.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"Converts SemanticDeltaIRv0 objects to ObservationIR for hypothesis lifecycle tracking. Enforces goal context with stable parameters and minimal payload.",
      "classes": [
        "GoalContextV0"
      ],
      "functions": [
        "compute_goal_params_checksum",
        "_normalize_goal_params",
        "_normalize_goal_param_value",
        "build_goal_context",
        "semantic_delta_to_observation",
        "semantic_deltas_to_observations",
        "enrich_observations_with_goal_context",
        "normalize_to_delta_observation",
        "normalize_observations_to_delta",
        "semantic_deltas_to_observations_by_episode"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [
        "SEMANTIC_DELTA_OBSERVATION_KIND"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T15:29:26.282645",
        "modified": "2026-01-21T11:21:45.542861",
        "modified_days_ago": 30,
        "lines": 641,
        "size_bytes": 25644,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/session_scoring.py",
      "name": "session_scoring.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Computes MDL costs as a pure function over session-level hypothesis, evidence, and test results. Enables Stage K to score proposals using accumulated cross-episode data without relying on controller state.",
      "classes": [],
      "functions": [
        "compute_session_mdl_costs",
        "compute_session_mdl_breakdowns",
        "compute_counterfactual_selection",
        "validate_weight_application"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T23:41:35.337486",
        "modified": "2026-01-21T11:07:45.600343",
        "modified_days_ago": 30,
        "lines": 387,
        "size_bytes": 15433,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/signature_separation.py",
      "name": "signature_separation.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Signature Separation Test: Diagnoses if structural signatures distinguish episode families. Computes Jaccard overlap and entropy. Runs K0 diagnostic (yellow) until tuned with known-good data. Author: @darianrosebrook.",
      "classes": [
        "SignatureSeparationResult"
      ],
      "functions": [
        "compute_entropy",
        "extract_deltas_from_episodes",
        "extract_family_label_from_episode",
        "test_signature_separation"
      ],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "typing",
        "core.induction.delta_clustering"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T11:36:48.285442",
        "modified": "2026-01-21T11:07:23.530145",
        "modified_days_ago": 30,
        "lines": 284,
        "size_bytes": 10360,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/sketch_compiler.py",
      "name": "sketch_compiler.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Sketch Compiler: Converts operator sketches to executable operators.\n\nSprint 2 Phase 5: Compiles certified OperatorSketchCoreIR into executable\noperator signatures that can be registered in the OperatorRegistry.\n\nThe compilation process:\n1. Validate sketch contracts (preconditions/effects)\n2. Generate precondition/effect functions from InferredClauses\n3.",
      "classes": [
        "CompilationResult",
        "SketchCompiler"
      ],
      "functions": [
        "compile_sketches_from_store"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T13:52:27.344638",
        "modified": "2026-01-23T19:24:43.921256",
        "modified_days_ago": 28,
        "lines": 492,
        "size_bytes": 15588,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/stage_k_report.py",
      "name": "stage_k_report.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"Generates a contract report for K1 metrics, fails closed due to unpopulated field\n    (optional): \"measured\"\n    # = \"unknown\"  # 1.",
      "classes": [
        "JsonifyStrictModeError",
        "ArtifactRef",
        "ProvenanceMetrics",
        "BudgetRegimeDescriptor",
        "K1SplitGateResult",
        "ScopedOverrideDecision",
        "K1ClaimsSummary",
        "K1OverrideGuardrails",
        "WeightApplicationValidation",
        "StrategyViability",
        "InductionViabilityResult",
        "MetricStatus",
        "MetricField",
        "GovernanceCheckField",
        "SignificanceTest",
        "PNSemanticMetrics",
        "StageKMetrics",
        "StageKReport"
      ],
      "functions": [
        "build_proposal_witness",
        "_jsonify",
        "evaluate_k1_split_gates",
        "compute_measurement_resolution_threshold",
        "interpret_k1_validity",
        "evaluate_override_guardrails",
        "compute_provenance_metrics",
        "assess_strategy_viability",
        "create_not_measured_field",
        "create_measured_field"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.governance.run_intent",
        "core.induction.nontriviality_gates"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:02:51.247875",
        "modified": "2026-01-25T20:02:51.247979",
        "modified_days_ago": 26,
        "lines": 4682,
        "size_bytes": 225860,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/state_snapshot.py",
      "name": "state_snapshot.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "StateSnapshot provides a content-addressed, hashable representation of a StateNode for deterministic sandbox testing.",
      "classes": [
        "StateSnapshot"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:07:17.882556",
        "modified": "2026-01-22T07:53:46.454621",
        "modified_days_ago": 29,
        "lines": 101,
        "size_bytes": 3235,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/synthesis_config.py",
      "name": "synthesis_config.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Determines operator identity via config_ hash from SynthesisConfigV1 fields. Ensures same config+sketch+engine yields same operator. Used in the promotion pipeline to prevent identical sketches from producing identical operators for different configs.",
      "classes": [
        "SynthesisConfigV1"
      ],
      "functions": [
        "compute_operator_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "SYNTHESIS_ENGINE_VERSION",
        "DEFAULT_CANONICALIZATION_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T10:00:31.155091",
        "modified": "2026-01-22T07:53:46.499323",
        "modified_days_ago": 29,
        "lines": 262,
        "size_bytes": 8821,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/synthesis_replay_check.py",
      "name": "synthesis_replay_check.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Synthesis Replay Check verifies that synthesized operators produce expected effects using fixture states and effect clauses. It runs promotion-time and install-time replay checks and records observable evidence or error details as a ReplayCheckResult.",
      "classes": [
        "ReplayCheckResult"
      ],
      "functions": [
        "build_pn_fixture_state",
        "run_promotion_time_replay_check",
        "_verify_effect_clauses",
        "run_install_time_replay_check",
        "run_full_replay_check"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-19T22:39:07.091851",
        "modified": "2026-01-22T07:53:46.443137",
        "modified_days_ago": 29,
        "lines": 464,
        "size_bytes": 15854,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/tc2_validator.py",
      "name": "tc2_validator.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "{\"description\":\"TC-2 feature admissibility classification and enforcement of Sterling's prior feature set using static registry and pattern matching. Verifies that operator inputs are purely from observed state, not goal. Removes any non-admissible features from priors. Reports violations with clear categorization. Ensures only admissible Sterling features in priors. Detects and sanitizes forbidden knowledge patterns. Enforces TC-2 via symbolic governance.",
      "classes": [
        "FeatureAdmissibility",
        "FeatureClassification",
        "TC2FeatureRegistry",
        "TC2ValidationResult",
        "TC2Validator"
      ],
      "functions": [
        "validate_prior_for_tc2"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T18:48:52.827714",
        "modified": "2026-01-22T07:53:46.504029",
        "modified_days_ago": 29,
        "lines": 387,
        "size_bytes": 15328,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/tier_gate_reason.py",
      "name": "tier_gate_reason.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Enforces tier gate failure reasoning. Normalizes and records failure codes for tier validation.",
      "classes": [
        "TierGateReasonCode"
      ],
      "functions": [],
      "imports": [
        "enum"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-25T14:48:47.160733",
        "modified": "2026-01-22T07:53:46.491233",
        "modified_days_ago": 29,
        "lines": 22,
        "size_bytes": 666,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "induction/validation_fixtures.py",
      "name": "validation_fixtures.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "Provides deterministic test fixtures for sandbox validation. Enables building fixtures from lifecycle states, golden corpus, or test stubs. Must return fixtures with a replay-manifest for verification.",
      "classes": [
        "ValidationFixtureProvider"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T22:31:56.127531",
        "modified": "2026-01-21T11:07:45.608561",
        "modified_days_ago": 30,
        "lines": 63,
        "size_bytes": 2136,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "induction/wordnet_rollout_scenario.py",
      "name": "wordnet_rollout_scenario.py",
      "category": "Operator learning, promotion pipeline, and hypothesis lifecycle",
      "status": "active",
      "description": "WordNetRolloutInductionScenario reuses DialogueRolloutInductionScenario infrastructure but filters for WordNet task family and verifies using WordNetWorldAdapter. Author: @darianrosebrook. Date: January 26.",
      "classes": [
        "WordNetScenarioConfig",
        "WordNetRolloutInductionScenario"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.induction.dialogue_rollout_scenario"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-06T13:33:07.910442",
        "modified": "2026-01-21T11:07:23.543635",
        "modified_days_ago": 30,
        "lines": 183,
        "size_bytes": 5816,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/__init__.py",
      "name": "__init__.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "Intent module for Sterling.\n\nProvides canonical intent taxonomy and classification infrastructure\nfor intent-aware reasoning and value estimation.",
      "classes": [],
      "functions": [
        "__getattr__"
      ],
      "imports": [
        "core.intent.classifier",
        "core.intent.model",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:20:57.573163",
        "modified": "2026-01-22T07:53:46.504534",
        "modified_days_ago": 29,
        "lines": 155,
        "size_bytes": 4526,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/classifier.py",
      "name": "classifier.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "IntentClassifier extracts soft features using weighted phrase and keyword patterns for intent scoring. Do not use for intent routing; pass features to Sterling's value function.",
      "classes": [
        "IntentFeatures",
        "IntentClassification",
        "IntentClassifier"
      ],
      "functions": [
        "get_intent_classifier",
        "get_intent_features",
        "classify_intent"
      ],
      "imports": [
        "__future__",
        "logging",
        "warnings",
        "dataclasses",
        "typing",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:20:57.573495",
        "modified": "2026-01-22T07:53:46.504562",
        "modified_days_ago": 29,
        "lines": 1268,
        "size_bytes": 44834,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/model.py",
      "name": "model.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "IntentModel module providing intent annotations and distributions for utterance and state-level prediction.",
      "classes": [
        "IntentSource",
        "IntentAnnotation",
        "StateIntentDistribution",
        "IntentTrainingExample"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:27:44.777962",
        "modified": "2026-01-22T07:53:46.504509",
        "modified_days_ago": 29,
        "lines": 330,
        "size_bytes": 11468,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/predictor.py",
      "name": "predictor.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "Predicts next intent from StateNode structural features using a 2-layer MLP; supports intent classification and hierarchical intent prediction. Trained with KG data and human-labeled intent labels. Fallback to JSON if PyTorch unavailable.",
      "classes": [
        "IntentPredictorConfig",
        "StateIntentPredictor"
      ],
      "functions": [
        "create_intent_predictor"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "numpy",
        "core.intent.model",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T19:07:25.790223",
        "modified": "2026-01-22T07:53:46.504615",
        "modified_days_ago": 29,
        "lines": 491,
        "size_bytes": 16274,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/refinement.py",
      "name": "refinement.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "Extracts linguistic features from TextIR to refine intent predictions at late stage.",
      "classes": [
        "RefinementConfig",
        "LinguisticFeatures",
        "IntentRefinementClassifier"
      ],
      "functions": [
        "extract_linguistic_features",
        "_safe_call",
        "create_refinement_classifier"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.intent.model",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T21:27:06.086085",
        "modified": "2026-01-22T07:53:46.504593",
        "modified_days_ago": 29,
        "lines": 437,
        "size_bytes": 15379,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/types.py",
      "name": "types.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "Maps operational vocabulary to IntentType via IntentFamily lookup. IntentFamily: operational intent routing. IntentType: specific analysis actions. Author: @darianrosebrook.",
      "classes": [
        "IntentFamily",
        "IntentType",
        "OperationType"
      ],
      "functions": [
        "get_intent_family",
        "get_family_intents",
        "map_operation_to_intent",
        "_resolve_branch_intent",
        "validate_intent_mapping"
      ],
      "imports": [
        "__future__",
        "enum",
        "typing",
        "typing"
      ],
      "constants": [
        "_BRANCH_SYNTHESIZE_HINTS",
        "_BRANCH_SCOPE_CHANGE_HINTS",
        "_BRANCH_SECTION_HINTS",
        "_BRANCH_REPEATABLE_INTENTS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:27:05.255371",
        "modified": "2026-01-23T18:12:01.413820",
        "modified_days_ago": 28,
        "lines": 424,
        "size_bytes": 15696,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "intent/value_head.py",
      "name": "value_head.py",
      "category": "Intent classification and prediction",
      "status": "active",
      "description": "IntentConditionedValueHead that conditions on intent, integrating with HybridValueFunction for intent-aware evaluation. Uses intent embedding from StateIntentPredictor or external annotation. Configurable dimensions and dropout as per model version.",
      "classes": [
        "IntentValueHeadConfig",
        "IntentConditionedValueHead"
      ],
      "functions": [
        "create_intent_value_head"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "numpy",
        "core.intent.types",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T19:08:48.457352",
        "modified": "2026-01-22T07:53:46.504480",
        "modified_days_ago": 29,
        "lines": 614,
        "size_bytes": 21106,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir/__init__.py",
      "name": "__init__.py",
      "category": "Intermediate representations (semantic, syntax, delta)",
      "status": "active",
      "description": "Sterling Intermediate Representations (IR) module.\n\nContains canonical data models for Sterling's semantic state representations:\n- SemanticDeltaIRv0: Domain-specific (PN/TextIR) representation of semantic mutations\n- Future: TextIR, PseudocodeIR, etc.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.ir.semantic_delta_ir"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-30T22:05:41.804720",
        "modified": "2026-01-22T07:53:46.507020",
        "modified_days_ago": 29,
        "lines": 52,
        "size_bytes": 1010,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir/cube_delta_ops.py",
      "name": "cube_delta_ops.py",
      "category": "Intermediate representations (semantic, syntax, delta)",
      "status": "active",
      "description": "{\"description\":\"Apply for cube moves: generates move (notations)\n    return: (BoW, cc cube poses a move as a \"U\" step. \n    (a int\n    (k faces the\n    op. A move\n    produces zero or\n    an i\n    goes to\n    step (new state m.  literal. A\n    op. 4. r\n    G (r permutations\n    (a, 6. u\nr. in\n    int\n    a\n    step\n    returns\n    the.  literal B\n    step;  literal\n    CUBr. 4.  literal\n    (a 1.2 step\n    (optional/s\n    step:  literal\n    for 2\n    each 2\n    form\n    each 3.  literal",
      "classes": [
        "ApplyMove",
        "SetSolved"
      ],
      "functions": [
        "cube_op_from_dict",
        "is_cube_op",
        "parse_cube_move",
        "compute_cube_operator_id",
        "get_inverse_move",
        "create_apply_move_op",
        "create_solved_op",
        "compute_cube_state_hash",
        "solution_to_ops",
        "get_schema_id_for_op"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "CUBE_DOMAIN_ID",
        "CUBE_SCHEMA_VERSION",
        "CUBE_OPERATOR_CATEGORY",
        "CUBE_MOVE_SCHEMA_ID",
        "CUBE_GOAL_SCHEMA_ID"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T17:29:10.434935",
        "modified": "2026-01-22T07:53:46.506986",
        "modified_days_ago": 29,
        "lines": 429,
        "size_bytes": 12004,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir/escape_delta_ops.py",
      "name": "escape_delta_ops.py",
      "category": "Intermediate representations (semantic, syntax, delta)",
      "status": "active",
      "description": "{\"description\":\"SetPiecePosition: Records a single piece move in EscapeGame domain.  \nSetBoardHash: Captures the board state hash before and after a move for verification.  \nSetGoalReached: Marks when the exit condition is satisfied in EscapeGame.  \n",
      "classes": [
        "SetPiecePosition",
        "SetBoardHash",
        "SetGoalReached"
      ],
      "functions": [
        "escape_op_from_dict",
        "is_escape_op",
        "compute_escape_semantic_patch_ops",
        "compute_escape_state_hash",
        "compute_escape_operator_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "ESCAPE_DOMAIN_ID",
        "ESCAPE_SCHEMA_VERSION",
        "ESCAPE_OPERATOR_CATEGORY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T02:41:34.926187",
        "modified": "2026-01-22T07:53:46.506979",
        "modified_days_ago": 29,
        "lines": 368,
        "size_bytes": 11738,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir/semantic_delta_apply.py",
      "name": "semantic_delta_apply.py",
      "category": "Intermediate representations (semantic, syntax, delta)",
      "status": "active",
      "description": "Semantic Delta Application: Pure function for applying SemanticDeltaIRv0 to StateNode.",
      "classes": [
        "VerificationMode",
        "DeltaApplicationError",
        "PreStateHashMismatch",
        "PostStateHashMismatch",
        "UnsupportedOpError",
        "ReplayVerificationError",
        "MintModeError",
        "DeltaApplicationResult"
      ],
      "functions": [
        "compute_semantic_hash",
        "_apply_flip_polarity",
        "_apply_set_enum",
        "_apply_single_op",
        "apply_semantic_delta"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "typing",
        "core.ir.semantic_delta_ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.579981",
        "modified": "2026-02-21T15:51:43.580121",
        "modified_days_ago": 0,
        "lines": 376,
        "size_bytes": 12031,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir/semantic_delta_ir.py",
      "name": "semantic_delta_ir.py",
      "category": "Intermediate representations (semantic, syntax, delta)",
      "status": "active",
      "description": "{\"description\":\"SemanticDelta representation of state changes. Isolated system.  Pre canonical data.  Schema, see\n  structurALI  m  e  wIt's model\n    t  e  t  e  t  e  t  e  t  a  t  e  t  e  r  e  t  h  e  r  e  t  S  e  t  e  t  e  t  e  t  a  s  e  t  e  m  e  t  a  s  e  t  e  d  e  t  e  m  l  e  t  a  s  e  v 0  e  s  t  e  t  e  a  n  t  e  t  e  t",
      "classes": [
        "WitnessKind",
        "Witness",
        "EnvironmentRefs",
        "SetEnum",
        "UpsertEntity",
        "RemoveEntity",
        "UpsertEvent",
        "RemoveEvent",
        "SetRole",
        "UnsetRole",
        "UnsetRoleEdge",
        "SetSurface",
        "AddHole",
        "RemoveHole",
        "AttachLabel",
        "DetachLabel",
        "FlipPolarityOp",
        "SemanticDeltaIRv0"
      ],
      "functions": [
        "semantic_patch_op_from_dict"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing",
        "core.operators.registry"
      ],
      "constants": [
        "SEMANTIC_DELTA_IR_SCHEMA_ID",
        "SEMANTIC_DELTA_IR_SCHEMA_VERSION",
        "CANONICALIZATION_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.374234",
        "modified": "2026-01-30T12:05:14.374376",
        "modified_days_ago": 21,
        "lines": 1166,
        "size_bytes": 42655,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir_extraction.py",
      "name": "ir_extraction.py",
      "category": "Core module",
      "status": "active",
      "description": "Extracts IR_ V1 structures from raw sentences via dependency parsing. Enables tool interface for sentence-level reasoning. Uses Stanza Parser Adapters.",
      "classes": [
        "_StanzaParserAdapter",
        "_StanzaDocAdapter",
        "_StanzaTokenAdapter"
      ],
      "functions": [
        "extract_ir_from_sentence",
        "get_all_copular_verbs",
        "_get_default_parser"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.id_registry",
        "core.ir_serialization"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-19T08:46:48.639475",
        "modified": "2026-01-22T07:53:46.006771",
        "modified_days_ago": 29,
        "lines": 303,
        "size_bytes": 9013,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "ir_serialization.py",
      "name": "ir_serialization.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\": \"IR (Intermediate Representation) serialization utilities for Sterling Light. Provides token and sentence-level schema with versioning for stability and change tracking. IR_V1 includes basic token info plus syntax tree structure. IR_V1 token lists. Includes nsubj, aux, det, mark, root. \nToken and syntax trees from dependencies. IR token and syntax\n  includes content, position\nReturn ir as dict and JSON LDF for compatibility. \n  returns tree with core.",
      "classes": [
        "IRToken",
        "IR_V1",
        "IRTokenDict",
        "IRDict_V1"
      ],
      "functions": [
        "ir_to_dict",
        "ir_from_dict",
        "serialize_ir",
        "deserialize_ir",
        "ir_equal",
        "_self_test_round_trip"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413110",
        "modified": "2026-01-22T07:53:46.007235",
        "modified_days_ago": 29,
        "lines": 324,
        "size_bytes": 9830,
        "author": "@darianrosebrook",
        "has_main": true
      }
    },
    {
      "path": "kernels/__init__.py",
      "name": "__init__.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Sterling Kernel Abstraction Layer.\n\nKernels provide domain-specific affordances (neighbors, masks, goal detection)\nwithout becoming the sole proposer or mutator. Core proposes via OperatorRegistry;\nkernels provide domain hints.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.kernels.gridworld",
        "core.kernels.kv_store",
        "core.kernels.mastermind",
        "core.kernels.pn",
        "core.kernels.poisoned_curriculum",
        "core.kernels.protocol",
        "core.kernels.wordnet"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T04:44:43.520433",
        "modified": "2026-02-15T04:44:43.520644",
        "modified_days_ago": 5,
        "lines": 39,
        "size_bytes": 1081,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/discourse.py",
      "name": "discourse.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Discourse kernel for operator argument proposal.\n\nProvides minimal neighbor/argument generation for discourse operators so\ninstrumented search can progress without manual task scripts.",
      "classes": [
        "DiscourseKernel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.kernels.protocol",
        "core.worlds.discourse",
        "core.worlds.discourse.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.580462",
        "modified": "2026-02-21T15:51:43.580592",
        "modified_days_ago": 0,
        "lines": 609,
        "size_bytes": 27274,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "kernels/generic.py",
      "name": "generic.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Generic registry-backed kernel.\n\nProvides minimal affordances by delegating applicability to OperatorRegistry.",
      "classes": [
        "RegistryKernel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.kernels.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.581263",
        "modified": "2026-02-21T15:51:43.581359",
        "modified_days_ago": 0,
        "lines": 78,
        "size_bytes": 2750,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "kernels/gridworld.py",
      "name": "gridworld.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "{\"description\":\"Sterling Slippery Gridworld Kernel that provides stochastic movement affordances, allowing each agent to slip probabilistically when moving. Gridworld, agent (position, goal, walls). A* environment for a gridworld agent. A gridworld state, simplify. A gridworld state, move stack. Grid steps on the state. Grid status.  Grid token.  Grid  (D x,y) tokens.  Grid  (set of  (P,per yaction.  Grid  (success, failure, states.  Grid (or  go  stochast for each  choice in a  gridworld.",
      "classes": [
        "GridworldConfig",
        "GridworldState",
        "GridworldKernel"
      ],
      "functions": [
        "_derive_step_rng",
        "_resolve_effective_direction",
        "_apply_move"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "struct",
        "dataclasses",
        "typing",
        "core.kernels.protocol",
        "core.state_model"
      ],
      "constants": [
        "DIRECTIONS",
        "GRIDWORLD_OPERATOR_MOVE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T03:50:33.959607",
        "modified": "2026-02-08T03:50:33.959753",
        "modified_days_ago": 12,
        "lines": 382,
        "size_bytes": 12071,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/kv_store.py",
      "name": "kv_store.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Return null (no-op\n    return\n    (is\n    return\n    (is\n    return\n    \"\"\"\n    (when\n    (return\n    None (return\n    \"get\"    (return\n    \"state_\"    return\n    null (return\n    no-atomic with\n    return\n    \"is\"    return\n    \"is\" atomic commit\n    returns\n    a\n    \"is\" a\n    return\n    \"M\"    return\n    null\n    return\n    \"fence\"\n    return\n    \"M\"    return\n    null\n    return\n    \"M\"    return\n    null\n    return",
      "classes": [
        "JournalEntry",
        "TxnRecord",
        "KVStoreState",
        "KVStoreConfig",
        "KVStoreKernel"
      ],
      "functions": [
        "_kv_map_hash",
        "_journal_digest",
        "_journal_entry_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json",
        "core.kernels.protocol",
        "core.state_model"
      ],
      "constants": [
        "OP_BEGIN",
        "OP_PUT",
        "OP_DELETE",
        "OP_COMMIT",
        "OP_ABORT",
        "ALL_OPERATORS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T01:44:00.908380",
        "modified": "2026-02-15T01:44:00.908516",
        "modified_days_ago": 5,
        "lines": 673,
        "size_bytes": 22607,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/mastermind.py",
      "name": "mastermind.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "{\"description\":\"Sterling Mastermind kernel for code-breaking. Uses bitset belief model to track possible codes. 1 (1 of (bit- 0 (pruning) @ 1. 1 search. 2 for 1 candidate 0 and 1 (max, 1-1 guess. 2 outcome graph.",
      "classes": [
        "MastermindGuessRecord",
        "MastermindGameState",
        "MastermindKernelConfig",
        "MastermindKernel"
      ],
      "functions": [
        "enumerate_codes",
        "code_to_index",
        "index_to_code",
        "compute_feedback",
        "full_belief",
        "belief_size",
        "belief_hash",
        "belief_to_codes",
        "prune_belief",
        "partition_score"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "itertools",
        "logging",
        "dataclasses",
        "typing",
        "core.kernels.protocol",
        "core.state_model"
      ],
      "constants": [
        "MASTERMIND_OPERATOR_APPLY_GUESS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T03:49:04.331964",
        "modified": "2026-02-08T03:49:04.332088",
        "modified_days_ago": 12,
        "lines": 753,
        "size_bytes": 24917,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/pn.py",
      "name": "pn.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Sterling Predicate Nominal (PN) Kernel.\n\nProvides domain affordances for PN transformation tasks without owning\nmutation or proposal. Co-equal with WordNetKernel to shape core abstractions\n(identity representation, provenance schema, scope/polarity invariants).",
      "classes": [
        "PNKernel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.kernels.protocol",
        "core.state_model"
      ],
      "constants": [
        "PN_OPERATORS",
        "PN_TASK_TYPES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.581799",
        "modified": "2026-02-21T15:51:43.581957",
        "modified_days_ago": 0,
        "lines": 988,
        "size_bytes": 36219,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/poisoned_curriculum.py",
      "name": "poisoned_curriculum.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "```json\n{\n    \"arbitrary\"  outputs\n    \"validation\"\n    \"quarantine\"\n    \"detection\"  and  \"rejection\" with structured\n    metadata and  \"only\"  and\n    \"arbitrary\"  and  \"only\"  and  \"validation\"\n    mode,  \"arithmetic\"  and  \"emitting\"  \"arbitrary\"  and  \"rejection\"  and  \"only\"  and  \"evidence\"  and  \"exhaustive\"  and  \"unverified\"  and  \"rejection\"  and  \"witness\"  and  \"arbitrary\"  and  \"evidence\"  and  \"validation\"  and  \"arbitrary\"  and  \"Kernel\"  and  \"evidence\"  and  \"arbitrary",
      "classes": [
        "CurriculumExample",
        "HypothesisUpdate",
        "ValidationResult",
        "JournalEntry",
        "PoisonedCurriculumState",
        "PoisonedCurriculumConfig",
        "PoisonedCurriculumKernel"
      ],
      "functions": [
        "_registry_hash",
        "_quarantine_hash",
        "_journal_digest",
        "_journal_entry_digest",
        "_update_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json",
        "core.kernels.protocol",
        "core.state_model"
      ],
      "constants": [
        "OP_INGEST",
        "OP_PROPOSE",
        "OP_VALIDATE",
        "OP_PROMOTE",
        "OP_QUARANTINE",
        "OP_REVOKE",
        "ALL_OPERATORS",
        "TRANSCRIPTED_OPERATORS",
        "EPOCH_MUTATING_OPERATORS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T04:04:40.118479",
        "modified": "2026-02-15T04:04:40.118615",
        "modified_days_ago": 5,
        "lines": 1049,
        "size_bytes": 36781,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/protocol.py",
      "name": "protocol.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Kernel provides domain-specific hints (neighbors, masks, goal detection) via KernelProtocol but does not perform mutation or proposal. Kernels emit KernelEdit observations; full mutation is handled by Transactional_Apply wrapper per TD-6 architecture.",
      "classes": [
        "GoalResult",
        "KernelEdit",
        "KernelTransition",
        "KernelCapabilities",
        "Kernel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T16:49:01.460644",
        "modified": "2026-02-16T16:49:01.460979",
        "modified_days_ago": 4,
        "lines": 412,
        "size_bytes": 13738,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kernels/wordnet.py",
      "name": "wordnet.py",
      "category": "Domain-specific reasoning kernels",
      "status": "active",
      "description": "Sterling WordNet Kernel.\n\nProvides domain affordances for WordNet KG navigation without owning\nmutation or proposal. Wraps the existing WordNetEnv as a neighbor/mask\nprovider only.",
      "classes": [
        "WordNetKernel"
      ],
      "functions": [
        "get_cached_kernel",
        "cache_kernel",
        "clear_kernel_cache"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.kernels.protocol",
        "core.kg.registry",
        "core.reasoning.step_record",
        "core.state_model"
      ],
      "constants": [
        "WORDNET_KG_SCHEMA_ID",
        "WORDNET_KG_SCHEMA_VERSION",
        "WORDNET_OPERATORS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.582339",
        "modified": "2026-02-21T15:51:43.582477",
        "modified_days_ago": 0,
        "lines": 955,
        "size_bytes": 33141,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kg/__init__.py",
      "name": "__init__.py",
      "category": "Knowledge graph integration and registry",
      "status": "active",
      "description": "Sterling Knowledge Graph types and utilities.\n\nThis module provides:\n- Core KG types with optional external sense linking (thin sense bridge strategy)\n- KG Registry for managing KG ownership outside of per-state objects\n- KGRef for stable content-based identity\n\n@author: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.kg.exceptions",
        "core.kg.registry",
        "core.kg.types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-03T16:41:48.749790",
        "modified": "2026-01-22T07:53:46.530307",
        "modified_days_ago": 29,
        "lines": 71,
        "size_bytes": 1497,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kg/exceptions.py",
      "name": "exceptions.py",
      "category": "Knowledge graph integration and registry",
      "status": "active",
      "description": "Defines exceptions for KG registry operations to enforce fail-closed behavior at execution boundaries.",
      "classes": [
        "KGRegistryError",
        "KGNotRegisteredError",
        "KGHashMismatchError",
        "KGAlreadyRegisteredError"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.093926",
        "modified": "2026-01-22T07:53:46.530283",
        "modified_days_ago": 29,
        "lines": 110,
        "size_bytes": 2899,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kg/registry.py",
      "name": "registry.py",
      "category": "Knowledge graph integration and registry",
      "status": "active",
      "description": "{\"description\": \"KGMutability: provides a hash-based, context-aware reference identity for Knowledge Graphs. content hash (sha256) not stored in ref; object hash. hash from string representation. \n    @class schema id, generated by serializing to bytes. \n    (not stored as in object, kept in file. \n    paxiom. \n    a hash(256,...) by serializing dets. \n    tive to check (dev) th. \n    eX\n    r: (if not valid, raise V. \n    at per. \n    r: (dev) eXtive to get. \n    t: teed by (r, th.",
      "classes": [
        "KGMutability",
        "KGRef",
        "KGRegistration",
        "KGRegistry"
      ],
      "functions": [
        "compute_content_hash_from_bytes",
        "compute_content_hash_from_file",
        "get_registry",
        "register_kg",
        "get_kg",
        "get_kg_or_raise"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "threading",
        "contextlib",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.094002",
        "modified": "2026-01-22T07:53:46.530315",
        "modified_days_ago": 29,
        "lines": 547,
        "size_bytes": 18159,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kg/schemas.py",
      "name": "schemas.py",
      "category": "Knowledge graph integration and registry",
      "status": "active",
      "description": "get_schema_for_...  \ndef ...  \nschema_...  \ndef ...  \nof ...  \nclass Person ...  \ndef ...  \nclass Organization ...  \ndef ...  \n@type ...  \ndef ...  \ndef ...  \nclass ...  \ndef ...  \ndef ...  \ndef ...  \ndef ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \ndef ...  \nclass ...  \nclass ...  \nclass ...  \ndef ...  \nclass ...  \nclass ...  \ndef ...  \nclass ...",
      "classes": [
        "PropertyType",
        "ClaimType",
        "PropertySpec",
        "ClaimPattern",
        "ClaimMatch",
        "EntitySchema",
        "PersonSchema",
        "OrganizationSchema",
        "SoftwareSchema",
        "ProgrammingLanguageSchema",
        "PolicyTierSchema",
        "ConceptSchema"
      ],
      "functions": [
        "get_schema_for_entity",
        "get_all_schemas"
      ],
      "imports": [
        "__future__",
        "re",
        "abc",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T08:23:47.434118",
        "modified": "2026-01-22T07:53:46.530873",
        "modified_days_ago": 29,
        "lines": 905,
        "size_bytes": 28519,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "kg/types.py",
      "name": "types.py",
      "category": "Knowledge graph integration and registry",
      "status": "active",
      "description": "Defines KG entity and path types with optional external sense bridge to WordNet/Wikidata. Bridges are explicit, human-readable labels and confidence scores. Schema supports future sense bridging experiments.",
      "classes": [
        "KnowledgeBase",
        "ExternalSense",
        "WordNetPathSupport",
        "WikidataStatementSupport",
        "ExternalSupport",
        "Entity",
        "Relation",
        "TruthKG"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-03T16:42:32.973869",
        "modified": "2026-01-22T07:53:46.531100",
        "modified_days_ago": 29,
        "lines": 387,
        "size_bytes": 12821,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/__init__.py",
      "name": "__init__.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "Sterling LabelSpace: Canonical Label Layer.\n\nThis package provides the shared vocabulary that all Sterling layers and worlds\nproject into.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.labels.claim_adapter",
        "core.labels.jsonld_integration",
        "core.labels.landmarks",
        "core.labels.pseudocode_adapter",
        "core.labels.registry",
        "core.labels.text_adapter",
        "core.labels.types",
        "core.labels.wordnet_mapping"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T14:55:08.324577",
        "modified": "2026-01-22T07:53:46.529512",
        "modified_days_ago": 29,
        "lines": 185,
        "size_bytes": 4588,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/claim_adapter.py",
      "name": "claim_adapter.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "Sterling LabelSpace: ClaimWorld Adapter.\n\nThis module provides integration between LabelSpace and ClaimWorld.\nIt bridges the existing ClaimIR with the canonical label layer.\n\nKey Functions:\n- Annotate ClaimIR with LabelSpace labels\n- Convert ClaimIR property IRIs to PropertyIDs\n- Attach landmark information to claims\n- Generate label-aware features for value head\n\nAuthor: @darianrosebrook",
      "classes": [
        "ClaimAnnotation",
        "ClaimAnnotator",
        "LabelFeatures"
      ],
      "functions": [
        "extract_label_features",
        "enhance_verdict_with_labels",
        "get_claim_annotator",
        "annotate_claim"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.jsonld_integration",
        "core.labels.landmarks",
        "core.labels.registry",
        "core.labels.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T15:03:52.337844",
        "modified": "2026-01-22T07:53:46.529480",
        "modified_days_ago": 29,
        "lines": 392,
        "size_bytes": 12172,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/jsonld_integration.py",
      "name": "jsonld_integration.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "It converts LabelSpace annotations to JSON-LD format\nIt ensures type/property consistency across Label and JSON-LD graphs\"}",
      "classes": [
        "JsonLdNode"
      ],
      "functions": [
        "generate_jsonld_context",
        "merge_contexts",
        "extract_nodes_from_jsonld",
        "annotate_from_jsonld",
        "annotate_jsonld_document",
        "property_iri_to_label",
        "entity_type_iri_to_label",
        "annotation_to_jsonld",
        "is_context_compatible",
        "get_claim_context"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.registry",
        "core.labels.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T15:00:56.549099",
        "modified": "2026-01-22T07:53:46.529675",
        "modified_days_ago": 29,
        "lines": 505,
        "size_bytes": 14264,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/landmarks.py",
      "name": "landmarks.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "Sterling recognizes landmark patterns in Semantic IR and applies special operators when a Landmark is detected.",
      "classes": [
        "LandmarkKind",
        "LandmarkPattern",
        "LandmarkMatch",
        "LandmarkDetector"
      ],
      "functions": [
        "create_landmark_detector"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.labels.types"
      ],
      "constants": [
        "TESTING_DEFECT_LANDMARK",
        "TIER_LIMITS_LANDMARK",
        "CEO_ORGANIZATION_LANDMARK",
        "SOFTWARE_COMPONENT_LANDMARK"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T14:58:59.807067",
        "modified": "2026-01-22T07:53:46.529509",
        "modified_days_ago": 29,
        "lines": 483,
        "size_bytes": 15834,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/pseudocode_adapter.py",
      "name": "pseudocode_adapter.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "PseudocodeIR node types mapped to LabelSpace entity IDs. Feature extraction for value head. L.4 integration enabled.",
      "classes": [
        "PseudocodeLabelFeatures",
        "PseudocodeLabelAdapter"
      ],
      "functions": [
        "get_default_pseudocode_adapter",
        "annotate_pseudocode_program",
        "get_pseudocode_features"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.labels.registry",
        "core.labels.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T15:36:20.904946",
        "modified": "2026-01-22T07:53:46.529789",
        "modified_days_ago": 29,
        "lines": 711,
        "size_bytes": 24858,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/registry.py",
      "name": "registry.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "Central registry for label definitions; supports registration with aliases, lookup by IRI or alias, mapping from external sources (WordNet, JSON-LD), and namespace management.",
      "classes": [
        "LabelEntry",
        "LabelRegistry"
      ],
      "functions": [
        "get_default_registry"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T14:58:05.352136",
        "modified": "2026-01-22T07:53:46.529521",
        "modified_days_ago": 29,
        "lines": 959,
        "size_bytes": 29585,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/text_adapter.py",
      "name": "text_adapter.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "{\"description\":\"TextLabelAdapter that maps Text IR entities and events to LabelSpace IDs, enabling entity type normalization, sense grounding, and role standardization via LabelSpace IDs. Provides semantic features from Text IR for value heads. Uses LandmarkDetector for initial entity detection, then routes to LabelSpace via a provided mappings.  \n",
      "classes": [
        "TextLabelFeatures",
        "TextLabelAdapter"
      ],
      "functions": [
        "get_text_label_adapter",
        "resolve_entity_type",
        "resolve_semantic_role",
        "ground_entity_to_concept"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.landmarks",
        "core.labels.registry",
        "core.labels.types",
        "core.labels.wordnet_mapping"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T15:22:55.126870",
        "modified": "2026-01-22T07:53:46.529465",
        "modified_days_ago": 29,
        "lines": 604,
        "size_bytes": 19892,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/types.py",
      "name": "types.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "{\"@namespace\": \"http://www.w3.org/2004.ontology# and annotations\n\"\"\"This is the main type\n\"\"\" @dataclass\n\"\"\"  # data\n\"\"\"  #  (D)\n\"\"\"  #  (A T  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs)\n\"\"\"  (rdfs0 (mbox)\n\"\"\"  (mbox, mbox,  mbox\"\"\"\n\"\"\"  (mbox)\n\"\"\"  (mbox,  (mbox)\n\"\"\"  (mbox)\n\"\"\" (mbox)\n\"\"\"  (mbox)\n\"\"\"  (mbox)\n\"\"\"  (mbox)\n\"\"\"  (mbox)\n\"\"\"  (mbox)\n\"\"\"  (mbox)\n",
      "classes": [
        "LabelKind",
        "LabelID",
        "ConceptID",
        "EntityTypeID",
        "PropertyID",
        "RelationID",
        "OperationID",
        "IntentID",
        "LabelPath",
        "LabelAnnotation"
      ],
      "functions": [
        "expand_iri",
        "compact_iri"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413215",
        "modified": "2026-01-22T07:53:46.529632",
        "modified_days_ago": 29,
        "lines": 580,
        "size_bytes": 17570,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "labels/wordnet_mapping.py",
      "name": "wordnet_mapping.py",
      "category": "Label spaces and adapters",
      "status": "active",
      "description": "Sterling LabelSpace: WordNet Synset to ConceptID Mapping.\n\nThis module provides the mapping layer between WordNet synsets and\nSterling's LabelSpace. WordNet becomes one projection mechanism into\nthe canonical label vocabulary.",
      "classes": [
        "SynsetInfo",
        "SynsetMapping",
        "WordNetMapper"
      ],
      "functions": [
        "get_default_wordnet_mapper",
        "wordnet_relation_to_label"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T15:00:09.014268",
        "modified": "2026-01-22T07:53:46.529483",
        "modified_days_ago": 29,
        "lines": 625,
        "size_bytes": 19449,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "lexicon/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "core.lexicon \u2014 governed lexicon snapshot artifacts.\n\nProvides LexiconSnapshotV1, a content-addressed, domain-neutral lexicon\nartifact with three-hash identity (bytes closure, compat with gloss,\nidentity without gloss) and fail-closed query semantics.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "ref",
        "results",
        "snapshot"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.090525",
        "modified": "2026-02-20T08:48:06.090682",
        "modified_days_ago": 0,
        "lines": 35,
        "size_bytes": 869,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "lexicon/ref.py",
      "name": "ref.py",
      "category": "Core module",
      "status": "active",
      "description": "LexiconRef provides a content-addressable reference to lexicon snapshots using (schema_ id, schema_ version, content_ hash). Logical_ name is for human readability and is not part of the identity.",
      "classes": [
        "LexiconRef"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.090724",
        "modified": "2026-02-20T08:48:06.090863",
        "modified_days_ago": 0,
        "lines": 75,
        "size_bytes": 2543,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "lexicon/results.py",
      "name": "results.py",
      "category": "Core module",
      "status": "active",
      "description": "Returns lookup result types for lexicon snapshot queries. Fail-closed semantics: missing mappings return explicit results with fallbacks. Ambiguous lookups return all candidates in deterministic order.",
      "classes": [
        "LookupStatus",
        "Lexicalization",
        "LookupResult"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.090903",
        "modified": "2026-02-20T08:48:06.091148",
        "modified_days_ago": 0,
        "lines": 54,
        "size_bytes": 1414,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "lexicon/snapshot.py",
      "name": "snapshot.py",
      "category": "Core module",
      "status": "active",
      "description": "LexiconEntryV1: surface form, POS tag, concept reference (namespace, id), gloss. NormalizationPolicyV1 applies surface and concept normalization. Each entry is a content-addressed unit of meaning. Three digest types: content (withgloss), compatible (withlegacy), identity (no gloss).",
      "classes": [
        "NormalizationPolicyV1",
        "LexiconEntryV1",
        "LexiconSnapshotV1"
      ],
      "functions": [
        "_none_to_empty",
        "_compat_sort_key",
        "_identity_sort_key",
        "_compute_compat_hash",
        "_compute_identity_hash",
        "compute_legacy_synset_hash",
        "entries_from_synset_dict",
        "load_lexicon_snapshot"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "collections",
        "dataclasses",
        "pathlib",
        "typing",
        "core.verification.hash_utils",
        "ref",
        "results"
      ],
      "constants": [
        "_COMPAT_DOMAIN",
        "_IDENTITY_DOMAIN",
        "_LEGACY_SYNSET_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.091187",
        "modified": "2026-02-20T08:48:06.091355",
        "modified_days_ago": 0,
        "lines": 415,
        "size_bytes": 14183,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Sterling linguistics module.\n\nProvides operators, state representations, contracts, and utilities for\nlinguistic generation.\n\nSINGLE SOURCE OF TRUTH for all linguistic generation contracts:\n- Schema versions\n- Violation types\n- Operator registry\n- Checksum utilities\n- ID generation\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.contracts",
        "core.linguistics.operators"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.374721",
        "modified": "2026-01-30T12:05:14.375085",
        "modified_days_ago": 21,
        "lines": 83,
        "size_bytes": 1947,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/contracts.py",
      "name": "contracts.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Sterling linguistic generation contracts - SINGLE SOURCE OF TRUTH.\n\nThis module defines all contracts that must be shared across:\n- Generators (trace, pairs, negatives)\n- Lint gate\n- Runtime validation\n\nNO DUPLICATED STRINGS. All schema versions, violation types, and field\nnames must be imported from this module.\n\nAuthor: @darianrosebrook",
      "classes": [
        "SchemaVersion",
        "ViolationType",
        "TrainingReadinessResult"
      ],
      "functions": [
        "validate_schema_version",
        "validate_violation_type",
        "is_debug_field",
        "check_leakage_key",
        "compute_stable_checksum",
        "is_stable_checksum",
        "generate_deterministic_id",
        "check_training_ready",
        "get_nested_field",
        "has_nested_field"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.375294",
        "modified": "2026-01-30T12:05:14.375482",
        "modified_days_ago": 21,
        "lines": 306,
        "size_bytes": 8937,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/expand_by_digest_v1.py",
      "name": "expand_by_digest_v1.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Materializes committed IR dict to LeafPlanStepV1 steps deterministically, extracting only from committed IR. Bypasses TS intent resolver for 'explore', 'navigate', 'gather' lemmas, emitting executor-native leaves with explicit arguments to preserve Sterling semantics.",
      "classes": [],
      "functions": [
        "_canonical_json",
        "_sha256_hex",
        "_extract_theme_from_ir",
        "_lower_explore",
        "_lower_navigate",
        "_lower_gather",
        "materialize_steps_from_ir"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "typing"
      ],
      "constants": [
        "_TASK_TYPE_MAP",
        "BOOTSTRAP_LOWERING_SCHEMA_VERSION",
        "_BOOTSTRAP_LOWERING_LEMMAS",
        "_BOOTSTRAP_LOWERING_FNS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-14T15:12:56.294350",
        "modified": "2026-02-17T10:09:42.461375",
        "modified_days_ago": 3,
        "lines": 334,
        "size_bytes": 12548,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "linguistics/holes_policy.py",
      "name": "holes_policy.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"Holes_PRESENT in the input: fail- closed due to the analysis\n    of input\n    cannot make claims. Claim_ span must\n    be present\n    ",
      "classes": [
        "MeasurementStatus",
        "THole",
        "HolesPolicyResult",
        "HolesPolicy",
        "HolesPolicyViolation"
      ],
      "functions": [
        "compute_holes_digest",
        "merge_overlapping_holes",
        "validate_holes_for_certifying",
        "from_text_ir_hole",
        "to_text_ir_hole",
        "convert_holes_list_from_text_ir",
        "convert_holes_list_to_text_ir"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.375597",
        "modified": "2026-01-30T12:05:14.375728",
        "modified_days_ago": 21,
        "lines": 628,
        "size_bytes": 20798,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/intake/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "H3.1 Linguistic Intake Pipeline.\n\nProvides deterministic text-to-IR parsing with content-addressed artifacts.\n\nModules:\n- pipeline: Main intake orchestrator\n- parser: Deterministic parser wrapper\n- canonicalization: Canonical JSON rules\n- digest: Stable digest computation\n\nAuthor: @darianrosebrook\nDate: January 2026",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.intake.pipeline"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.375844",
        "modified": "2026-01-30T12:05:14.375942",
        "modified_days_ago": 21,
        "lines": 26,
        "size_bytes": 533,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/intake/pipeline.py",
      "name": "pipeline.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"Deterministic intake parser for the input text. Implements content- addressable parser for the input syntax. Token 1 r_ \u8bed\u6cd5\n    # 4. \u8bed\u6cd5\n    # 5. Canonicalize 6_input. \u8bed\u6cd5\n    # 1. \u8bed\u6cd5\n    # 2. \u8bed\u6cd5\n    # 4. \u8bed\u6cd5\n    # 5. \u8bed\u6cd5\n    # 6. Token2_ \u8bed\u6cd5\n    # 1. \u8bed\u6cd5\n    # 4. \u8bed\u6cd5\n    # 5. \u8bed\n    # 6. \u8bed\u6cd5\n    # 1. \u8bed\u6cd5\n    # 2. \u8bed\u6cd5\n    # 3. \u8bed\u6cd5\n    # 4. \u8bed\u6cd5\n    # 5",
      "classes": [
        "IntakePipelineConfig",
        "IntakePipeline"
      ],
      "functions": [
        "_normalize_apostrophes",
        "_expand_contractions",
        "_resolve_expand_contractions",
        "parse_text_to_ir"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "re",
        "dataclasses",
        "typing",
        "core.linguistics.holes_policy",
        "core.linguistics.parser_trust",
        "core.text.intake_ir",
        "core.text.ir"
      ],
      "constants": [
        "_CONTRACTION_PATTERN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T10:19:39.742658",
        "modified": "2026-02-18T10:19:39.743032",
        "modified_days_ago": 2,
        "lines": 728,
        "size_bytes": 25635,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/intake/policy_fingerprint.py",
      "name": "policy_fingerprint.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"Computes a content-verified hash of the parser configuration. Domain- separated to prevent cross- artifact contamination\n",
      "classes": [
        "ParserPolicyFingerprintV1"
      ],
      "functions": [
        "compute_parser_policy_fingerprint"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T17:32:22.114024",
        "modified": "2026-02-17T17:32:22.114397",
        "modified_days_ago": 3,
        "lines": 89,
        "size_bytes": 3309,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/io_envelope_v1.py",
      "name": "io_envelope_v1.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "It defines a structured input envelope for LLM output sent to Sterling: LanguageIOEnvelopeV1 carries raw and sanitized text with metadata (SanitizationFlags) describing transforms applied. TypeScript must NOT interpret these fields semantically.",
      "classes": [
        "SanitizationFlags",
        "DeclaredMarker",
        "WorldSnapshotRef",
        "LanguageIOEnvelopeV1"
      ],
      "functions": [
        "validate_envelope"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "time",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "LANGUAGE_IO_ENVELOPE_SCHEMA_ID",
        "LANGUAGE_IO_ENVELOPE_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-03T17:47:30.707821",
        "modified": "2026-02-03T17:47:30.708035",
        "modified_days_ago": 17,
        "lines": 354,
        "size_bytes": 13315,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Linguistic IR v0 \u2014 four-partition typed intermediate representation.\n\nPartitions:\n- Surface: Document, Segment, Token, Mention\n- Structure: Syntax (observational, from core.text.ir)\n- Committed: EntityRef, Predicate, Proposition, ScopeOperator, DiscourseLink, Attribution, ValueNode\n- Frontier: Hypothesis, Candidate, PromotionRecord\n\nSchema: sterling.linguistic_ir.v0 (version 0.0.1)",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.context_ref",
        "core.linguistics.ir_v0.episode_trace",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.meaning_state",
        "core.linguistics.ir_v0.myelin_sheath",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:00:47.097784",
        "modified": "2026-01-30T12:02:30.576821",
        "modified_days_ago": 21,
        "lines": 185,
        "size_bytes": 4053,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/budget.py",
      "name": "budget.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "WSBudget enforces materialization limits for nodes, edges, and frontier in the working set. Profiles map budgets to usage scenarios. Operators receive a concrete budget instance.",
      "classes": [
        "WSBudget"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses"
      ],
      "constants": [
        "MINIMAL",
        "STANDARD",
        "LARGE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:53:37.927601",
        "modified": "2026-01-30T11:53:37.927707",
        "modified_days_ago": 21,
        "lines": 60,
        "size_bytes": 2053,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/container.py",
      "name": "container.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"LinguisticIR is a four-partition container for linguistic representations. Surface (document, mentions. Committed (entity_refs, predicates, propositions, scope_ops, discourse_links, attributions, value_nodes.  \nValidation invariants enforce references exist in surface doc, mentions in mentions; predicate in props; scope in props; value in nodes.  \nFrontier contains hypotheses.  \n",
      "classes": [
        "LinguisticIR"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:20:48.878507",
        "modified": "2026-02-01T03:20:48.878643",
        "modified_days_ago": 19,
        "lines": 611,
        "size_bytes": 26460,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/context_ref.py",
      "name": "context_ref.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Linguistic IR v0 \u2014 ContextRef (context axis).\n\nA ContextRef identifies the domain, worldline, and definitional context\nunder which a state or episode exists. This enables reasoning about\n\"two truths\" (e.g., different domains, different revision histories)\nwithout forcing premature collapse.\n\nSchema reference: docs/canonical/semantic_working_memory_contract_v0.md \u00a75.4",
      "classes": [
        "ContextRef"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:24:04.994982",
        "modified": "2026-01-30T11:24:04.995077",
        "modified_days_ago": 21,
        "lines": 85,
        "size_bytes": 2782,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/episode_trace.py",
      "name": "episode_trace.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Computes the cryptographic hashes for OperatorStep and EpisodeTrace objects to enforce episode integrity and operator implementation provenance.",
      "classes": [
        "OperatorStep",
        "EpisodeTrace"
      ],
      "functions": [
        "_compute_operator_sequence_digest",
        "compute_episode_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.context_ref"
      ],
      "constants": [
        "EPISODE_TRACE_SCHEMA_ID",
        "EPISODE_TRACE_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T02:39:09.779923",
        "modified": "2026-02-01T02:39:09.780067",
        "modified_days_ago": 19,
        "lines": 252,
        "size_bytes": 8764,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/frontier.py",
      "name": "frontier.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"Frontier holds unresolved linguistic hypotheses (Hypothesis) with scored candidates and PromotionRecord. It generates frontier hypothesis IDs from (attached_to, kind, generator_id, candidates. In the MOC (model context) for the hypothesis, ranked candidates, applied operator, delta. It content-addressable hyp_id to canonical_ (hypothesis) for the function candidate scoring; status, kind. A promoted hyp_ record with operator_ and delta objects.  \n",
      "classes": [
        "HypothesisKind",
        "HypothesisStatus",
        "Candidate",
        "GeneratorRef",
        "PromotionRecord",
        "Hypothesis"
      ],
      "functions": [
        "_compute_hypothesis_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:50:05.079972",
        "modified": "2026-01-30T10:02:34.491217",
        "modified_days_ago": 21,
        "lines": 207,
        "size_bytes": 6895,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/meaning_state.py",
      "name": "meaning_state.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Computes a content-addressed digest of committed meaning-state plus metadata to detect drift, forming nodes in the cryptographic chain of custody.",
      "classes": [
        "MeaningStateDigest"
      ],
      "functions": [
        "compute_state_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.context_ref"
      ],
      "constants": [
        "MEANING_STATE_SCHEMA_ID",
        "MEANING_STATE_SCHEMA_VERSION",
        "GENESIS_SENTINEL"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:24:26.608048",
        "modified": "2026-01-30T11:24:26.608179",
        "modified_days_ago": 21,
        "lines": 187,
        "size_bytes": 6871,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/myelin_sheath.py",
      "name": "myelin_sheath.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"Computes a deterministic sheath_id from canonical corridor + evidence digest\nA Myelin Sheath is a validated by episode hash\n@ CanonicalCorridor contains committed steps\n@ Myelin Sheath: episode \u2192 sheath_implementation\n@ Canonical operator_implementation\n",
      "classes": [
        "CorridorStep",
        "CanonicalCorridor",
        "MyelinSheath"
      ],
      "functions": [
        "compute_sheath_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.context_ref"
      ],
      "constants": [
        "MYELIN_SHEATH_SCHEMA_ID",
        "MYELIN_SHEATH_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T02:40:27.170822",
        "modified": "2026-02-01T02:40:27.170957",
        "modified_days_ago": 19,
        "lines": 247,
        "size_bytes": 9132,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/patch_v0.py",
      "name": "patch_v0.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "LinguisticDeltaPatchV0 encodes a sequence of typed operations (PatchOp) that transform one LinguisticIR to another. Patches are ordered by op kind rank and node/edge keys. Schema v0.0. Used for deterministic diffing.",
      "classes": [
        "PatchOp",
        "LinguisticDeltaPatchV0"
      ],
      "functions": [
        "_stable_key"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "LINGUISTIC_DELTA_PATCH_SCHEMA_ID",
        "LINGUISTIC_DELTA_PATCH_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-01-30T09:51:30.482858",
        "modified": "2026-01-30T10:02:34.489287",
        "modified_days_ago": 21,
        "lines": 121,
        "size_bytes": 3983,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/pin_set.py",
      "name": "pin_set.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Pin set for eviction protection (Implementation Constraint E).\n\nNodes in the pin set cannot be evicted by EvictWS.  The pin set is\npurely operational \u2014 it does not change Committed semantics or\nMeaningStateDigest.  It is recomputed at the start of each eviction pass.\n\nv0 pin categories:\n- Goal nodes: nodes in the active goal predicate's closure.",
      "classes": [
        "PinSet"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "EMPTY_PIN_SET"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:54:08.531564",
        "modified": "2026-01-30T12:02:30.576310",
        "modified_days_ago": 22,
        "lines": 70,
        "size_bytes": 2329,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/retention.py",
      "name": "retention.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Computes retention scores for working-set eviction using recency (last PlannerView/witness step), frequency ( appearances in patch/precondition), and certification (set by VerifyAndPromote. Policy coefficients in policy_dig est via policy_ digest.",
      "classes": [
        "RetentionPolicy",
        "RetentionState",
        "RetentionTable"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "DEFAULT_RETENTION_POLICY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:53:58.891965",
        "modified": "2026-01-30T11:53:58.892095",
        "modified_days_ago": 21,
        "lines": 146,
        "size_bytes": 5040,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/types.py",
      "name": "types.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"Defines frozen dataclass types for linguistic IR v0 entities, relationships, and features. Provides canonical IDs for text elements and supports content addresses for mentions, predicates and their features. Includes IDs, has value and status types, and operators for semantic modeling.  Represents a full sentence meaning as structured dataclass of text segments with virtual MWEIGHTS for NLP . 0r for 0rational\n    features. 0r for\n    mentions. 0 types\n    .",
      "classes": [
        "NodeStatus",
        "MentionType",
        "PredKind",
        "PropositionStatus",
        "ScopeKind",
        "DiscourseRelation",
        "AttitudeType",
        "ValueType",
        "Number",
        "Person",
        "Gender",
        "Definiteness",
        "Tense",
        "Aspect",
        "Mood",
        "Voice",
        "EntityFeatures",
        "PredFeatures",
        "Span",
        "TokenSpan",
        "NodeRef",
        "NodeEnvelope",
        "EdgeEnvelope",
        "Token",
        "Segment",
        "Document",
        "Mention",
        "EntityRef",
        "Predicate",
        "RoleEdge",
        "Proposition",
        "ScopeOperator",
        "DiscourseLink",
        "Attribution",
        "ValueNode"
      ],
      "functions": [
        "_content_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "LINGUISTIC_IR_SCHEMA_ID",
        "LINGUISTIC_IR_SCHEMA_VERSION",
        "CANONICALIZATION_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T11:48:38.267884",
        "modified": "2026-01-30T11:48:38.268011",
        "modified_days_ago": 21,
        "lines": 866,
        "size_bytes": 26881,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/ir_v0/witness_v0.py",
      "name": "witness_v0.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"OperatorWitnessV0 records which precondition, provenance, and patch it produced for an operator. Evidence must be non-authoritative unless promoted. Operator_impl_digest links to implementation. AnchorRef identifies text span in a document. ExternalProvenance indicates origin. Schema: sterling.operatorwitness.v0.0.1.",
      "classes": [
        "PreconditionCheck",
        "AnchorRef",
        "ExternalProvenance",
        "OperatorWitnessV0"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "OPERATOR_WITNESS_SCHEMA_ID",
        "OPERATOR_WITNESS_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-01-30T09:51:53.069642",
        "modified": "2026-01-30T10:02:34.490647",
        "modified_days_ago": 21,
        "lines": 155,
        "size_bytes": 5293,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "MTA capsule: portable semantic stage algebra.\n\nThis package contains the core MTA (Morphosyntactic-Temporal Algebra) types\nand operations. It is import-isolated from Sterling engine internals \u2014\nno module in this package may import from core.reasoning, core.operators,\ncore.carrier, core.worlds, or core.kernels.",
      "classes": [],
      "functions": [],
      "imports": [
        "canonical",
        "edit_log",
        "gccl",
        "hashing",
        "operators",
        "replay",
        "stage_state",
        "verifier"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.971937",
        "modified": "2026-02-21T23:57:28.972031",
        "modified_days_ago": 0,
        "lines": 116,
        "size_bytes": 2589,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/canonical.py",
      "name": "canonical.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Serializes StageStateV1 deterministically by sorting only top-level collections. Produces hashable dict and bytes with ascii encoding enabled for cross-platform consistency.",
      "classes": [],
      "functions": [
        "_scope_node_to_canonical_dict",
        "canonicalize",
        "canonical_bytes"
      ],
      "imports": [
        "__future__",
        "json",
        "typing",
        "stage_state"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972074",
        "modified": "2026-02-21T23:57:28.972182",
        "modified_days_ago": 0,
        "lines": 106,
        "size_bytes": 3445,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/edit_log.py",
      "name": "edit_log.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\n  \"description\": \"Records a feature or obligation removal as a type edit (Set or Remove) a value from a model entity value or\n  semantic dict  (for  each  value:  (set or\n                (set or  Remove  (if\nType (the  semantic\n  checks,  to ensure\n  only \"Set\":  no\n  semantic\n  checks\n  for each\n  value:  semantic\n  and  value\n  semantic\n  (all  (no\n  semantic\n  checks to  ensure  only\n  semantic\n  validation for  each  value\n  (no\n  semantic\n  checks\n  to  ensure\n  no  semantic\n  checks to ...",
      "classes": [
        "SetFeature",
        "RemoveObligation",
        "AddScopeNode",
        "SetScopeParent",
        "SetScopeModality",
        "EditLogV1"
      ],
      "functions": [
        "_validate_ascii_id",
        "_canonical_entry_bytes",
        "_sha256_hex",
        "edit_entry_from_dict"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "re",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_ASCII_ID_RE",
        "EDIT_LOG_SCHEMA_VERSION",
        "_VALID_FEATURE_TARGET_KINDS",
        "_VALID_OBLIGATION_TARGET_KINDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972219",
        "modified": "2026-02-21T23:57:28.972357",
        "modified_days_ago": 0,
        "lines": 400,
        "size_bytes": 13283,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/gccl.py",
      "name": "gccl.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Evaluates GCCL clauses against StageStateV1 using schema constraints. Unknown clause or scope keys fail closed with GCCLError. MustAll, MustAny, MustNot operators enforced.",
      "classes": [
        "GCCLError",
        "ClauseResult",
        "GCCLResult"
      ],
      "functions": [
        "_find_event",
        "_find_entity",
        "_find_scope_node",
        "_get_feature_value",
        "_eval_has_feature",
        "_eval_lacks_feature",
        "_eval_has_role_edge",
        "_eval_has_scope_node",
        "_eval_scope_parent_is",
        "_eval_scope_applies_to_event"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "stage_state"
      ],
      "constants": [
        "GCCL_SCHEMA_VERSION",
        "_SCOPE_FEATURE_KEYS",
        "_CLAUSE_DISPATCH"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972396",
        "modified": "2026-02-21T23:57:28.972511",
        "modified_days_ago": 0,
        "lines": 435,
        "size_bytes": 16566,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/hashing.py",
      "name": "hashing.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Hashes StageStateV1 using domain-specific SHA256: sha256(_DOMAIN_PREFIX + canonical_bytes(state)). Bumping version or dict shape requires updating both prefix and version field.",
      "classes": [],
      "functions": [
        "stage_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "canonical",
        "stage_state"
      ],
      "constants": [
        "_DOMAIN_PREFIX"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972588",
        "modified": "2026-02-21T23:57:28.972690",
        "modified_days_ago": 0,
        "lines": 30,
        "size_bytes": 818,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/operators.py",
      "name": "operators.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Checks preconditions against StageStateV1 and produce ordered EditEntry tuples in OperatorResult. Never mutates state directly; replay kernel enforces edits. Operators raise OperatorError on state-dependent failures. Do not import replay or verifier.",
      "classes": [
        "OperatorError",
        "OperatorResult"
      ],
      "functions": [
        "_find_event",
        "_find_entity",
        "_find_var",
        "_find_scope_node",
        "_check_event_exists",
        "_check_entity_exists",
        "_check_var_exists",
        "_check_scope_id_free",
        "_check_scope_id_exists",
        "_check_obligation_open"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "edit_log",
        "stage_state"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972723",
        "modified": "2026-02-21T23:57:28.972907",
        "modified_days_ago": 0,
        "lines": 397,
        "size_bytes": 13224,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/replay.py",
      "name": "replay.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Applies edit entries to StageStateV1 state; only rebuilds the targeted object and its tuple, asserts non-targets unchanged by identity.",
      "classes": [
        "KernelError"
      ],
      "functions": [
        "_find_by_id",
        "_set_feature",
        "_remove_obligation",
        "_assert_non_targets_unchanged",
        "_apply_set_feature",
        "_apply_remove_obligation",
        "_apply_add_scope_node",
        "_apply_set_scope_parent",
        "_apply_set_scope_modality",
        "apply_edit"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "edit_log",
        "stage_state"
      ],
      "constants": [
        "_APPLY_DISPATCH"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.972949",
        "modified": "2026-02-21T23:57:28.973098",
        "modified_days_ago": 0,
        "lines": 252,
        "size_bytes": 9310,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/stage_state.py",
      "name": "stage_state.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"StageStateV1 \u2014 immutable, sorted feature tuples for each kind\n  - validate structure\n  - validate member references\n  - each value\n  - type\n  - simple\n  - enforce\n  - each node name\n  - validate structure\n  - L  literal checks.\n  - enforce node/role\n  checks on graph.",
      "classes": [
        "Filler",
        "Entity",
        "Event",
        "RoleEdge",
        "Var",
        "Quantifier",
        "ScopeAppliesTo",
        "ScopeNode",
        "StageStateV1"
      ],
      "functions": [
        "_validate_ascii_id",
        "_check_no_duplicates",
        "_check_ref_exists",
        "features_from_dict",
        "features_to_dict",
        "obligations_from_list",
        "_check_no_scope_cycles"
      ],
      "imports": [
        "__future__",
        "re",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_ASCII_ID_RE",
        "_VALID_FILLER_KINDS",
        "_VALID_APPLIES_TO_KINDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.973137",
        "modified": "2026-02-21T23:57:28.973273",
        "modified_days_ago": 0,
        "lines": 459,
        "size_bytes": 15617,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/mta/verifier.py",
      "name": "verifier.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Verifies traces by replaying from base state with per-step hash chain. Self-authenticates via independent recomputation of entry and log hashes. Detects tampering at exact step (INV-LO-35).",
      "classes": [
        "VerifierError",
        "StepRecord",
        "VerifiedTrace"
      ],
      "functions": [
        "verify_trace"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "edit_log",
        "hashing",
        "replay",
        "stage_state"
      ],
      "constants": [
        "TRACE_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.973305",
        "modified": "2026-02-21T23:57:28.973444",
        "modified_days_ago": 0,
        "lines": 179,
        "size_bytes": 5885,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators.py",
      "name": "operators.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Compatibility shim for linguistic operator registry exports.\n\nCanonical implementation lives in\n`core.linguistics.operators.registry` under the operators package.\nThis module remains to preserve legacy direct-file import paths.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.376245",
        "modified": "2026-02-21T10:46:18.924967",
        "modified_days_ago": 0,
        "lines": 40,
        "size_bytes": 1011,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Linguistic operators package.\n\nRe-exports the generation operator registry (formerly operators.py) and\nprovides the v0 IR construction operators.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:57:32.986706",
        "modified": "2026-01-30T09:57:32.986839",
        "modified_days_ago": 21,
        "lines": 26,
        "size_bytes": 749,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/base.py",
      "name": "base.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Linguistic IR v0 defines protocol and base types for linguistic operators, including OperatorContext, Inputs, and Result. Operators must fail-closed by returning OperatorResult with a witness on precondition failure.",
      "classes": [
        "OperatorContext",
        "OperatorInputs",
        "OperatorResult",
        "LinguisticOperator"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass",
        "runtime_checkable"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:52:16.903094",
        "modified": "2026-01-30T10:02:21.634821",
        "modified_days_ago": 21,
        "lines": 68,
        "size_bytes": 1922,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/registry.py",
      "name": "registry.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Parsenal parsing of operator IDs by category. Generators reference only the canonical registry for linguistic operators.",
      "classes": [
        "OperatorSpec",
        "ParsedOperator",
        "LinguisticOperators"
      ],
      "functions": [
        "parse_operator_id",
        "normalize_operator_id",
        "_build_registry",
        "get_all_operators",
        "get_operator",
        "get_operators_by_category",
        "validate_operator_id",
        "validate_operator_params",
        "get_operator_category",
        "assert_valid_operator"
      ],
      "imports": [
        "__future__",
        "re",
        "dataclasses",
        "typing",
        "core.reasoning.state_graph"
      ],
      "constants": [
        "_PARAM_PATTERN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:57:23.764730",
        "modified": "2026-01-30T10:02:34.490856",
        "modified_days_ago": 21,
        "lines": 463,
        "size_bytes": 15926,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Linguistic IR v0 operators \u2014 registry and exports.\n\nProvides all v0 operators and a dispatch function for deserialization.\nIncludes the original 10 linguistic operators, lifecycle operators\n(EvictWS, CompactToSummary, RehydrateShadow, VerifyAndPromote),\nand myelin sheath operators (PromoteToSheath, ApplySheath).",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.operators.v0.apply_sheath",
        "core.linguistics.operators.v0.attach_modality",
        "core.linguistics.operators.v0.attach_negation",
        "core.linguistics.operators.v0.compact_to_summary",
        "core.linguistics.operators.v0.evict_ws",
        "core.linguistics.operators.v0.make_entity_ref",
        "core.linguistics.operators.v0.make_mention",
        "core.linguistics.operators.v0.make_predicate",
        "core.linguistics.operators.v0.make_proposition",
        "core.linguistics.operators.v0.promote_coref_merge"
      ],
      "constants": [
        "V0_OPERATORS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:00:33.221138",
        "modified": "2026-01-30T12:00:33.221286",
        "modified_days_ago": 21,
        "lines": 66,
        "size_bytes": 2622,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/apply_sheath.py",
      "name": "apply_sheath.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Apply a certified MyelinSheath corridor; fail-closed on mismatched preconditions, registry digest, evidence roots, or context incompatibility.",
      "classes": [
        "ApplySheath"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.myelin_sheath",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:22:43.897640",
        "modified": "2026-02-01T03:22:43.897771",
        "modified_days_ago": 19,
        "lines": 251,
        "size_bytes": 10951,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/attach_modality.py",
      "name": "attach_modality.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Op 6: AttachModality \u2014 attach a MODALITY scope operator to a proposition.",
      "classes": [
        "AttachModality"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.types",
        "core.linguistics.operators.base",
        "core.linguistics.operators.v0.scope_attach_common"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:54:04.130747",
        "modified": "2026-02-21T10:46:49.644554",
        "modified_days_ago": 0,
        "lines": 44,
        "size_bytes": 1255,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/attach_negation.py",
      "name": "attach_negation.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Op 5: AttachNegation \u2014 attach a NEGATION scope operator to a proposition.",
      "classes": [
        "AttachNegation"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.types",
        "core.linguistics.operators.base",
        "core.linguistics.operators.v0.scope_attach_common"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:53:52.654126",
        "modified": "2026-02-21T10:46:58.496960",
        "modified_days_ago": 0,
        "lines": 46,
        "size_bytes": 1365,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/compact_to_summary.py",
      "name": "compact_to_summary.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "{\"description\": \"Compaction: returns a summary artifact carrying compacted node and edge IDs.  Allows reconstruction via  <PRES-PROD> (reconstruct (op) common for all operators.  Produces summary artifacts for op'stated' nodes.",
      "classes": [
        "CompactionSummary",
        "CompactToSummary"
      ],
      "functions": [
        "_gen_summary_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:28:12.189087",
        "modified": "2026-02-01T03:28:12.189212",
        "modified_days_ago": 19,
        "lines": 279,
        "size_bytes": 10774,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/evict_ws.py",
      "name": "evict_ws.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "{\n  \"description\": \"EvictWS \u2014 Prunes non-committed content from working-set per implementation.  digest.  \nReturn (hash).  \nPrune non-committed.  \nReturn  (digest).  \nEvict (WS)  \nPrune (non-comm)  \nReturn  (object).  \nPrune (com)  \nReturn structures.  \nPrune storage  \nReturn (graph).  \nPrune (content)  \nPrune (shadows).  \nReturn ( digests)  \nPrune (shadows).  \nPrune (pinned)  \nReturn ( digests)  \nPrune (pinned)  \nReturn (graph)  \nPrune (non-pinned)  \nReturn (graph).",
      "classes": [
        "EvictWS"
      ],
      "functions": [
        "_committed_digest",
        "_count_edges",
        "_count_nodes"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing",
        "core.linguistics.ir_v0.budget",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.pin_set",
        "core.linguistics.ir_v0.retention",
        "core.linguistics.ir_v0.types"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:27:51.348453",
        "modified": "2026-02-01T03:27:51.348801",
        "modified_days_ago": 19,
        "lines": 357,
        "size_bytes": 14822,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/make_entity_ref.py",
      "name": "make_entity_ref.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "MakeEntityRef creates an EntityRef node linking to existing mentions in the IR. Requires valid mention IDs and a canonical label. Fails if mentions missing or already covered.",
      "classes": [
        "MakeEntityRef"
      ],
      "functions": [
        "_fail",
        "_gen_entity_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:53:06.138089",
        "modified": "2026-01-30T10:02:34.489260",
        "modified_days_ago": 21,
        "lines": 150,
        "size_bytes": 4903,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/make_mention.py",
      "name": "make_mention.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "MakeMention creates a Mention node from a surface span within a segment in a LinguisticIR document.",
      "classes": [
        "MakeMention"
      ],
      "functions": [
        "_gen_mention_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:52:50.988986",
        "modified": "2026-01-30T10:02:34.490854",
        "modified_days_ago": 21,
        "lines": 155,
        "size_bytes": 5114,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/make_predicate.py",
      "name": "make_predicate.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "MakePredicate creates a Predicate node from an anchor span in the linguistic processing module.",
      "classes": [
        "MakePredicate"
      ],
      "functions": [
        "_fail",
        "_gen_pred_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:53:19.288778",
        "modified": "2026-01-30T10:02:34.491889",
        "modified_days_ago": 21,
        "lines": 134,
        "size_bytes": 4234,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/make_proposition.py",
      "name": "make_proposition.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "MakeProposition creates a Proposition by establishing predicate and role edges using validated parameters and existing knowledge graph references.",
      "classes": [
        "MakeProposition"
      ],
      "functions": [
        "_fail",
        "_gen_prop_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:53:36.516589",
        "modified": "2026-01-30T10:02:34.493414",
        "modified_days_ago": 21,
        "lines": 182,
        "size_bytes": 5768,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/promote_coref_merge.py",
      "name": "promote_coref_merge.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "PromoteCorefMerge: Certifies a COREF hypothesis by merging its mention entity ref into the selected entity ref within the LinguisticIR and OperatorContext.",
      "classes": [
        "PromoteCorefMerge"
      ],
      "functions": [
        "_fail",
        "_gen_prom_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:54:46.285922",
        "modified": "2026-01-30T10:02:34.490546",
        "modified_days_ago": 21,
        "lines": 197,
        "size_bytes": 6648,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/promote_discourse_link.py",
      "name": "promote_discourse_link.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "PromoteDiscourseLink: Certifies a DISCOURSE LINK hypothesis by promoting it to a committed DiscourseLink through a structured operator, requiring valid inputs and checks.",
      "classes": [
        "PromoteDiscourseLink"
      ],
      "functions": [
        "_fail",
        "_gen_link_id",
        "_gen_prom_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:55:25.611453",
        "modified": "2026-01-30T10:02:34.493189",
        "modified_days_ago": 21,
        "lines": 238,
        "size_bytes": 8219,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/promote_to_sheath.py",
      "name": "promote_to_sheath.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "PromoteToSheath certifies a Committed corridor by converting it to a MyelinSheath artifact and validates all elements committed; fails if any non-Committed node or unresolvable evidence root detected.",
      "classes": [
        "PromoteToSheath"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.myelin_sheath",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:22:11.944516",
        "modified": "2026-02-01T03:22:11.944703",
        "modified_days_ago": 19,
        "lines": 216,
        "size_bytes": 8471,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/propose_coref.py",
      "name": "propose_coref.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "ProposeCoref creates a COREF hypothesis linking mentions to candidate entities in the frontier.",
      "classes": [
        "ProposeCoref"
      ],
      "functions": [
        "_fail"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:54:24.261965",
        "modified": "2026-01-30T10:02:34.492373",
        "modified_days_ago": 21,
        "lines": 184,
        "size_bytes": 6051,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/propose_discourse_link.py",
      "name": "propose_discourse_link.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "ProposeDiscourseLink creates a DISCOURSE_LINK hypothesis between two propositions in the frontier using provided IDs and candidate relations.",
      "classes": [
        "ProposeDiscourseLink"
      ],
      "functions": [
        "_fail"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.frontier",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T09:55:01.441376",
        "modified": "2026-01-30T10:02:34.492446",
        "modified_days_ago": 21,
        "lines": 155,
        "size_bytes": 5020,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/rehydrate_shadow.py",
      "name": "rehydrate_shadow.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "RehydrateShadow brings content from persistent substrate into the working set as Shadow nodes. It applies only seeds and budget parameters, returns a patch with Shadow/Weak nodes and Frontier hypotheses. It emits deterministic witness digests for seeds, budgets, and returned/skipped node sets.",
      "classes": [
        "RehydrateShadow"
      ],
      "functions": [
        "_seeds_digest",
        "_returned_set_digest",
        "_skipped_set_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:27:36.487046",
        "modified": "2026-02-01T03:27:36.487206",
        "modified_days_ago": 19,
        "lines": 230,
        "size_bytes": 8805,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/scope_attach_common.py",
      "name": "scope_attach_common.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Shared helpers for v0 scope-attach operators.",
      "classes": [],
      "functions": [
        "gen_scope_id",
        "fail_result",
        "apply_scope_attach"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T10:46:42.167623",
        "modified": "2026-02-21T10:46:42.170054",
        "modified_days_ago": 0,
        "lines": 126,
        "size_bytes": 4358,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/operators/v0/verify_and_promote.py",
      "name": "verify_and_promote.py",
      "category": "Linguistic processing operators",
      "status": "legacy_v7",
      "description": "Verifies evidence for specified node IDs, promotes them to Committed status if checks pass, emits PromotionRecords when needed, and updates MeaningStateDigest on commit.",
      "classes": [
        "VerifyAndPromote"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.linguistics.ir_v0.container",
        "core.linguistics.ir_v0.patch_v0",
        "core.linguistics.ir_v0.types",
        "core.linguistics.ir_v0.witness_v0",
        "core.linguistics.operators.base"
      ],
      "constants": [
        "_IMPL_DIGEST"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Located in old version directory (v7 or earlier)"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-01T03:28:24.859384",
        "modified": "2026-02-01T03:28:24.859518",
        "modified_days_ago": 19,
        "lines": 234,
        "size_bytes": 8894,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "linguistics/parser_trust.py",
      "name": "parser_trust.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"Parser capabilities\",\"untrained_Weights,\" rather than a fixed structure\n    (no: \"Only\" if\n    grammatical\n    # Optional\n    # admissible_grammar\n    #unparsed_grammar\n    # linguistic\n    # Pre-trained\n    # Check_missing_ambiguity\n    #  syntactic\n    #  admissible_grammar\n    #  admissible_grammar\n    #  admissible_grammar\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    #  admissible\n    # ...",
      "classes": [
        "ParserCapabilities",
        "ParserClass",
        "ClaimType",
        "RunIntent",
        "CapabilityAdmissibilityRule",
        "AdmissibilityResult",
        "ParserTrustAttestation",
        "ParserTrustError",
        "ParserAdmissibilityError",
        "UnknownParserError",
        "ParserAdmissibilityGate"
      ],
      "functions": [
        "validate_parser_for_claim",
        "get_parser_class",
        "get_parser_capabilities",
        "register_parser_classification",
        "register_parser_capabilities"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-30T12:05:14.376505",
        "modified": "2026-01-30T12:05:14.376655",
        "modified_days_ago": 21,
        "lines": 1154,
        "size_bytes": 43203,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/reducer_result_v1.py",
      "name": "reducer_result_v1.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"description\":\"LanguageReducerV1\": \"grounding_violations\", \"reduction_hierarchy of (highly_structured_talid_plan_each_wise: 'still_redundant_ from each_ authoritative_ source_ of each_ value\n# as provided by system\n# with all_mod_sch hierarchy\n# official_ as file\n# each_ author_ative: 'no text_ to check_ (no_sch_ving:  has_ textual_content: check_ (all_ textual_including_ all_ (optional_ = \"no_violation_ text\n# a_ authoritative_ for the_ file_ references and  d_ert_ to each_ authority\n#...",
      "classes": [
        "GroundingViolation",
        "GroundingResultV1",
        "AdvisoryClassification",
        "LanguageReducerResultV1"
      ],
      "functions": [
        "validate_result"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "LANGUAGE_REDUCER_RESULT_SCHEMA_ID",
        "LANGUAGE_REDUCER_RESULT_SCHEMA_VERSION",
        "GROUNDING_RESULT_SCHEMA_ID",
        "GROUNDING_RESULT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-03T18:24:37.348289",
        "modified": "2026-02-03T18:24:37.348434",
        "modified_days_ago": 17,
        "lines": 630,
        "size_bytes": 25001,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "linguistics/reducers/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Linguistic reducers module.\n\nReducers transform input artifacts (envelopes) into committed LinguisticIR.\n\nAvailable reducers:\n- IntentReducerV1: Reduces LanguageIOEnvelopeV1 to committed IR with intent classification\n\nAuthor: @darianrosebrook\nDate: February 2026",
      "classes": [],
      "functions": [],
      "imports": [
        "core.linguistics.reducers.intent_reducer_v1"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-03T17:51:39.818932",
        "modified": "2026-02-03T17:51:39.819035",
        "modified_days_ago": 17,
        "lines": 21,
        "size_bytes": 449,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/reducers/intent_reducer_v1.py",
      "name": "intent_reducer_v1.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "{\"type\":\"semantics\",\"owner\":\"@sterlinguistics\",\"line\":\" commitment\",\"gated\": true,\"authoritative\" context: \"no\" in commit, so\n    *  (this: a 1.0 SEmepted\n    \"\"\" returns\n        intent: here 1\n        \"\"\" commits to\n        T1 (exec context (no exec)\n        \"\"\" 1.0.0 \"\"\" Look ahead type\n        exactly once\n        for\n        semantic\n        commitment\n        can\n        only\n        semantic\n        space\n        (the\n        semantic\n        simple\n        Meets\n        the\n       ...",
      "classes": [
        "IntentReducerV1"
      ],
      "functions": [
        "_select_idle_goal"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "re",
        "time",
        "dataclasses",
        "typing",
        "core.intent.types",
        "core.linguistics.io_envelope_v1"
      ],
      "constants": [
        "INTENT_REDUCER_VERSION",
        "_IMPL_CODE_HASH",
        "CANONICAL_ACTIONS",
        "ACTION_NORMALIZE_MAP",
        "ACTION_TO_FAMILY",
        "ACTION_TO_TYPE",
        "_IDLE_EPISODE_HEADER"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-09T19:42:58.462107",
        "modified": "2026-02-09T19:42:58.462232",
        "modified_days_ago": 11,
        "lines": 1000,
        "size_bytes": 36821,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "linguistics/resolve_intent_steps.py",
      "name": "resolve_intent_steps.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "Resolves intent steps to executor leaves by invoking domain solvers and mapping their outputs. Bridges intent leaves with proposition metadata to concrete actions such as craft_recipe, acquire_material, smelt, and place_block in Phase 1 (CRAFT only). Logging and validation ensure governance-compliant transitions.",
      "classes": [],
      "functions": [
        "_canonical_json",
        "_sha256_hex",
        "_craft_args",
        "_mine_args",
        "_smelt_args",
        "_place_args",
        "_prune_mine_rules",
        "_compute_mine_frontier",
        "_prune_craft_variants_to_observed",
        "map_solver_step_to_leaf"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "collections",
        "typing"
      ],
      "constants": [
        "RESOLVABLE_TASK_TYPES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-13T18:47:50.561855",
        "modified": "2026-02-13T18:47:50.561980",
        "modified_days_ago": 7,
        "lines": 650,
        "size_bytes": 24900,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "linguistics/world_snapshot_v1.py",
      "name": "world_snapshot_v1.py",
      "category": "Linguistic processing operators",
      "status": "active",
      "description": "WorldSnapshotV1 provides explicit world state for grounding. It defines structured types (Position, InventoryItem, EntityInfo, BlockInfo) and validates world snapshot schema compliance.",
      "classes": [
        "Position",
        "InventoryItem",
        "EntityInfo",
        "BlockInfo",
        "WorldSnapshotV1"
      ],
      "functions": [
        "validate_snapshot"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "WORLD_SNAPSHOT_SCHEMA_ID",
        "WORLD_SNAPSHOT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-03T18:24:42.274065",
        "modified": "2026-02-03T18:24:42.274206",
        "modified_days_ago": 17,
        "lines": 589,
        "size_bytes": 21810,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "logging_config.py",
      "name": "logging_config.py",
      "category": "Core module",
      "status": "active",
      "description": "Configures Sterling's logging with customizable levels and formats, supporting JSON for production and colored output for development.",
      "classes": [
        "SterlingFormatter"
      ],
      "functions": [
        "verbose",
        "get_logging_config",
        "setup_logging",
        "get_logger",
        "log_performance",
        "log_api_call"
      ],
      "imports": [
        "logging",
        "logging.config",
        "sys",
        "pathlib",
        "typing"
      ],
      "constants": [
        "VERBOSE_LEVEL"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-26T21:37:06.785650",
        "modified": "2026-01-22T07:53:46.007221",
        "modified_days_ago": 29,
        "lines": 271,
        "size_bytes": 7685,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/__init__.py",
      "name": "__init__.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Schema registration entrypoint for Memory Substrate (MS).",
      "classes": [],
      "functions": [
        "build_registry"
      ],
      "imports": [
        "__future__",
        "core.memory.meta_schemas",
        "core.memory.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T10:33:40.539355",
        "modified": "2026-01-22T07:53:46.530788",
        "modified_days_ago": 29,
        "lines": 20,
        "size_bytes": 486,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/abstraction_expansion.py",
      "name": "abstraction_expansion.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Reasoner-Side Abstraction Expansion\n\nEnables selective expansion of abstract claims into their atomic sources\nwhen abstraction density or lossiness threatens task correctness.\n\nThis module implements the \"Reasoner Abstraction Expansion\" working spec,\nmaintaining TD-grade determinism, provenance, and budget honesty.\n\n@author: @darianrosebrook",
      "classes": [
        "ExpansionBudget",
        "ExpansionView",
        "CachedExpansionResult",
        "ExpansionResult",
        "DrilldownSliceInfo"
      ],
      "functions": [
        "compute_claim_cost",
        "should_trigger_expansion",
        "select_abstractions_for_expansion",
        "create_expansion_recheck_actions",
        "get_registry_op_head_id",
        "load_abstraction_index",
        "batch_load_abstractions",
        "load_abstraction_from_registry_or_store",
        "_evict_expansion_cache_entry",
        "expand_abstraction"
      ],
      "imports": [
        "logging",
        "dataclasses",
        "typing",
        "core.memory.abstractions",
        "core.memory.certification",
        "core.memory.registry",
        "core.memory.schema",
        "core.memory.tool_loops"
      ],
      "constants": [
        "EXPANSION_CACHE_SCHEMA_VERSION",
        "MAX_EXPANSION_CACHE_ENTRIES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:53:21.603957",
        "modified": "2026-01-22T07:53:46.530835",
        "modified_days_ago": 30,
        "lines": 1242,
        "size_bytes": 49392,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/abstractions.py",
      "name": "abstractions.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "L3 abstraction index for claim clusters, summaries, and expansion. Records op_head_ and hash-based lookups with schema versioning. Requires registry head match for validity.",
      "classes": [
        "MemoryAbstractionV1",
        "AbstractionIndexV1"
      ],
      "functions": [
        "compute_abstraction_metrics"
      ],
      "imports": [
        "logging",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T14:06:05.597000",
        "modified": "2026-01-22T07:53:46.530740",
        "modified_days_ago": 29,
        "lines": 359,
        "size_bytes": 12782,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/anchors.py",
      "name": "anchors.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Provides grounding of claims to external identifiers (WordNet, Wikidata) via ExternalAnchorV1. Ensures referential stability through canonical IDs and versioned snapshots.",
      "classes": [
        "ExternalAnchorV1",
        "AnchorSnapshotV1",
        "AnchorStore"
      ],
      "functions": [
        "normalize_anchor_id",
        "validate_anchor_id"
      ],
      "imports": [
        "logging",
        "re",
        "dataclasses",
        "typing",
        "core.memory.canonical",
        "core.memory.certification"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T13:43:05.827489",
        "modified": "2026-01-22T07:53:46.530718",
        "modified_days_ago": 29,
        "lines": 291,
        "size_bytes": 10021,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/canonical.py",
      "name": "canonical.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Serializes artifacts to deterministic canonical JSON and computes SHA256 hashes for MOC artifacts using a ruleset registry.",
      "classes": [
        "HashRulesetRegistry"
      ],
      "functions": [
        "canonical_json",
        "normalize_sha256_hex",
        "extract_hash_value",
        "sha256_canonical",
        "fake_hash",
        "get_hash_ruleset_registry",
        "compute_spec_hash",
        "get_spec_hash",
        "validate_ruleset_versioning",
        "_next_ruleset_version"
      ],
      "imports": [
        "hashlib",
        "pathlib",
        "typing",
        "core.canonicalization"
      ],
      "constants": [
        "CURRENT_HASH_RULESET_ID"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.767923",
        "modified": "2026-01-22T07:53:46.530624",
        "modified_days_ago": 29,
        "lines": 389,
        "size_bytes": 12669,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/certificate_builder.py",
      "name": "certificate_builder.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Builds hash-locked MSCertificateV1 artifacts using provided manifest, report, and projection inputs.",
      "classes": [],
      "functions": [
        "_path_for_artifact",
        "_derive_artifact_id",
        "build_ms_certificate"
      ],
      "imports": [
        "logging",
        "datetime",
        "typing",
        "core.memory.canonical",
        "core.memory.certification",
        "core.memory.projection"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-21T11:51:18.817022",
        "modified": "2026-01-22T07:53:46.530496",
        "modified_days_ago": 29,
        "lines": 168,
        "size_bytes": 5850,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/certification.py",
      "name": "certification.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"description\":\"Defines content-addressable certification artifacts for Memory Substrate (M4/M5): MSRunManifestV1 (execution closure), MSReportV1 (rebuild verification), CertifiedFailureV1 (fence emission), OutcomeV1 (sum type for decision/failure, with certified artifact\n",
      "classes": [
        "ArtifactRefV1",
        "OutcomeV1",
        "MSRunManifestV1",
        "MSReportV1",
        "MSCertificateV1",
        "CertifiedFailureV1"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T20:52:11.904457",
        "modified": "2026-01-22T07:53:46.530945",
        "modified_days_ago": 29,
        "lines": 833,
        "size_bytes": 31666,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/claim.py",
      "name": "claim.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "ClaimInstance represents a semantic assertion with structured slots and metadata. Its compute_signature method generates a canonical identifier for deduplication using the provided schema. The class is part of Sterling's memory and concept storage systems.",
      "classes": [
        "ClaimInstance",
        "ClaimDelta",
        "SemanticOp"
      ],
      "functions": [],
      "imports": [
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.canonicalization.semantic",
        "core.memory.schema_base"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.768123",
        "modified": "2026-01-22T07:53:46.530722",
        "modified_days_ago": 29,
        "lines": 78,
        "size_bytes": 3093,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/concept_resolver.py",
      "name": "concept_resolver.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Resolves concepts deterministically: redirects if input is a ConceptID string, performs namespace and global alias lookups via ConceptStore, creates internal ConceptID from namespace, domain, and normalized slug; returns resolved ConceptID and rationale suitable for Decision Packet.",
      "classes": [
        "ConceptQuery",
        "ConceptResolution"
      ],
      "functions": [
        "slugify",
        "is_concept_id",
        "resolve_concept",
        "_concept_id_from_existing",
        "_concept_id_from_anchor"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.memory.concept_store",
        "core.memory.concepts"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T10:39:05.005699",
        "modified": "2026-01-22T07:53:46.530466",
        "modified_days_ago": 29,
        "lines": 277,
        "size_bytes": 10014,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/concept_store.py",
      "name": "concept_store.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"get_node\": \"Retrieval via alias and redirect mapping (concept_id \u2192 node_id).  \n\"  \n\"resolve\"  \n\"  \ndef\"  \n\"  \n\"  \nclass_ Concept  \n  (optional)  \n  def\"  \n  def get_  \n  def in (optional)  \n  def (concepts)  \n  def (alias, l  \n  def  \n  def (concepts)  \n  def (alias, l  \n  def (concepts)  \n  def (entities)  \n  def (merge)  \n  def (n  \n  def (backed  \n  def (ali  \n ased ",
      "classes": [
        "ConceptStore",
        "KVConceptStore"
      ],
      "functions": [
        "_encode",
        "_decode",
        "_pl_get",
        "_pl_put",
        "_pl_add",
        "normalize_alias",
        "_concept_to_dict",
        "_concept_from_dict",
        "_edge_to_dict",
        "_edge_from_dict"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.memory.concepts",
        "core.memory.store"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:53:21.604436",
        "modified": "2026-01-22T07:53:46.530763",
        "modified_days_ago": 29,
        "lines": 470,
        "size_bytes": 14760,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/concepts.py",
      "name": "concepts.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Provides stable, backend-agnostic concept identifiers and optional external pointers (Wikidata/WordNet) without importing definitions. Supports disambiguation via namespace, links (syn, hyper, hypo, related, analogous). Used for concept graph nodes in MOC.",
      "classes": [
        "ExternalRef",
        "ConceptID",
        "ConceptEdge",
        "ConceptNode"
      ],
      "functions": [
        "concept_from_wikidata",
        "concept_from_wordnet",
        "internal_concept"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T10:31:20.508268",
        "modified": "2026-01-22T07:53:46.530456",
        "modified_days_ago": 29,
        "lines": 129,
        "size_bytes": 4610,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/conflict.py",
      "name": "conflict.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Computes a deterministic hash of claim content including schema, reason, and relevant roles/values for conflict resolution.",
      "classes": [
        "ConflictSet"
      ],
      "functions": [],
      "imports": [
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.768303",
        "modified": "2026-01-22T07:53:46.530789",
        "modified_days_ago": 29,
        "lines": 113,
        "size_bytes": 4632,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/expansion_policy.py",
      "name": "expansion_policy.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Abstraction Expansion Policy Module\n\nProvides deterministic escalation policies for abstraction expansion.\nThis is a reasoner-side policy module (not MS core) that produces\ndeterministic task_spec changes and recheck actions.\n\n@author: @darianrosebrook",
      "classes": [
        "TaskClassDefaults",
        "ExpansionPolicyV1"
      ],
      "functions": [
        "classify_task_type",
        "standardize_expansion_view",
        "apply_expansion_policy"
      ],
      "imports": [
        "logging",
        "dataclasses",
        "typing",
        "core.memory.canonical"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T00:17:09.353580",
        "modified": "2026-01-22T07:53:46.530539",
        "modified_days_ago": 29,
        "lines": 430,
        "size_bytes": 16205,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/failure.py",
      "name": "failure.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Sterling's MOC Memory Failure module structures and verifies failure outcomes using CertifiedFailure objects. It detects failures via policy, registry, and packet analysis, then audits with hashes and context. Recovery suggestions are generated from failure evidence and task spec.",
      "classes": [
        "FailureReason",
        "FailureSeverity",
        "CertifiedFailure"
      ],
      "functions": [
        "create_certified_failure",
        "is_blocking_conflict",
        "check_budget_exhaustion",
        "detect_failure",
        "get_recovery_suggestions"
      ],
      "imports": [
        "datetime",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.canonicalization.json",
        "core.memory.policy"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.768521",
        "modified": "2026-01-22T23:18:16.939463",
        "modified_days_ago": 29,
        "lines": 278,
        "size_bytes": 10255,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/handover.py",
      "name": "handover.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "L1: Provides sealed envelopes for Memory Substrate state handover between agents with cryptographic integrity and provenance tracking.",
      "classes": [
        "AgentIdentityV1",
        "ScopeConstraintsV1",
        "AgentHandoverV1",
        "LaunderingViolation",
        "LaunderingReportV1"
      ],
      "functions": [
        "detect_provenance_laundering"
      ],
      "imports": [
        "dataclasses",
        "typing",
        "core.memory.canonical",
        "core.memory.certification",
        "core.memory.claim"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.768753",
        "modified": "2026-01-22T07:53:46.530911",
        "modified_days_ago": 29,
        "lines": 318,
        "size_bytes": 11506,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/index_canonical.py",
      "name": "index_canonical.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Canonicalizes shared indexes for Phase 2 and 3. Ensures index hashes match between manifest and report.",
      "classes": [],
      "functions": [
        "canonicalize_indexes",
        "compute_index_build_hash"
      ],
      "imports": [
        "json",
        "typing",
        "core.memory.canonical",
        "core.memory.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-21T10:42:02.974497",
        "modified": "2026-01-22T07:53:46.531024",
        "modified_days_ago": 29,
        "lines": 85,
        "size_bytes": 3273,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/landmark_extractor.py",
      "name": "landmark_extractor.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Extracts LandmarkCandidates from completed episodes using hub (high-degree) and traversal frequency criteria. Ensures deterministic extraction (B5) and replay equivalence (B6) via sorted keys. Configurable via ExtractionConfig.",
      "classes": [
        "ExtractionConfig",
        "ExtractionWitnessV1",
        "ExtractionResult",
        "LandmarkExtractor"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.memory.landmark_node"
      ],
      "constants": [
        "DEFAULT_EXTRACTION_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.683282",
        "modified": "2026-01-22T23:14:27.683806",
        "modified_days_ago": 29,
        "lines": 416,
        "size_bytes": 13608,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/landmark_gate.py",
      "name": "landmark_gate.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"config\": {\"description\": \"...\", \"class\": {\"name\": \"...\"} \n{\"Landmark\": {\"description\": \"...\"} \n``` \n``` \n{\"Logframe\": 0, \"...\" \n``` \n```python \n``` \n```python \n``` \n``` \n```python \n``` \n```python \n``` \n```python \n``` \n``` \n```python \n``` \n``` \n``` \n```python \n``` \n``` \n``` \n``` \n``` \n```python \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n``` \n```...",
      "classes": [
        "GateType",
        "GateResult",
        "SingleGateResult",
        "GateEvaluationResult",
        "LandmarkGateConfig",
        "LandmarkGateViolation",
        "LandmarkGate"
      ],
      "functions": [
        "create_gate_for_world"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.memory.landmark_node"
      ],
      "constants": [
        "DEFAULT_GATE_CONFIG",
        "STRICT_GATE_CONFIG",
        "LENIENT_GATE_CONFIG",
        "CERTIFIED_GATE_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:26:11.513030",
        "modified": "2026-01-22T07:53:22.107230",
        "modified_days_ago": 29,
        "lines": 743,
        "size_bytes": 26349,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/landmark_node.py",
      "name": "landmark_node.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "LandmarkNodeV1: First-Class Landmark Objects (Milestone 2.2).\n\nLandmarks are compression-gated waypoints whose value is proven by:\n1. Reuse count across episodes\n2. Path reduction evidence\n3.",
      "classes": [
        "LandmarkType",
        "LandmarkDefinition",
        "EpisodeReference",
        "PathReference",
        "EdgeReference",
        "LandmarkProvenance",
        "LandmarkMetrics",
        "LandmarkNodeV1",
        "LandmarkCandidate"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:23:57.540486",
        "modified": "2026-01-22T07:53:22.107175",
        "modified_days_ago": 30,
        "lines": 707,
        "size_bytes": 23103,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/landmark_registry.py",
      "name": "landmark_registry.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"description\":\"MOC JSON format\",\"solution\":\"\\\\n the class and related functions from context in memory\\\\n the objects of class (LandmarkRegistry key objects\\n\n\\\\nClass\\\\nLandmark storage parameters\\n\n\\\\nData\\\\nSchema for objects\\n\n\\\\nData\\\\nFormat\\\\nData\\\\nClass\\\\nFormat\\\\nSchema\\\\nfor\\\\nSchema\\\\nObject\\\\nSchema\\\\nType\\\\nSchema\\\\nObject\\\\nSchema\\\\nObject\\\\nSchema\\\\nObject\\\\nSchema\\\\nObject\\\\nSchema\\\\nObject\\\\nSchema\\\\nType\\\\nObject\\\\nSchema: stores\\\\nSchema\n    \"\"\"\n@type...",
      "classes": [
        "LandmarkRegistryConfig",
        "LandmarkRegistryError",
        "LandmarkNotFoundError",
        "LandmarkVerificationError",
        "RegistryFullError",
        "LandmarkRegistry"
      ],
      "functions": [
        "get_global_registry",
        "set_global_registry",
        "reset_global_registry"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing",
        "core.memory.landmark_gate",
        "core.memory.landmark_node"
      ],
      "constants": [
        "DEFAULT_REGISTRY_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.683903",
        "modified": "2026-01-22T23:14:27.684304",
        "modified_days_ago": 29,
        "lines": 807,
        "size_bytes": 25868,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/manifest_builder.py",
      "name": "manifest_builder.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Builds MSRunManifestV1 with locked execution closure for replay, using canonical and certificate builder utilities.",
      "classes": [],
      "functions": [
        "get_git_commit",
        "get_environment_info",
        "compute_ops_ledger_hash",
        "compute_index_build_hash",
        "build_schema_closure_ref",
        "build_policy_closure_ref",
        "build_ops_ledger_ref",
        "build_index_snapshot_refs",
        "build_abstraction_index_ref",
        "build_ms_run_manifest"
      ],
      "imports": [
        "hashlib",
        "subprocess",
        "sys",
        "datetime",
        "pathlib",
        "typing",
        "core.memory.canonical",
        "core.memory.certificate_builder",
        "core.memory.certification",
        "core.memory.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-21T10:29:42.015356",
        "modified": "2026-01-22T07:53:46.530828",
        "modified_days_ago": 29,
        "lines": 536,
        "size_bytes": 16712,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/meta_schemas.py",
      "name": "meta_schemas.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "provides get_meta_schemas.",
      "classes": [],
      "functions": [
        "get_meta_schemas"
      ],
      "imports": [
        "core.memory.schema_base"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.768988",
        "modified": "2026-01-22T07:53:46.530935",
        "modified_days_ago": 30,
        "lines": 123,
        "size_bytes": 4838,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/packet.py",
      "name": "packet.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "DecisionPacket assembly retrieves claims deterministically from the ClaimSchemaRegistry and ranks them using M3 salience scoring. When failure_policy is provided, it can return a CertifiedFailure instead of a DecisionPacket when failure conditions detected. It computes PacketDiagnostics with staleness info and rechecks if enabled.",
      "classes": [
        "PacketBudget",
        "PacketMetrics",
        "PacketSlice",
        "DecisionPacket"
      ],
      "functions": [
        "assemble_decision_packet",
        "assemble_decision_packet_with_failure_check"
      ],
      "imports": [
        "logging",
        "dataclasses",
        "typing",
        "core.memory.registry",
        "core.memory.schema"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 274,
            "content": "# TODO: Refactor PacketSlice to separate signature from claim object",
            "file_path": "core/memory/packet.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T00:17:09.353675",
        "modified": "2026-01-22T07:53:46.530582",
        "modified_days_ago": 29,
        "lines": 878,
        "size_bytes": 36881,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/packet_query.py",
      "name": "packet_query.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "PacketQuery provides a deterministic interface for querying DecisionPacket claims. In certifying mode, it enforces that only supported claims are returned and fails closed for ambiguous queries. Operators can invoke it without packet internals.",
      "classes": [
        "QueryFailedClosed",
        "QueryConfig",
        "PacketQuery"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing",
        "core.memory.claim",
        "core.memory.packet"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.352915",
        "modified": "2026-01-22T16:54:03.353095",
        "modified_days_ago": 29,
        "lines": 275,
        "size_bytes": 8602,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/policy.py",
      "name": "policy.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Verification and failure policy configuration.\n\nThis module defines policy classes which are STABLE API SURFACES.\nChanges to these classes require version bump and backward compatibility consideration.",
      "classes": [
        "VerificationPolicy",
        "FailurePolicy",
        "AbstractionPolicyV1"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing"
      ],
      "constants": [
        "DEFAULT_MAX_ARTIFACT_BYTES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T12:30:06.213436",
        "modified": "2026-01-22T07:53:46.530811",
        "modified_days_ago": 30,
        "lines": 330,
        "size_bytes": 11466,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/projection.py",
      "name": "projection.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Computes salience scores and conflict relevance using task fingerprint and claim signature; stores bounded claim and conflict slices in a hashable projection packet for deterministic evaluation.",
      "classes": [
        "ProjectionBudgetV1",
        "ProjectionMetricsV1",
        "ClaimSliceV1",
        "ConflictSliceV1",
        "ProjectionPacketV1",
        "SalienceCache"
      ],
      "functions": [
        "_parse_iso8601",
        "compute_task_fingerprint",
        "compute_temporal_relevance",
        "compute_claim_salience",
        "get_salience_cache",
        "reset_salience_cache",
        "rank_claims_and_conflicts"
      ],
      "imports": [
        "hashlib",
        "time",
        "dataclasses",
        "datetime",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.769185",
        "modified": "2026-01-22T23:18:30.259959",
        "modified_days_ago": 29,
        "lines": 536,
        "size_bytes": 19643,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/reasoner_integration.py",
      "name": "reasoner_integration.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "ExpansionTriggerResult interface for detecting and integrating abstraction expansion into reasoning, bridging MS core and reasoner with auditability.",
      "classes": [
        "ExpansionTriggerResult"
      ],
      "functions": [
        "detect_expansion_trigger",
        "create_expansion_task_spec",
        "detect_salience_critical_abstractions",
        "reasoner_expand_abstractions"
      ],
      "imports": [
        "logging",
        "dataclasses",
        "typing",
        "core.memory.abstraction_expansion",
        "core.memory.expansion_policy",
        "core.memory.registry",
        "core.memory.tool_loops"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T16:55:49.552540",
        "modified": "2026-01-22T07:53:46.530965",
        "modified_days_ago": 29,
        "lines": 306,
        "size_bytes": 10629,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/registry.py",
      "name": "registry.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Sterling Memory Registry manages schema registrations and provides access to ClaimSchemaRegistry with error handling for schema validation.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.memory.registry_store",
        "core.memory.registry_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.769375",
        "modified": "2026-01-22T07:53:46.530883",
        "modified_days_ago": 29,
        "lines": 18,
        "size_bytes": 376,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/registry_logic.py",
      "name": "registry_logic.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Enforces claim registry validation and conflict detection through delta and update processing.",
      "classes": [],
      "functions": [
        "parse_cardinality",
        "validate_slot_value",
        "validate_instance",
        "check_temporal_overlap",
        "detect_and_create_conflicts",
        "update_conflict_indexes",
        "update_indexes_for_claim",
        "remove_indexes_for_claim",
        "process_updates",
        "process_deletes"
      ],
      "imports": [
        "datetime",
        "hashlib",
        "json",
        "logging",
        "uuid",
        "typing",
        "core.memory.registry_types",
        "core.memory.schema"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.769488",
        "modified": "2026-01-22T07:53:46.530499",
        "modified_days_ago": 29,
        "lines": 725,
        "size_bytes": 29541,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/registry_store.py",
      "name": "registry_store.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Enforces claim storage and schema validation in a central registry. Maintains versioned schemas, claim instances, conflict sets, and indexed retrieval by schema and identity.",
      "classes": [
        "ClaimSchemaRegistry"
      ],
      "functions": [],
      "imports": [
        "hashlib",
        "logging",
        "typing",
        "core.memory",
        "core.memory.handover",
        "core.memory.registry_types",
        "core.memory.schema"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.769672",
        "modified": "2026-01-22T07:53:46.530638",
        "modified_days_ago": 29,
        "lines": 254,
        "size_bytes": 9825,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/registry_types.py",
      "name": "registry_types.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Defines types and exceptions for the Sterling Memory Registry schema validation and registration processes.",
      "classes": [
        "SchemaValidationError",
        "SchemaRegistrationError",
        "RegistryStoreProtocol"
      ],
      "functions": [],
      "imports": [
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.769994",
        "modified": "2026-01-22T07:53:46.530575",
        "modified_days_ago": 29,
        "lines": 40,
        "size_bytes": 1134,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/report_builder.py",
      "name": "report_builder.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Computes artifact hashes and validates content integrity using read-only registry access and canonical hashing; verifies artifact content hash via _verify_ref_content_hash, loads claims and projections with _load_artifact_json, computes deterministic hashes for artifacts, index, and ledger using provided helpers; detects failures from decision packets and builds reports without emitting outcomes.",
      "classes": [],
      "functions": [
        "_load_artifact_json",
        "_verify_ref_content_hash",
        "compute_claims_hash",
        "compute_conflicts_hash",
        "compute_indexes_hash",
        "compute_projection_hash",
        "check_schema_validation",
        "check_index_integrity",
        "check_conflict_integrity",
        "check_closure_consistency"
      ],
      "imports": [
        "json",
        "logging",
        "datetime",
        "pathlib",
        "typing",
        "core.memory.canonical",
        "core.memory.certificate_builder",
        "core.memory.certification",
        "core.memory.index_canonical",
        "core.memory.manifest_builder"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-22T13:12:17.729539",
        "modified": "2026-02-22T13:12:17.729714",
        "modified_days_ago": 0,
        "lines": 1061,
        "size_bytes": 37046,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/schema.py",
      "name": "schema.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Sterling Memory Schema Facade manages memory schema evolution and re-export. It provides structured access to ClaimInstance, SchemaDef, and compatible slot and temporal schemas.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.canonicalization.semantic",
        "core.memory.claim",
        "core.memory.conflict",
        "core.memory.failure",
        "core.memory.projection",
        "core.memory.schema_base"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.770390",
        "modified": "2026-01-22T07:53:46.530417",
        "modified_days_ago": 29,
        "lines": 64,
        "size_bytes": 1261,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/schema_base.py",
      "name": "schema_base.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Defines SlotDef, SchemaDef, ModalScope and provides AuditableMixin, TemporalMixin, AgentScopeMixin.",
      "classes": [
        "SlotDef",
        "SchemaDef",
        "ModalScope",
        "TemporalScope"
      ],
      "functions": [
        "AuditableMixin",
        "TemporalMixin",
        "AgentScopeMixin",
        "MechanismMixin"
      ],
      "imports": [
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.770507",
        "modified": "2026-01-22T07:53:46.530592",
        "modified_days_ago": 30,
        "lines": 145,
        "size_bytes": 4879,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/semantic_coverage.py",
      "name": "semantic_coverage.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Enforces semantic path validation in memory dictionaries. Verifies that to_semantic_dict() includes only required semantic paths and excludes non-semantic paths. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "get_path_value",
        "path_exists",
        "assert_paths_present",
        "assert_paths_absent"
      ],
      "imports": [
        "typing"
      ],
      "constants": [
        "_MISSING"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T12:30:06.278188",
        "modified": "2026-01-22T07:53:46.530995",
        "modified_days_ago": 29,
        "lines": 149,
        "size_bytes": 4489,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/text_claim_schemas.py",
      "name": "text_claim_schemas.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Defines schema for text-derived claims, including entity, event, relation, and claim IDs. Schemas registered with ClaimSchemaRegistry for use in text claim projections.",
      "classes": [],
      "functions": [
        "register_text_claim_schemas",
        "get_text_claim_schema",
        "is_text_claim_schema"
      ],
      "imports": [
        "core.memory.schema_base"
      ],
      "constants": [
        "TEXT_ENTITY_SCHEMA",
        "TEXT_EVENT_SCHEMA",
        "TEXT_RELATION_SCHEMA",
        "TEXT_POLARITY_SCHEMA",
        "TEXT_PN_TYPE_SCHEMA",
        "TEXT_TOKEN_SCHEMA",
        "TEXT_CLAIM_SCHEMAS",
        "TEXT_CLAIM_SCHEMA_IDS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.353136",
        "modified": "2026-01-22T16:54:03.353271",
        "modified_days_ago": 29,
        "lines": 178,
        "size_bytes": 5710,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/text_claims.py",
      "name": "text_claims.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"description\":\"Deterministic extraction of ClaimInstance objects from UtteranceState.",
      "classes": [
        "ClaimTier",
        "ClaimSourceKind",
        "ConfidenceContext",
        "TextClaimConfig",
        "EvidenceRef"
      ],
      "functions": [
        "make_confidence_context",
        "project_claims_v1",
        "_get_claim_sort_key",
        "_build_support_ref",
        "_stable_claim_id",
        "_compute_claim_qualifiers",
        "_extract_entity_claims",
        "_extract_event_claims",
        "_extract_polarity_claims",
        "_extract_pn_claims"
      ],
      "imports": [
        "dataclasses",
        "enum",
        "typing",
        "core.memory.claim",
        "core.memory.packet"
      ],
      "constants": [
        "PARSER_TRUST_CONFIDENCE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.413663",
        "modified": "2026-01-26T06:12:48.413791",
        "modified_days_ago": 25,
        "lines": 909,
        "size_bytes": 29868,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/text_negative_controls.py",
      "name": "text_negative_controls.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"description\": \"Tests verify: runs input scrambling tests against claim-preserving, consumer behavior checks, span-aware tests\nA) Scrambling preserves claim structure, but drops relevance\nB) Perturbation maintains claim integrity for certifiability\nC) Removal of support breaks certifiability\nD) Pure projection tests suit: drop metric\nE) All operator tests: measure\nF) Scramble inputs, check suite DREQUIRE: when input present, suit UP, suite  UNCHANGED: when input, operator\n    INTEGRITY  ...",
      "classes": [
        "ControlType",
        "ExpectedBehavior",
        "NegativeControlResult",
        "NegativeControlSuite",
        "WithWithoutResult"
      ],
      "functions": [
        "scramble_payload",
        "scramble_packet",
        "perturb_spans",
        "perturb_packet_spans",
        "remove_support",
        "remove_packet_support",
        "run_projection_robustness_controls",
        "run_consumer_signal_controls",
        "run_negative_controls",
        "run_with_without_experiment"
      ],
      "imports": [
        "copy",
        "random",
        "dataclasses",
        "enum",
        "typing",
        "core.memory.claim",
        "core.memory.packet"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.353514",
        "modified": "2026-01-22T16:54:03.353659",
        "modified_days_ago": 29,
        "lines": 658,
        "size_bytes": 23573,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/text_packet_consumer.py",
      "name": "text_packet_consumer.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Decision Packet Consumer V1\n\nA deterministic consumer for DecisionPacket that enables meaningful\nnegative control experiments.\n\nNegative controls only become meaningful when the metric is downstream\nbehavior, not projection-internal metrics like claim count.",
      "classes": [
        "QueryIntentType",
        "QueryIntent",
        "SliceSelection",
        "ConsumerResult",
        "DecisionPacketConsumerV1",
        "ConsumerMetrics",
        "GoldSlice",
        "GoldSet"
      ],
      "functions": [
        "compute_slot_relevance",
        "create_consumer_metric_fn"
      ],
      "imports": [
        "dataclasses",
        "enum",
        "typing",
        "core.memory.claim",
        "core.memory.packet"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.353715",
        "modified": "2026-01-22T16:54:03.353943",
        "modified_days_ago": 29,
        "lines": 372,
        "size_bytes": 12300,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/text_projection_report.py",
      "name": "text_projection_report.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"generate\",\"create\",\"verify\",\"compute\",\"audit\",\"include\",\"exclude\",\"test\",\"validate\",\"ensure\",\"deterministic\",\"replicate\",\"invariant\",\"test\",\"exclude\",\"simplify\",\"test\",\"precise\",\"prove\",\"verify\",\"exclude\",\"validate\",\"certify\",\"strict\",\"check\",\"maintain\",\"generate\",\"filter\",\"test\",\"exclude\",\"sign\",\"apply\",\"verify\",\"interpret\",\"heres\",\"strict\",\"provenance\",\"enhance\",\"check\",\"exclude\",\"ensure\",\"instruct\",\"verify\",\"maintain\",\"check\",\"instruct\",\"interpret\",\"test\",\"extra\",\"exclude\",\"reinvariant\",\"co...",
      "classes": [
        "QualifierDigestPolicy",
        "SupportResolutionState",
        "SupportResolution",
        "CollisionReport",
        "CoverageStats",
        "HoleSafetyResult",
        "ProjectionInvariantsV1",
        "SWMTextProjectionReportV1"
      ],
      "functions": [
        "compute_projection_digest",
        "compute_packet_digest",
        "resolve_support_ref",
        "detect_claim_collisions",
        "compute_coverage_stats",
        "check_hole_safety",
        "generate_projection_report"
      ],
      "imports": [
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing",
        "core.memory.claim",
        "core.memory.packet",
        "core.memory.text_claims"
      ],
      "constants": [
        "QUALIFIER_DIGEST_POLICY",
        "QUALIFIER_WHITELIST"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.353980",
        "modified": "2026-01-22T16:54:03.354132",
        "modified_days_ago": 29,
        "lines": 710,
        "size_bytes": 24964,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/tool_loops.py",
      "name": "tool_loops.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "{\"description\":\"Tool loops implement the operator in MOC: provides is data, prove,  verify,  data structure\nReturn (the  (sha256, in MRCRig (sha256, base: 1.2.1\n  return_0.0.0\n  return (base, check_1.1\n  return (shard,  verify | 1.3.0  return 0 (code.0.0 data\n 0.0 (shard)\n  == claims.1\n  == claims in L2 code  stard\n  == 0.0 (sh  data\n  == 0  (structure)\n  == Pure state_ from * 3.0 (abstract) for 2.0 (common table\n  == interface table ID  from 3.0 type\n 1",
      "classes": [
        "ToolCompleteness",
        "ToolSpec",
        "ToolInvocationV1",
        "ToolObservation",
        "NormalizationRulesetV1",
        "ToolOutputArtifactV1",
        "ToolObservationStore",
        "RecheckAction",
        "HandoverSummary",
        "PacketDiagnostics",
        "ToolFailureReason"
      ],
      "functions": [
        "register_normalization_ruleset",
        "get_normalization_ruleset",
        "normalize_observation_data",
        "load_tool_output",
        "_compute_json_depth",
        "create_tool_invocation",
        "create_tool_observation",
        "create_tool_metadata_qualifier",
        "check_claim_staleness",
        "check_registry_freshness"
      ],
      "imports": [
        "__future__",
        "enum",
        "math",
        "unicodedata",
        "dataclasses",
        "pathlib",
        "typing",
        "core.memory.canonical",
        "core.memory.certification"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 913,
            "content": "# TODO: Remove frozen dataclass workaround for content hash computation",
            "file_path": "core/memory/tool_loops.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-22T12:30:06.278489",
        "modified": "2026-01-22T07:53:46.530793",
        "modified_days_ago": 29,
        "lines": 1504,
        "size_bytes": 56585,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "memory/verifier.py",
      "name": "verifier.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "M4-M5 Phase 6: Offline Verifier (Public Facade)\n\nThis module provides the public API for the offline verifier.\nThe implementation has been split into:\n- verifier_types.py: Core data structures, enums, and constants.\n- verifier_io.py: Low-level I/O and artifact loading primitives.\n- verifier_engine.py: High-level verification logic and orchestrators.",
      "classes": [],
      "functions": [],
      "imports": [
        "logging",
        "core.memory.verifier_engine",
        "core.memory.verifier_io",
        "core.memory.verifier_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.770723",
        "modified": "2026-01-23T10:38:57.680012",
        "modified_days_ago": 28,
        "lines": 169,
        "size_bytes": 4579,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/verifier_engine.py",
      "name": "verifier_engine.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Verification Engine and Orchestration for the Sterling Offline Verifier.",
      "classes": [
        "ReportVerificationResult"
      ],
      "functions": [
        "extract_hash_value",
        "normalize_hash",
        "verify_schema_closure_hash",
        "compare_hash",
        "compare_dict_counts",
        "create_envelope_ref",
        "verify_schema_id",
        "verify_canonical_bytes",
        "check_hash_ruleset_match",
        "check_replay_prerequisites"
      ],
      "imports": [
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.canonicalization.hashes",
        "core.memory.abstractions",
        "core.memory.anchors",
        "core.memory.canonical",
        "core.memory.claim"
      ],
      "constants": [
        "T"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-22T13:12:17.730033",
        "modified": "2026-02-22T13:12:17.730454",
        "modified_days_ago": 1,
        "lines": 2607,
        "size_bytes": 96859,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/verifier_io.py",
      "name": "verifier_io.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Provides I/O and artifact loading primitives for the Sterling Offline Verifier, including bytes loading with transport hash checks and resolution of artifact references within a structured memory schema.",
      "classes": [
        "BytesInfo"
      ],
      "functions": [
        "get_max_bytes_for_schema",
        "resolve_ref_path",
        "canonical_path_for_artifact",
        "_artifact_ref_with_canonical_path",
        "hash_bytes",
        "load_bytes_at_path",
        "find_artifact_by_hash",
        "verify_canonical_path",
        "_load_artifact_bytes_unverified",
        "check_json_depth"
      ],
      "imports": [
        "hashlib",
        "json",
        "logging",
        "pathlib",
        "typing",
        "core.memory.certification",
        "core.memory.verifier_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.771106",
        "modified": "2026-01-22T07:53:46.530989",
        "modified_days_ago": 29,
        "lines": 308,
        "size_bytes": 10602,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "memory/verifier_types.py",
      "name": "verifier_types.py",
      "category": "Memory and concept storage systems",
      "status": "active",
      "description": "Defines typed references and verification data structures for artifact envelopes and load results in Sterling's offline verifier. Ensures EnvelopeRef is validated for canonical hash format and content hash handling. ArtifactLoadResult records parsed artifacts with integrity checks and structured issues.",
      "classes": [
        "VerificationMode",
        "VerificationLevel",
        "ArtifactBytes",
        "VerifyIssue",
        "ForensicsMetadata",
        "EnvelopeRef",
        "ArtifactEnvelope",
        "ArtifactLoadResult",
        "RebuildResult",
        "ReportVerificationResult",
        "SalvageAction",
        "SalvageActionsRegistry",
        "VerificationResult"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [
        "T",
        "MAX_ARTIFACT_BYTES_DEFAULT",
        "FORENSICS_ABSOLUTE_MAX_BYTES",
        "MAX_JSON_DEPTH"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.771257",
        "modified": "2026-01-22T07:53:46.530857",
        "modified_days_ago": 29,
        "lines": 313,
        "size_bytes": 9416,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operator_masking.py",
      "name": "operator_masking.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\": \"Operator masking for both (optional) and (constrained) vocab (set of e.g. operator\n    from kg (path) at each node. The operator\n    \"\"\" looks a bit\n    for conjoined model\n    in (class) with\n    \"\"\"  (operator.  returns\n    the  operator\\\\\n    types as text.  class with\n    \"\"\"  returns\n    the operator\n\"\"\"  returns the  mask and  operator\n\"\"\"  returns the  operator\n\"\"\"  (operator and  looks for  at each  node.",
      "classes": [
        "OperatorMaskBuilder",
        "BenchmarkIntegrityError"
      ],
      "functions": [
        "load_operator_vocab",
        "verify_vocab_hash",
        "apply_operator_mask",
        "apply_operator_prior",
        "renormalize_teacher_probs",
        "validate_gold_in_mask",
        "build_batch_masks",
        "build_batch_operator_counts",
        "compute_mask_baseline_accuracy",
        "compute_masked_entropy"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "pathlib",
        "typing",
        "torch",
        "torch"
      ],
      "constants": [
        "OPERATOR_VOCAB_V9",
        "WORDNET_RELATION_OPS",
        "WORDNET_NAVIGATION_OPS",
        "WORDNET_ALL_OPS",
        "EDGE_TYPE_TO_OPERATOR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-15T20:27:47.061925",
        "modified": "2026-01-22T07:53:46.006687",
        "modified_days_ago": 29,
        "lines": 927,
        "size_bytes": 30013,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/__init__.py",
      "name": "__init__.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Sterling Operator Calculus.\n\nThis package implements the operator signature system and predicate vocabulary\nfor Sterling's typed operator calculus. Per Commitment 4, operator signatures\nare enforceable contracts, not just documentation.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "registry",
        "registry_profiles"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T12:46:10.860870",
        "modified": "2026-01-22T07:53:46.525973",
        "modified_days_ago": 29,
        "lines": 48,
        "size_bytes": 1187,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/bundle.py",
      "name": "bundle.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "CertifiedOperatorBundle: K6-B portable export/verify/install workflow.\n\nK6-B Goal: Enable offline verification and distribution of certified operators\nthrough a self-contained bundle format.",
      "classes": [
        "BundleVerificationError",
        "BundleInstallError",
        "BundleExportError",
        "BundleErrorSeverity",
        "BundleError",
        "BundleVerificationResult",
        "BundleManifest",
        "BundleOperatorEntry",
        "BundleCertificateEntry",
        "BundleClosureEntry",
        "CertifiedOperatorBundle"
      ],
      "functions": [
        "bundle_export",
        "bundle_verify",
        "bundle_install",
        "_compute_content_hash",
        "_load_certificate",
        "_load_closure",
        "_install_operator_to_store"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.771446",
        "modified": "2026-01-22T07:53:46.507364",
        "modified_days_ago": 30,
        "lines": 811,
        "size_bytes": 28815,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/bundle_schemas.py",
      "name": "bundle_schemas.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"Bundle Schemas define operator entries (operator_name, operator_ hash, category, family_tag, worlds, operator references, closure reference, cert_ required, dev_ optional\n",
      "classes": [
        "BundleOperatorEntry",
        "BundleCertificateEntry",
        "CertifiedBundleManifest",
        "DevBundleManifest",
        "CertifiedOperatorBundle",
        "DevOperatorBundle",
        "BundleInstallError",
        "BundleTypeError"
      ],
      "functions": [
        "is_certified_bundle",
        "is_dev_bundle",
        "load_bundle",
        "bundle_install_certified"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.canonicalization"
      ],
      "constants": [
        "CERTIFIED_BUNDLE_SCHEMA_ID",
        "DEV_BUNDLE_SCHEMA_ID"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T12:35:22.637479",
        "modified": "2026-01-22T07:53:46.510165",
        "modified_days_ago": 29,
        "lines": 547,
        "size_bytes": 18080,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/canonicalization.py",
      "name": "canonicalization.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Enforces deterministic serialization by excluding non-semantic metadata (no timestamps, no floats). Serializes state to a hashable representation using specified ordering, escaping, and Unicode normalization. Used for MOC hashing and verification.",
      "classes": [
        "CanonicalizationProfileV1",
        "SemanticRecord",
        "MonotonicCounter",
        "OperatorApplicationSemanticRecord"
      ],
      "functions": [
        "assert_no_floats",
        "assert_no_timestamps"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "CANON_V1"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T12:29:07.258741",
        "modified": "2026-01-22T07:53:46.527769",
        "modified_days_ago": 29,
        "lines": 401,
        "size_bytes": 12883,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/certified_bundle.py",
      "name": "certified_bundle.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Verified operator bundle containing canonical semantic artifacts and references. Audit metadata separated from bundle for non-deterministic checks. Loader validates bundle hashes before installation.",
      "classes": [
        "VerificationAudit",
        "VerifiedCertifiedOperatorBundle",
        "VerificationResult",
        "InstallBatchResult",
        "LoadRegistryResult"
      ],
      "functions": [
        "_infer_category",
        "_infer_layers",
        "_infer_scope"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:15.397458",
        "modified": "2026-01-27T07:17:15.397579",
        "modified_days_ago": 24,
        "lines": 506,
        "size_bytes": 18019,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/certified_loader.py",
      "name": "certified_loader.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"CertifiedOperatorLoader loads verified operators from certified store, policy enforces operator_allowlist checks during load (file_ and _deterministic_ ordering via certificate_ id enforcement\n    ",
      "classes": [
        "CertifiedOperatorLoader"
      ],
      "functions": [
        "build_staging_baseline_registry"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "typing",
        "core.induction.closure_allowlist",
        "core.operators.certified_bundle",
        "core.operators.certified_store",
        "core.operators.promotion_policy",
        "core.proofs.td12_ms_certificate"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:00:59.169683",
        "modified": "2026-01-25T20:00:59.169820",
        "modified_days_ago": 26,
        "lines": 1181,
        "size_bytes": 51372,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/certified_store.py",
      "name": "certified_store.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"Certified OperatorStore: Immutable index for certified operator sketches. Verification is explicit and enforced at access. Artifacts are write-once. Applicability decisions are deferred; store does not decide. Revocation state is observed via certificate. Immutable artifacts and verification.",
      "classes": [
        "VerificationState",
        "RevocationRecord",
        "RevocationResult",
        "OperatorDependency",
        "CertifiedIndexEntry",
        "CertifiedOperatorStore"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing",
        "core.operators.promotion_policy"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T10:00:35.609126",
        "modified": "2026-01-22T07:53:46.507288",
        "modified_days_ago": 29,
        "lines": 1160,
        "size_bytes": 44730,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/contract.py",
      "name": "contract.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Provides the generic import path for the evidence contract. Re-exports OperatorContractV1 implementation to prevent import fragmentation across Sterling's components.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.operators.evidence_contract"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.440472",
        "modified": "2026-02-19T09:08:21.440960",
        "modified_days_ago": 1,
        "lines": 17,
        "size_bytes": 622,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/effects.py",
      "name": "effects.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Effect IDs and registry.\n\nCanonical, versioned effect identifiers mirror precondition handling to avoid\ndict-based extension as the long-term mechanism.",
      "classes": [
        "EffectID",
        "EffectResolutionMode",
        "EffectAssertion",
        "EffectNotFoundError",
        "EffectRegistry"
      ],
      "functions": [
        "record_effect_fallback",
        "get_effect_fallback_counts",
        "_syntax_modified",
        "_semantics_modified",
        "_polarity_flipped",
        "_sense_resolved",
        "_entity_activated",
        "register_standard_effects",
        "canonicalize_effect_id"
      ],
      "imports": [
        "__future__",
        "logging",
        "collections",
        "dataclasses",
        "enum",
        "types",
        "typing"
      ],
      "constants": [
        "_EFFECT_FALLBACK_COUNTER",
        "SYNTAX_MODIFIED",
        "SEMANTICS_MODIFIED",
        "POLARITY_FLIPPED",
        "SENSE_RESOLVED",
        "ENTITY_ACTIVATED"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T09:41:33.647193",
        "modified": "2026-01-22T07:53:46.507336",
        "modified_days_ago": 30,
        "lines": 265,
        "size_bytes": 8337,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/episode_chain.py",
      "name": "episode_chain.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\" episodeHash\":\"...\",\"preimage\":\"...\",\"hash\":\"...\",\"url\":\"...\",\"blockhashes\":\"...\",\"parent_hash\":\"...\",\"proof\":\"...\",\"previous\":\"IP [0] (if A) common. The episode hash \u2192 episode hash (common. hash of all operator inputs.  / hash tree\n    (A hash n \u2192 hash B\n    merkle tree\n    common. hash\n",
      "classes": [
        "EpisodeHashError",
        "BatchCertificationError",
        "ProvenanceQueryError",
        "EpisodeHashRecord",
        "MerkleNode",
        "BatchCertificate",
        "EpisodeProvenanceIndex",
        "CertificateChain"
      ],
      "functions": [
        "compute_episode_hash",
        "compute_merkle_root",
        "create_batch_certificate",
        "verify_batch_certificate"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T07:24:56.974566",
        "modified": "2026-01-22T07:53:46.510115",
        "modified_days_ago": 29,
        "lines": 621,
        "size_bytes": 21848,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/errors.py",
      "name": "errors.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Provides shared error types for the operator system. Sprint 2 introduces consolidated error classes for governance enforcement.",
      "classes": [
        "EvaluationModeViolation",
        "PromotionGateViolation",
        "CertificateVerificationError",
        "RegistryInstallError",
        "RegistryLoadError"
      ],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T03:07:56.470794",
        "modified": "2026-01-22T07:53:46.507206",
        "modified_days_ago": 29,
        "lines": 83,
        "size_bytes": 2362,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/evidence_contract.py",
      "name": "evidence_contract.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Declares an operator's identity, version, and behavioral contract for step-level evidence binding. Contract digest is included in StepWitnessV1 to detect operator drift. Distinct from registry contracts used for planning semantics.",
      "classes": [
        "OperatorContractV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_CONTRACT_HASH_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.441000",
        "modified": "2026-02-19T09:08:21.441481",
        "modified_days_ago": 1,
        "lines": 86,
        "size_bytes": 3269,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/execution_attestation.py",
      "name": "execution_attestation.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Executes verification of IR against a domain and produces a hash-based attestation.",
      "classes": [
        "CapabilityScope",
        "CapabilityGrant",
        "AttestationError",
        "ExecutionAttestation"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.domains.action_surface",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "ATTESTATION_VERSION",
        "CERTIFYING_POLICY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:15.666032",
        "modified": "2026-01-27T07:17:15.667660",
        "modified_days_ago": 24,
        "lines": 296,
        "size_bytes": 10252,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/execution_context.py",
      "name": "execution_context.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "GovernanceContext provides immutable context for sealed operator application within Sterling's engine. It contains a universe snapshot and gate factory for runtime enforcement. Evaluation mode is set externally via engine configuration. It integrates with ExecutionContext to enable K6-A governance checks.",
      "classes": [
        "GovernanceContext",
        "ExecutionContextBuilder"
      ],
      "functions": [
        "is_certifying",
        "create_execution_context"
      ],
      "imports": [
        "__future__",
        "inspect",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.pn.linguistics"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T20:13:50.829967",
        "modified": "2026-01-24T20:13:50.830264",
        "modified_days_ago": 27,
        "lines": 577,
        "size_bytes": 24026,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/fence.py",
      "name": "fence.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Apply operator allowlist enforcement (E3). Only allowed operators may execute; others are rejected (STRICT or dropped (STRICT-with-drop). Traced operator ids post-run.",
      "classes": [
        "ApplyFence",
        "OperatorNotAllowedError",
        "ApplyFenceMissingError"
      ],
      "functions": [
        "create_no_fence",
        "create_fence"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.reasoning.transactional_apply"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:51:23.546573",
        "modified": "2026-01-22T07:53:46.526010",
        "modified_days_ago": 29,
        "lines": 189,
        "size_bytes": 6755,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/gate.py",
      "name": "gate.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "OperatorGate: Unforgeable capability for operator application.\n\nThis is the mechanical seal that enforces K6-A boundaries.",
      "classes": [
        "GatePayload",
        "OperatorGate",
        "GateVerificationReceipt",
        "OperatorGateError",
        "InvalidGateError",
        "GateScopeMismatchError",
        "OperatorNotApplicableError",
        "OperatorNotInUniverseError",
        "GateProcessMismatchError",
        "GateFactory"
      ],
      "functions": [
        "gated_apply",
        "_get_process_id"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "hmac",
        "secrets",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.354257",
        "modified": "2026-01-22T16:54:03.354446",
        "modified_days_ago": 29,
        "lines": 593,
        "size_bytes": 22468,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/governance_runtime.py",
      "name": "governance_runtime.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "GovernanceRuntime provides episode-scoped runtime state for governance. It exposes a mandatory application_sink for OperatorApplication and provides get_next_commit_index and related methods to track governance steps, enforcing immutability of governance facts via K7 (immutable GovernanceContext) while allowing mutable runtime state in ExecutionContext.",
      "classes": [
        "GovernanceRuntimeProtocol",
        "NoApplyGovernanceRuntimeError",
        "GovernanceRuntime",
        "NoApplyGovernanceRuntime"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 115,
            "content": "# Get step index for gate creation (K7 TODO #2)",
            "file_path": "core/operators/governance_runtime.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T09:15:56.465203",
        "modified": "2026-01-23T09:15:56.465323",
        "modified_days_ago": 28,
        "lines": 320,
        "size_bytes": 11047,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/inventory.py",
      "name": "inventory.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Operator Inventory: Canonical operator registry artifact and validation.\n\nThis module provides:\n1. Inventory generation from OperatorRegistry\n2. Inventory serialization to/from JSON\n3. Operator ID validation (unknown operator_id = deterministic failure)\n4.",
      "classes": [
        "UnknownOperatorError",
        "OperatorNotInWorldError",
        "OperatorEntry",
        "OperatorInventory"
      ],
      "functions": [
        "generate_inventory_from_registry",
        "get_global_inventory",
        "reset_global_inventory",
        "validate_operator_id",
        "is_valid_operator_id",
        "list_operators_for_world",
        "list_fallback_operators_for_world"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-08T19:41:06.750520",
        "modified": "2026-01-22T07:53:46.507164",
        "modified_days_ago": 30,
        "lines": 575,
        "size_bytes": 19589,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "operators/operator_ir_v1.py",
      "name": "operator_ir_v1.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Operator IR V1: Typed IR for Synthesized Operators.\n\nDefines the intermediate representation for operators synthesized from sketches.\nOperators are bound to DomainSpecs and verified against action surfaces.",
      "classes": [
        "PreconditionType",
        "EffectType",
        "PreconditionIR",
        "EffectIR",
        "ActionSurfaceSubset",
        "OperatorIRV1"
      ],
      "functions": [
        "create_operator_ir_from_synthesis"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.domains.action_surface",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-01-27T07:16:29.341733",
        "modified": "2026-01-27T07:16:29.341861",
        "modified_days_ago": 25,
        "lines": 526,
        "size_bytes": 18835,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/operator_ir_verifier.py",
      "name": "operator_ir_verifier.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\": \"Validates operator IR against ActionSurface in domain spec. Enforces all operators in allowed set for each domain\nReturns true if no violations. Else, returns false, with Violation details. \n  V-1: access check, V-2 type checks. \nV per op. domain: if V-3 check. each op. type inherits from We check_ (optional/safe check, inherits from Violation (optional)\nV4. Each node or field write check, inclusive, but not inclusive per node.",
      "classes": [
        "ViolationType",
        "ViolationSeverity",
        "VerificationViolation",
        "VerificationResult",
        "OperatorIRVerifier",
        "VerificationError"
      ],
      "functions": [
        "verify_operator_ir",
        "verify_and_raise"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.domains.action_surface",
        "core.domains.domain_spec_v1",
        "core.governance.run_intent",
        "core.operators.operator_ir_v1",
        "core.verification.hash_utils"
      ],
      "constants": [
        "NON_DETERMINISTIC_FIELDS",
        "NON_DETERMINISTIC_NAMESPACES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:29.185899",
        "modified": "2026-01-27T07:16:29.186045",
        "modified_days_ago": 24,
        "lines": 965,
        "size_bytes": 34541,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/pn/__init__.py",
      "name": "__init__.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.operators.pn.linguistics"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T14:14:13.237705",
        "modified": "2026-01-21T11:07:23.559639",
        "modified_days_ago": 33,
        "lines": 57,
        "size_bytes": 1569,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/pn/linguistics.py",
      "name": "linguistics.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\": \"Provides language pack selection and analysis helpers for fail-closed K-ON: PnLanguagePack (linguistic) analysis to select pack per syntax role (function and feature) tags from a text [a] the class of the language feature\n# to determine required pack for the language of the operator pack requires @ syntax analysis to determine pack compatibility\n#  Language: requires MAND: Language daT A0 a language identifier\n# to determine required/optional features\n# to determine missing: PN...",
      "classes": [
        "PnLanguagePackResolutionError",
        "PnLanguageResolutionMode",
        "LanguagePackID",
        "SurfaceEditKind",
        "LinguisticFeatureKey",
        "LinguisticAmbiguity",
        "SurfaceEdit",
        "SurfaceForm",
        "SurfaceEdits",
        "FeatureSpan",
        "LinguisticAnalysis",
        "PnLanguagePack",
        "PnEnglishLanguagePack",
        "PnLanguagePackRegistry"
      ],
      "functions": [
        "record_language_fallback",
        "get_language_fallback_counts",
        "reset_language_fallback_counts",
        "get_syntax_tokens",
        "get_language_code",
        "get_language_resolution_mode",
        "_should_expand_copula_s",
        "_analysis_has_feature",
        "_analysis_for_state",
        "_get_registry_from_state"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "collections",
        "dataclasses",
        "enum",
        "pathlib",
        "types",
        "typing"
      ],
      "constants": [
        "PN_LANGPACK_MISSING_REGISTRY_STRICT",
        "PN_LANGPACK_NOT_FOUND_STRICT",
        "_LANGUAGE_FALLBACK_COUNTER"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-10T11:29:25.240628",
        "modified": "2026-02-17T10:09:41.668826",
        "modified_days_ago": 3,
        "lines": 1040,
        "size_bytes": 38905,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/pn/operators.py",
      "name": "operators.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "PN operator implementations with domain-specific logic and language pack validation.",
      "classes": [],
      "functions": [
        "_log_pn_operator_probe",
        "_attach_operator_metadata",
        "apply_expand_contraction"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.operators.pn.linguistics"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T09:37:00.040616",
        "modified": "2026-01-22T07:53:46.526114",
        "modified_days_ago": 29,
        "lines": 123,
        "size_bytes": 3942,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/preconditions.py",
      "name": "preconditions.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"Versioned, stable precondition identifiers. Registry maps versioned precondition callables.",
      "classes": [
        "PreconditionID",
        "PreconditionNotFoundError",
        "PreconditionVersionMismatchError",
        "PreconditionRegistry"
      ],
      "functions": [
        "record_precondition_fallback",
        "get_precondition_fallback_counts",
        "_make_precond_id",
        "canonicalize_precondition_id",
        "register_standard_preconditions",
        "register_registry_preconditions",
        "compose_and",
        "compose_or"
      ],
      "imports": [
        "__future__",
        "inspect",
        "logging",
        "collections",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_PRECOND_FALLBACK_COUNTER",
        "STERLING_PRECOND_NS",
        "PRECOND_HAS_SEMANTICS",
        "PRECOND_HAS_KG_NODE",
        "PRECOND_HAS_UTTERANCE",
        "PRECOND_HAS_WORLD_STATE",
        "PRECOND_HAS_SYNTAX",
        "PRECOND_HAS_PRAGMATICS",
        "PRECOND_IS_TERMINAL",
        "PRECOND_NOT_TERMINAL"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T13:52:27.345095",
        "modified": "2026-01-22T07:53:46.507177",
        "modified_days_ago": 29,
        "lines": 498,
        "size_bytes": 15938,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/promoted_operator.py",
      "name": "promoted_operator.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"Promoted operator from synthesis.  Includes  operator+  runtime  and provenance proofs of  execution.  matches  the  operator  execution with  provenance\n",
      "classes": [
        "CommittedPayload",
        "ProvenanceBinding",
        "PromotedOperatorIR"
      ],
      "functions": [
        "create_promoted_operator_from_synthesis"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T10:01:42.134530",
        "modified": "2026-01-22T07:53:46.525991",
        "modified_days_ago": 29,
        "lines": 414,
        "size_bytes": 13706,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/promotion_policy.py",
      "name": "promotion_policy.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "PromotionPolicy defines tier thresholds for operator sketch promotion. It embeds policy-driven thresholds in certificates for auditability (Footgun H Fix).",
      "classes": [
        "PromotionPolicy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T01:13:36.148582",
        "modified": "2026-01-22T07:53:46.526063",
        "modified_days_ago": 29,
        "lines": 356,
        "size_bytes": 16839,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/promotion_service.py",
      "name": "promotion_service.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Promotion Service: Orchestrates tier transitions for operator sketches.\n\nFOOTGUN #3 FIX: Promotion is not the registry's job.",
      "classes": [
        "PromotionWriteMode",
        "PromotionArtifacts",
        "PromotionFailureV1",
        "PromotionResult",
        "PromotionEvent",
        "CertificatePromotionCheck",
        "PromotionService"
      ],
      "functions": [
        "check_certificate_promotable"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.operators.certified_store",
        "core.operators.errors"
      ],
      "constants": [
        "PROMOTABLE_CERTIFICATE_KINDS",
        "NON_PROMOTABLE_CERTIFICATE_KINDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T20:00:18.410197",
        "modified": "2026-02-17T10:09:41.575853",
        "modified_days_ago": 4,
        "lines": 1691,
        "size_bytes": 74134,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/promotion_token.py",
      "name": "promotion_token.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "PromotionToken: Secure, minted tokens for production writes, created only by PromotionService. Used to gate certified writes in the MOC.",
      "classes": [
        "PromotionToken"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "uuid",
        "dataclasses"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-26T23:45:59.184476",
        "modified": "2026-01-22T07:53:46.510131",
        "modified_days_ago": 29,
        "lines": 87,
        "size_bytes": 2792,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/registry.py",
      "name": "registry.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Provides access to the Sterling Operator Registry facade. Exports registry types, store, and resolve modules ensuring backward compatibility for public operators.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.operators.effects",
        "core.operators.registry_resolve",
        "core.operators.registry_store",
        "core.operators.registry_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.772089",
        "modified": "2026-01-23T11:03:15.173320",
        "modified_days_ago": 28,
        "lines": 115,
        "size_bytes": 3184,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/registry_profiles.py",
      "name": "registry_profiles.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Registry profiles map task types to named operator packs, enabling correct OperatorRegistry construction to avoid empty registry failures. Profiles are explicit, scenario-driven, and can be pinned for replayability. Core remains agnostic; profiles reside in core but are task-specific.",
      "classes": [],
      "functions": [
        "register_profile",
        "get_profile",
        "create_registry_from_profile",
        "get_default_profile_for_task",
        "create_registry_for_task",
        "_get_current_synset",
        "_set_wordnet_focus",
        "_derive_child_node_id",
        "_spawn_successor_state",
        "make_wordnet_operator"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.registry"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:51:23.546782",
        "modified": "2026-01-22T07:53:46.507297",
        "modified_days_ago": 29,
        "lines": 450,
        "size_bytes": 14015,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/registry_protocol.py",
      "name": "registry_protocol.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Defines the governance-approved set of registry operations for search and apply code. Only approved methods are accessible via implementing classes. Ensures type safety and prevents unauthorized operator use.",
      "classes": [
        "RegistryProtocol"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T16:10:49.904782",
        "modified": "2026-01-21T11:21:45.570797",
        "modified_days_ago": 30,
        "lines": 145,
        "size_bytes": 4924,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/registry_resolve.py",
      "name": "registry_resolve.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Resolves operator preconditions and effects using typed predicates and implementations; validates operator signatures against state and context.",
      "classes": [],
      "functions": [
        "_call_precondition_predicate",
        "_call_operator_impl",
        "_has_predication",
        "_has_ambiguous_term",
        "_has_entity_reference",
        "_has_negation",
        "_is_identity_pn",
        "_has_symbol_reference",
        "_has_extractable_block",
        "_has_inlineable_variable"
      ],
      "imports": [
        "__future__",
        "inspect",
        "logging",
        "copy",
        "typing",
        "core.operators.registry_types",
        "core.operators.registry_types"
      ],
      "constants": [
        "HAS_SYNTAX",
        "HAS_SEMANTICS",
        "HAS_SEMIOTICS",
        "HAS_PRAGMATICS",
        "HAS_LATENT",
        "HAS_PREDICATION",
        "HAS_AMBIGUOUS_TERM",
        "HAS_ENTITY_REFERENCE",
        "HAS_NEGATION",
        "IS_IDENTITY_PN"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.354574",
        "modified": "2026-01-23T10:45:58.106114",
        "modified_days_ago": 28,
        "lines": 1332,
        "size_bytes": 47924,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/registry_store.py",
      "name": "registry_store.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "OperatorRegistry stores and manages certified operator signatures and implementations for Sterling, enabling only verified operators to be executed.",
      "classes": [
        "OperatorRegistry"
      ],
      "functions": [
        "iter_builtin_operator_entries",
        "create_default_registry",
        "register_operators_in_labelspace"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "typing",
        "core.operators.registry_resolve",
        "core.operators.registry_resolve",
        "core.operators.registry_types",
        "core.optimization.applicability_index"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T02:04:57.246455",
        "modified": "2026-01-25T02:04:57.246781",
        "modified_days_ago": 26,
        "lines": 764,
        "size_bytes": 29648,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/registry_types.py",
      "name": "registry_types.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Defines exceptions for operator registry validation and provides typed, constrained operator signatures with scope and identity attributes for governance and execution.",
      "classes": [
        "OperatorContractViolation",
        "OperatorNotFoundError",
        "OperatorArgsError",
        "RegistryDriftError",
        "RegistryMutationError",
        "EnforcementMode",
        "PreconditionResolutionMode",
        "EffectResolutionMode",
        "OperatorCategory",
        "OperatorScope",
        "RegistrySnapshot",
        "OperatorCall",
        "ParamSpec",
        "LabelConstraints",
        "Precondition",
        "OperatorSignature",
        "OperatorImpl"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T02:04:47.045186",
        "modified": "2026-01-25T02:04:47.045438",
        "modified_days_ago": 26,
        "lines": 463,
        "size_bytes": 15436,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "operators/registry_view.py",
      "name": "registry_view.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Restricts access to the operator registry, exposing only applicable operators when governance is enabled. Bypass attempts are prevented via method access control and no downcasting to the full registry.",
      "classes": [
        "RegistryBypassError",
        "GovernedRegistryView"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T15:49:25.981755",
        "modified": "2026-01-21T11:07:23.537490",
        "modified_days_ago": 30,
        "lines": 205,
        "size_bytes": 6942,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/scope_allowlist.py",
      "name": "scope_allowlist.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"MOCamlT from stereotyped_strat_type regi  #Duck  {  op. 5  d  e  G  e  s  t  a  C  h  i  s  e  x  a  c  e  t  only  i  n  a  t  y  e  s  e  t  y  e  g  r  a  t  e  x  a  s  (  e  t  y  s  (  e  x  a  s  (  e  x  a  t  e  x  a  t  e  s  (  e  x  a  t  e  s  t  y  e  g  e  x  a  t  e  x  a  t",
      "classes": [
        "ScopeOperatorRule"
      ],
      "functions": [
        "register_scope_rule",
        "get_scope_rule",
        "get_scope_excluded_operators",
        "get_scope_allowlist",
        "is_operator_allowed_for_scope",
        "filter_observations_by_scope_allowlist"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T00:30:34.222134",
        "modified": "2026-01-22T07:53:46.526026",
        "modified_days_ago": 29,
        "lines": 367,
        "size_bytes": 11880,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/shadow_store.py",
      "name": "shadow_store.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "ShadowOperatorStore manages mutable Tier0 operator sketches without making them applicable. It provides influence hints for reordering existing operators only, with evidence deduplication. Used to guide promotion via episode IDs when a sketch meets certification criteria.",
      "classes": [
        "InfluenceHint",
        "ShadowOperatorStore"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.promotion_policy",
        "core.operators.errors"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.207903",
        "modified": "2026-02-17T10:09:41.487035",
        "modified_days_ago": 3,
        "lines": 621,
        "size_bytes": 21059,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/text_semantic_ops.py",
      "name": "text_semantic_ops.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "Text semantic operators apply in certifying mode using DecisionPacket evidence; OperatorOutcome records state_node, semantic_delta, and witness_claim_ids for traceability.",
      "classes": [
        "OperatorFailedClosed",
        "OperatorOutcome"
      ],
      "functions": [
        "apply_negation_v2",
        "get_polarity_from_packet"
      ],
      "imports": [
        "dataclasses",
        "typing",
        "core.ir.semantic_delta_apply",
        "core.ir.semantic_delta_ir",
        "core.memory.packet",
        "core.memory.packet_query"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.355065",
        "modified": "2026-01-22T16:54:03.355243",
        "modified_days_ago": 29,
        "lines": 255,
        "size_bytes": 8230,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "operators/universe.py",
      "name": "universe.py",
      "category": "Operator registry, signatures, and certified loader",
      "status": "active",
      "description": "{\"description\":\"OperatorUniverse and ApplicableOperatorSet provide sealed runtime interfaces for legal operator selection. It verifies operator applicability via universe_hash and category checks. It guards against universe modification. Operator entries are immutable and hashable. It records operator identity and context. It excludes shadow operators from Applicable set.",
      "classes": [
        "UniverseImmutabilityViolation",
        "UniverseMismatchError",
        "OperatorUniverseEntry",
        "OperatorUniverse",
        "ApplicableOperatorSet"
      ],
      "functions": [
        "_compute_signature_hash",
        "_compute_universe_hash",
        "_sketch_to_universe_entry"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.contracts.operator_application"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T07:08:48.475950",
        "modified": "2026-01-22T07:53:46.507334",
        "modified_days_ago": 29,
        "lines": 555,
        "size_bytes": 20077,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "optimization/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Optimization utilities that preserve determinism and auditability.",
      "classes": [],
      "functions": [],
      "imports": [
        "quantization",
        "hashing",
        "cache",
        "applicability_index"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.684726",
        "modified": "2026-01-22T23:14:27.684927",
        "modified_days_ago": 29,
        "lines": 39,
        "size_bytes": 1229,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "optimization/applicability_index.py",
      "name": "applicability_index.py",
      "category": "Core module",
      "status": "active",
      "description": "Pre-computes a mapping of required layers to applicable operators for O(1) candidate filtering before full precondition checks. Implements conservative indexing (no false negatives), static build, deterministic ordering (sorted by operator name). Used in OPT-I4 optimization.",
      "classes": [
        "ApplicabilityIndex"
      ],
      "functions": [
        "extract_required_layers",
        "get_available_layers_from_state"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.684970",
        "modified": "2026-01-22T23:14:27.685363",
        "modified_days_ago": 29,
        "lines": 305,
        "size_bytes": 10258,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "optimization/cache.py",
      "name": "cache.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides thread-local LRU cache for deterministic memoization. Ensures each thread has its own cache, preserving computation order and purity. Disables cache on demand via CACHE DISABLED flag. Evicts by LRU when maxsize exceeded. Used for feature caching. Invariants enforced at runtime. Author: @darianrosebrook. Date: January 26.",
      "classes": [
        "CacheConfig",
        "CacheStats",
        "ThreadLocalCache"
      ],
      "functions": [
        "_is_cache_disabled",
        "_set_cache_disabled",
        "cache_disabled",
        "cache_enabled",
        "get_feature_cache",
        "reset_feature_cache"
      ],
      "imports": [
        "__future__",
        "threading",
        "collections",
        "contextlib",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "K",
        "V",
        "_CACHE_DISABLED"
      ],
      "decorators_used": [
        "contextmanager",
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.685415",
        "modified": "2026-01-22T23:14:27.685871",
        "modified_days_ago": 29,
        "lines": 325,
        "size_bytes": 9266,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "optimization/hashing.py",
      "name": "hashing.py",
      "category": "Core module",
      "status": "active",
      "description": "Domain-separated hashing utilities for deterministic cache keys.\n\nThis module provides versioned, domain-separated hashing to ensure cache keys\nare stable across versions and don't collide between different cache domains.\nFollows the pattern established in core/proofs/commitment_hash.py.",
      "classes": [
        "HashDomain"
      ],
      "functions": [
        "canonical_json_bytes",
        "domain_hash",
        "domain_hash_json",
        "feature_cache_key"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "enum",
        "typing"
      ],
      "constants": [
        "_CANONICAL_JSON_KWARGS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.582836",
        "modified": "2026-02-21T15:51:43.582962",
        "modified_days_ago": 0,
        "lines": 182,
        "size_bytes": 5884,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "optimization/quantization.py",
      "name": "quantization.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides functions to quantize floats to integers (milli, micro) for deterministic comparisons and caching.",
      "classes": [],
      "functions": [
        "quantize_float",
        "dequantize_float",
        "quantize_pair"
      ],
      "imports": [
        "__future__"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.686332",
        "modified": "2026-01-22T23:14:27.687009",
        "modified_days_ago": 29,
        "lines": 110,
        "size_bytes": 3299,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Optimality Oracles - Single Source of Truth.\n\nThis package provides canonical implementations of optimality oracles,\nsimulators, state extractors, and canonical policies for all domains.\n\n**Critical Invariant**: All oracle computation, simulation, and canonical\npolicy logic must be imported from this package. No duplicate implementations\nin scripts or evaluation code.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.oracles.code",
        "core.oracles.common",
        "core.oracles.dialogue"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:17:05.827101",
        "modified": "2026-01-21T11:21:45.578357",
        "modified_days_ago": 30,
        "lines": 59,
        "size_bytes": 1412,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Code Optimality Oracle - Single Source of Truth.\n\nThis package provides the canonical implementation of the Code optimality oracle,\nincluding scoring, simulation, state extraction, and canonical policy.\n\nAll Code oracle computation must import from this package.\nNo duplicate implementations in scripts or evaluation code.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.oracles.code.integration",
        "core.oracles.code.legality",
        "core.oracles.code.mask",
        "core.oracles.code.oracle",
        "core.oracles.code.reranker"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:22:15.122621",
        "modified": "2026-01-21T11:21:45.578480",
        "modified_days_ago": 30,
        "lines": 64,
        "size_bytes": 1629,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/integration.py",
      "name": "integration.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides functions to extract and validate CodeRefactoringGoal and CodeState from examples or StateNode. Includes deterministic operator simulation and jitter key generation for code slices.",
      "classes": [],
      "functions": [
        "build_code_goal",
        "extract_code_state",
        "_reconstruct_code_state",
        "_build_code_state_from_source",
        "simulate_code_operator",
        "build_code_jitter_key",
        "get_available_code_ops",
        "extract_code_state_from_state_node"
      ],
      "imports": [
        "__future__",
        "ast",
        "typing",
        "core.oracles.code.oracle",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:27:50.717754",
        "modified": "2026-01-21T11:21:45.579010",
        "modified_days_ago": 30,
        "lines": 308,
        "size_bytes": 10081,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/legality.py",
      "name": "legality.py",
      "category": "Core module",
      "status": "active",
      "description": "Code Operator Legality Predicate - Single Source of Truth.\n\nDefines one primitive predicate: `is_structurally_legal(state, op) -> bool`\nThis is used by both `get_available_ops` and mask builders to prevent drift.\n\n**Critical**: This is the single source of truth for Code operator legality.\nAll availability checks and mask building must use this predicate.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "is_structurally_legal",
        "get_available_code_ops",
        "build_code_mask_set"
      ],
      "imports": [
        "typing",
        "core.oracles.legality_common",
        "core.oracles.code.oracle"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T11:06:40.571517",
        "modified": "2026-02-21T10:47:11.793708",
        "modified_days_ago": 0,
        "lines": 83,
        "size_bytes": 2423,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/mask.py",
      "name": "mask.py",
      "category": "Core module",
      "status": "active",
      "description": "Builds operator masks using the unified legality predicate. Returns sets or bitsets instead of torch tensors to decouple from the training stack. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "build_code_mask"
      ],
      "imports": [
        "typing",
        "core.oracles.code.legality",
        "core.oracles.code.oracle"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T11:06:53.256090",
        "modified": "2026-01-21T11:21:45.579452",
        "modified_days_ago": 30,
        "lines": 33,
        "size_bytes": 1004,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/oracle.py",
      "name": "oracle.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"parameters\":{...,\"rank\":null,\"mappings\":null,\"missing\":null,\"garbage\":null,\"provenance\":null,\" annotated A\" which provides framework to get_ annotated A = { \"Thermodynamics\": \"Energy\" } , { \"Luminous\" and \"kernal\" quantifier\" { \"Exquad\" from \"gym\" , \"hodules\" and \"pass\" st'let' { \"arch\" from \"l\" i' note (a \"pass\" thresholds\n    (  threshold)\n    \"\"\" (1.",
      "classes": [
        "CheckTier",
        "CodeState",
        "CodeRefactoringGoal",
        "CodeScore"
      ],
      "functions": [
        "q100",
        "compute_task_progress",
        "get_check_tier",
        "score_code_transition",
        "compute_code_best_ops",
        "_get_component_name",
        "compute_code_provenance"
      ],
      "imports": [
        "__future__",
        "ast",
        "inspect",
        "dataclasses",
        "typing",
        "core.oracles.common",
        "core.oracles.provenance"
      ],
      "constants": [
        "CODE_PRIORITY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 238,
            "content": "# TODO: Verify expression substitution (AST diff check)",
            "file_path": "core/oracles/code/oracle.py"
          },
          {
            "line_number": 246,
            "content": "# TODO: Verify call-site replacement + no duplication",
            "file_path": "core/oracles/code/oracle.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:22:48.104403",
        "modified": "2026-01-21T11:21:45.579946",
        "modified_days_ago": 30,
        "lines": 458,
        "size_bytes": 14757,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/code/reranker.py",
      "name": "reranker.py",
      "category": "Core module",
      "status": "active",
      "description": "Reranks Top-K operators using deterministic policy scores at runtime. Does not accept best_ops since lacks oracle access. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "rerank_code_topk",
        "eval_rerank_any_best"
      ],
      "imports": [
        "typing",
        "core.oracles.code.integration",
        "core.oracles.code.oracle"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T11:07:18.936286",
        "modified": "2026-01-21T11:21:45.580371",
        "modified_days_ago": 30,
        "lines": 88,
        "size_bytes": 2638,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/common.py",
      "name": "common.py",
      "category": "Core module",
      "status": "active",
      "description": "Scaffolding for deterministic best_ops and canonical_op selection using SHA256 jitter and lexicographic comparison. Supports migration from scripts to core.oracles.common.",
      "classes": [],
      "functions": [
        "stable_jitter_index",
        "lexmax",
        "best_items_by_score",
        "canonical_from_best_ops"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:17:55.057172",
        "modified": "2026-01-21T11:21:45.580962",
        "modified_days_ago": 30,
        "lines": 103,
        "size_bytes": 3075,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dataset_manifest.py",
      "name": "dataset_manifest.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Enforces replayability by requiring a DatasetManifest with tracked hashes for oracles and simulators. Verifies governance by validating manifest before training. Prevents \"we can't reproduce\" failures through hash-based provenance.\"}",
      "classes": [
        "DatasetManifest"
      ],
      "functions": [
        "get_git_commit_hash",
        "compute_oracle_hash",
        "compute_simulator_hash",
        "save_manifest",
        "load_manifest",
        "validate_manifest_for_training"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "subprocess",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing",
        "core.operator_masking"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T12:58:29.430931",
        "modified": "2026-01-21T11:21:45.581957",
        "modified_days_ago": 30,
        "lines": 277,
        "size_bytes": 9900,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/decision_audit.py",
      "name": "decision_audit.py",
      "category": "Core module",
      "status": "active",
      "description": "Oracle Decision Audit Utilities.\n\nTracks which ScoreVector component first separated best vs runner-up,\nenabling detection of deterministic-but-wrong oracles.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "find_deciding_component",
        "audit_score_component_dominance"
      ],
      "imports": [
        "__future__",
        "collections",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:37:49.810477",
        "modified": "2026-01-21T11:21:45.582082",
        "modified_days_ago": 30,
        "lines": 154,
        "size_bytes": 5671,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Dialogue Optimality Oracle - Single Source of Truth.\n\nThis package provides the canonical implementation of the Dialogue optimality oracle,\nincluding scoring, simulation, state extraction, and canonical policy.\n\nAll Dialogue oracle computation must import from this package.\nNo duplicate implementations in scripts or evaluation code.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.oracles.dialogue.integration",
        "core.oracles.dialogue.legality",
        "core.oracles.dialogue.mask",
        "core.oracles.dialogue.oracle",
        "core.oracles.dialogue.reranker"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:21:26.079519",
        "modified": "2026-01-21T11:21:45.582514",
        "modified_days_ago": 30,
        "lines": 60,
        "size_bytes": 1687,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/features.py",
      "name": "features.py",
      "category": "Core module",
      "status": "active",
      "description": "Extracts policy-structural features from DialogueObservation and Goal; includes phase one-hot encoding and normalized turn/intent counts; text features are optional and diagnostic.",
      "classes": [
        "DialogueFeatureSchema",
        "DialogueFeatureVector"
      ],
      "functions": [
        "normalize_turn_count",
        "normalize_intent_count",
        "one_hot_phase",
        "extract_features_v1",
        "extract_features"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.oracles.dialogue.integration",
        "core.oracles.dialogue.oracle"
      ],
      "constants": [
        "FEATURE_SCHEMA_VERSION",
        "PHASE_ORDER",
        "PHASE_IDX",
        "SCHEMA_V1_FEATURE_NAMES",
        "SCHEMA_V1"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T09:42:53.925472",
        "modified": "2026-01-21T11:21:45.582941",
        "modified_days_ago": 30,
        "lines": 261,
        "size_bytes": 8491,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/integration.py",
      "name": "integration.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Provides functions to extract DialogueGoal and DialogueState from examples or StateNodes without leakage. Extracts structured DialogueState from (utterance, intent) example-based DialogueGoal detection. \n\"}",
      "classes": [
        "PolicySafeTurn",
        "DialogueObservation",
        "DialogueSupervision",
        "DialogueExample",
        "ObservationLeakageError"
      ],
      "functions": [
        "build_dialogue_goal_from_observation",
        "build_dialogue_goal",
        "_derive_next_phase",
        "build_dialogue_goal_from_task",
        "extract_dialogue_state",
        "_reconstruct_dialogue_state",
        "_build_dialogue_state_from_turns",
        "_build_dialogue_state_from_flat",
        "simulate_dialogue_operator",
        "build_dialogue_jitter_key"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.discourse.dialogue",
        "core.oracles.dialogue.oracle",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T22:55:42.644794",
        "modified": "2026-01-21T11:21:45.571970",
        "modified_days_ago": 30,
        "lines": 919,
        "size_bytes": 34561,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/legality.py",
      "name": "legality.py",
      "category": "Core module",
      "status": "active",
      "description": "Dialogue Operator Legality Predicate - Single Source of Truth.\n\nDefines one primitive predicate: `is_structurally_legal(state, op) -> bool`\nThis is used by both `get_available_ops` and mask builders to prevent drift.\n\n**Critical**: This is the single source of truth for Dialogue operator legality.\nAll availability checks and mask building must use this predicate.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "is_structurally_legal",
        "get_available_dialogue_ops",
        "build_dialogue_mask_set"
      ],
      "imports": [
        "typing",
        "core.discourse.dialogue",
        "core.oracles.legality_common"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T15:28:01.074208",
        "modified": "2026-02-21T10:47:17.732378",
        "modified_days_ago": 0,
        "lines": 98,
        "size_bytes": 3130,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/mask.py",
      "name": "mask.py",
      "category": "Core module",
      "status": "active",
      "description": "Builds dialogue operator masks using the unified legality predicate. Returns sets or bitsets for operators, not torch tensors. Author: @darianrosebrook.",
      "classes": [],
      "functions": [
        "build_dialogue_mask"
      ],
      "imports": [
        "typing",
        "core.discourse.dialogue",
        "core.oracles.dialogue.legality"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T11:06:49.657009",
        "modified": "2026-01-21T11:21:45.572994",
        "modified_days_ago": 30,
        "lines": 33,
        "size_bytes": 1039,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/oracle.py",
      "name": "oracle.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\": \"Implements deterministic dialogue scoring using lexicographic (structure)\n    with\n    hard-coded\n    rules\n    as\n    pre-defined\n    (conformalized) (optional)\n    rules\n    \"\"\"\n    \"\"\" hard-coded\n        rules can\n    (optional)\n    \"\"\" hard-coded\n        rules\n        optional\n    \"\"\"\n    \"\"\" hard-coded\n        rules\n        \"\"\"\n    \"\"\" (optional) A.4.5 context\n    (the\n    hard-coded\n        rules\n    \"\"\"\n    \"\"\" hard-coded\n    \"\"\"\n    \"\"\" (optional)\n    \"\"\"\n    \"\"\"...",
      "classes": [
        "OracleStubError",
        "DialogueGoal",
        "DialogueScore"
      ],
      "functions": [
        "_count_required_satisfied",
        "_intent_progress_delta",
        "_intent_clarity_progress",
        "_phase_progress",
        "_phase_transition_legal",
        "_has_contradiction",
        "_violates_safety_constraints",
        "_has_contradiction_bool",
        "_violates_safety_constraints_bool",
        "score_dialogue_transition"
      ],
      "imports": [
        "__future__",
        "inspect",
        "logging",
        "dataclasses",
        "typing",
        "core.contracts.governance_status",
        "core.discourse.dialogue",
        "core.oracles.common",
        "core.oracles.provenance"
      ],
      "constants": [
        "PHASE_ORDER",
        "PHASE_IDX",
        "INTENT_SAT_ORD",
        "DIALOGUE_PRIORITY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [
          {
            "line_number": 328,
            "content": "Implement IR consistency checks:",
            "file_path": "core/oracles/dialogue/oracle.py"
          },
          {
            "line_number": 373,
            "content": "Implement IR-level safety checks:",
            "file_path": "core/oracles/dialogue/oracle.py"
          }
        ],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:52:32.751348",
        "modified": "2026-01-24T23:52:32.751625",
        "modified_days_ago": 27,
        "lines": 682,
        "size_bytes": 24155,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/dialogue/reranker.py",
      "name": "reranker.py",
      "category": "Core module",
      "status": "active",
      "description": "Deterministically reranks Top-K operators for dialogue state transitions; runtime cannot select best_ops.",
      "classes": [],
      "functions": [
        "rerank_dialogue_topk",
        "eval_rerank_any_best"
      ],
      "imports": [
        "typing",
        "core.discourse.dialogue",
        "core.oracles.dialogue.integration",
        "core.oracles.dialogue.oracle"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T11:07:12.601056",
        "modified": "2026-01-21T11:21:45.574061",
        "modified_days_ago": 30,
        "lines": 88,
        "size_bytes": 2643,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "oracles/legality_common.py",
      "name": "legality_common.py",
      "category": "Core module",
      "status": "active",
      "description": "Shared legality helpers for oracle domains.",
      "classes": [],
      "functions": [
        "available_ops",
        "build_mask_set"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T10:47:06.168345",
        "modified": "2026-02-21T10:47:06.170812",
        "modified_days_ago": 0,
        "lines": 21,
        "size_bytes": 747,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "oracles/provenance.py",
      "name": "provenance.py",
      "category": "Core module",
      "status": "active",
      "description": "Computes deterministic hashes for oracle and simulator code, constants, and dependencies to enable drift detection and reproducibility.",
      "classes": [],
      "functions": [
        "compute_code_hash",
        "compute_constants_hash",
        "compute_oracle_hash",
        "compute_simulator_hash",
        "compute_canonical_policy_hash",
        "compute_oracle_provenance",
        "validate_provenance"
      ],
      "imports": [
        "hashlib",
        "inspect",
        "json",
        "typing",
        "core.oracles.common"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T06:17:24.621621",
        "modified": "2026-01-21T11:21:45.574469",
        "modified_days_ago": 30,
        "lines": 260,
        "size_bytes": 8839,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pn/__init__.py",
      "name": "__init__.py",
      "category": "Predicate nominal processing",
      "status": "active",
      "description": "PN (Predicate Nominal) module for Sterling.\n\nProvides IR graph construction for predicate nominal families,\nsupporting LOFO evaluation and structural generalization experiments.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "ir_builder",
        "surface_generator"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T11:20:45.945959",
        "modified": "2026-01-22T07:53:46.504569",
        "modified_days_ago": 29,
        "lines": 43,
        "size_bytes": 1053,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pn/ir_builder.py",
      "name": "ir_builder.py",
      "category": "Predicate nominal processing",
      "status": "active",
      "description": "{\"description\":\"PNIRBuilder creates canonical IR StateGraph from predicate nominal example definitions for structural12/9 grammar. The PN model.",
      "classes": [
        "PNIRBuilderError",
        "PNInvariantViolation",
        "FamilyDefinition",
        "PNEdgeType",
        "PNIRBuilder"
      ],
      "functions": [
        "load_family_definitions",
        "get_family_definitions",
        "validate_pn_example",
        "build_pn_state_graph"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "collections",
        "dataclasses",
        "pathlib",
        "typing",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T11:22:34.107474",
        "modified": "2026-01-22T07:53:46.504636",
        "modified_days_ago": 29,
        "lines": 2095,
        "size_bytes": 70577,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pn/surface_generator.py",
      "name": "surface_generator.py",
      "category": "Predicate nominal processing",
      "status": "active",
      "description": "Generates canonical surface text from UtteranceState predicate nominal representations. It inverts semantic structures into 'Subject is/are Determiner Predicate', expands contractions, normalizes copulas to 'is' or 'are', and standardizes determiners. Used as the inverse of parsing.",
      "classes": [],
      "functions": [
        "generate_canonical_surface",
        "expand_contractions",
        "normalize_copula",
        "standardize_determiner",
        "_extract_subject",
        "_extract_predicate",
        "_select_copula",
        "_select_determiner",
        "_expand_copula_contraction",
        "apply_expand_contraction_transform"
      ],
      "imports": [
        "__future__",
        "re",
        "typing"
      ],
      "constants": [
        "VOWELS",
        "CONTRACTIONS",
        "COPULA_FORMS",
        "PLURAL_PRONOUNS",
        "SINGULAR_PRONOUNS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T14:20:22.749056",
        "modified": "2026-01-22T07:53:46.504686",
        "modified_days_ago": 29,
        "lines": 526,
        "size_bytes": 15361,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "profiling.py",
      "name": "profiling.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides decorators for profiling function execution time and memory usage tracking via tracemalloc and time. Performs timing and memory profiling, with logging and statistics aggregation.",
      "classes": [
        "PerformanceProfiler",
        "PerformanceMonitor"
      ],
      "functions": [
        "profile",
        "time_block",
        "profile_with_cprofile",
        "memory_usage",
        "benchmark_function"
      ],
      "imports": [
        "cProfile",
        "functools",
        "io",
        "pstats",
        "time",
        "tracemalloc",
        "contextlib",
        "typing",
        "logging_config"
      ],
      "constants": [
        "F"
      ],
      "decorators_used": [
        "contextmanager"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-26T21:37:36.487504",
        "modified": "2026-01-22T07:53:45.709152",
        "modified_days_ago": 29,
        "lines": 367,
        "size_bytes": 10729,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:25:55.222829",
        "modified": "2026-01-22T07:53:46.007442",
        "modified_days_ago": 32,
        "lines": 0,
        "size_bytes": 0,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/ablation_results.py",
      "name": "ablation_results.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"schema_1\": {\"description\": \"...\", \"sterling\": \"...\", \"reduction\": 10.0 {\"...\": \"...\": 3_must_must: \"...\": 2.  execution_proving module  ...\n    # 'deterministic'  execution\n    # 'sanity'  checks, 1,  'reduction' \n    # 'test': 1 (p  ...  'e' 1.  'self' d 'ver'  self  'exef' 4  r 'failure'\n    #  'interpret' 5  'sign' 2  'test' 6  'div'  top  'state'  #  verify 7 8  'proving' 9 'pre' 0\n    #  'must' 11  'interpret",
      "classes": [
        "VerificationStatus",
        "AblationResultsArtifactV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "ALLOWED_BASELINES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-04T19:35:37.787266",
        "modified": "2026-02-06T07:04:13.338264",
        "modified_days_ago": 14,
        "lines": 342,
        "size_bytes": 14340,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/adjudicable_state.py",
      "name": "adjudicable_state.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Provides state interfaces for equivalence adjudication. Defines minimal substrate requirements for certified evaluation. See equivalence_adijudication.py for protocol details.",
      "classes": [
        "AdjudicableState",
        "EvaluableState"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "runtime_checkable"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.441535",
        "modified": "2026-02-19T09:08:21.441767",
        "modified_days_ago": 1,
        "lines": 43,
        "size_bytes": 1247,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/artifact_hashing.py",
      "name": "artifact_hashing.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"id\":\"...\"}\n    base=64, interpret as bytes; strict\nOnly- missing schema to be any\n    claims must st in st at claim d: st in shas text.  If shas file, or other in st at or da 256 hash alid da  -  - JSON object with shas  and  -  verif  and  -  as  pure sha256 (id  and  - 256 (as  text,  is st 20, hash the id below\n - only 20 hash  se (from base64)\n - part\n - sha256 including  - 20, 20, st 20 (all  st 20 (the 20 20  (the 20 20 hash 20 20  (the 20 20 (no 20 hash 20 (the",
      "classes": [
        "SchemaClosureEntry",
        "ArtifactHashError"
      ],
      "functions": [
        "find_repo_root",
        "make_repo_relative",
        "compute_file_hash",
        "compute_claim_hash",
        "resolve_schema_closure",
        "compute_schema_hash",
        "create_artifacts_block",
        "verify_artifact_hashes",
        "write_verdict_atomic"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "os",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.413959",
        "modified": "2026-01-26T06:12:48.414166",
        "modified_days_ago": 25,
        "lines": 574,
        "size_bytes": 20780,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/batch_hasher.py",
      "name": "batch_hasher.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"\", \"artifact\": \"Hash map (digest, safe) for parallelization\n\"\" (optional) a digest if input was\n    (digest generation\n    for batch digests\n    with\n    shadigstoring\n    digests\n    as input\n    (no hash\n    in parallel\n    with\n    interface\n    (for\n    input ( digests\n    output\n    in\n    each\n    (digest creation, optional) with\n    algorithm\n    name: digest \n    (must\n    be\n    atomic\n    return (the\n    digests (optional; parallel, run, digests and\n    seen b\n    y...",
      "classes": [
        "HashResult",
        "BatchHashResult",
        "BatchHasher"
      ],
      "functions": [
        "compute_hash",
        "compute_file_hash",
        "compute_artifact_hash",
        "batch_hash_artifacts",
        "batch_hash_files",
        "batch_hash_witnesses"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "os",
        "concurrent.futures",
        "dataclasses",
        "typing",
        "core.hashing"
      ],
      "constants": [
        "ENV_PARALLEL_WORKERS",
        "DEFAULT_HASH_ALGORITHM"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:38:14.965132",
        "modified": "2026-01-26T06:38:14.965392",
        "modified_days_ago": 25,
        "lines": 556,
        "size_bytes": 17185,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/benchmark_artifacts.py",
      "name": "benchmark_artifacts.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\n  \"schema_\": \"BoundInputsV1\",\n  \"description\": \"Input binding schema + instance hashes to produce deterministic input representation for ML models, \n  (frozenM map: str to (fixed schema) \n  digest (body: str -> { \n    \"task\": str, \n    \"instance\": (body: str\n    \"context\": {\"job\": \"proof\": \"M map\"sterling job\" and context for proof storage in BoundInputs\n    \"data\": (str, \n    store Keys as (optional): \"explanation\"\n}",
      "classes": [
        "BoundInputsV1",
        "OutcomeRowsV1",
        "ReplayTraceV1",
        "MetricsBundleV1",
        "ToolTranscriptV1",
        "GeneratorContractV1",
        "ByteTraceArtifactV1",
        "ByteStateBindingV1",
        "ByteTraceProofSurface",
        "RunTelemetryV1"
      ],
      "functions": [
        "compute_bound_inputs_hash",
        "compute_bound_inputs_bundle_hash"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_BYTESTATE_BINDING_HASH_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T21:20:58.756505",
        "modified": "2026-02-18T21:20:58.756830",
        "modified_days_ago": 2,
        "lines": 455,
        "size_bytes": 17288,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/byte_replay_verification.py",
      "name": "byte_replay_verification.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "ByteReplayVerifier: Byte-for-byte trace replay verification.\n\nVerifies that two ByteTraceV1 instances (from two runs with the same seed)\nproduce identical payload hashes. On divergence, localizes to the exact\nbyte \u2192 step \u2192 layer/slot.\n\nThis is separate from the existing replay_verification.py which handles\nJSON-based ReplayTraceV1.\n\nAuthor: @darianrosebrook",
      "classes": [
        "ByteReplayVerifier"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "core.carrier.bytetrace"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T01:18:13.314026",
        "modified": "2026-02-16T01:18:13.314196",
        "modified_days_ago": 5,
        "lines": 132,
        "size_bytes": 4540,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/capsule_spec_ea.py",
      "name": "capsule_spec_ea.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Validates suite IDs for the p27.ea (Equivalence Adjudication lane) CapsuleSpecV1 builder.",
      "classes": [],
      "functions": [
        "validate_suite_id",
        "_validate_suite_ids",
        "build_p27_ea_capsule_spec",
        "spec_hash_surface_bytes"
      ],
      "imports": [
        "__future__",
        "re",
        "typing",
        "core.capsules.capsule_spec",
        "core.proofs.shared.canonical_json"
      ],
      "constants": [
        "_SUITE_ID_PATTERN",
        "_FORBIDDEN_SUITE_MARKERS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-22T13:12:17.730584",
        "modified": "2026-02-22T13:12:17.730696",
        "modified_days_ago": 0,
        "lines": 139,
        "size_bytes": 5315,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/certificate.py",
      "name": "certificate.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Computes a hash for verdict sets, builds TD12 certificates with issuer and policy data, and verifies certificates by rehashing referenced artifacts.",
      "classes": [],
      "functions": [
        "compute_verdict_set_hash",
        "build_certificate",
        "verify_certificate_replay"
      ],
      "imports": [
        "base64",
        "json",
        "logging",
        "pathlib",
        "typing",
        "core.proofs.artifact_hashing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T15:13:20.283955",
        "modified": "2026-01-22T07:53:46.092696",
        "modified_days_ago": 29,
        "lines": 195,
        "size_bytes": 6963,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/certification_blocker.py",
      "name": "certification_blocker.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "CertificationBlocker emits structured failure artifacts with stable codes to enable deterministic identity, machine-readable processing, and governance audit trails at mint and verify boundaries.",
      "classes": [
        "CertificationBlockerCode",
        "CertificationBlocker",
        "CertificationBlockerError",
        "VerificationResult"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:16:12.021402",
        "modified": "2026-01-27T07:16:12.021847",
        "modified_days_ago": 24,
        "lines": 221,
        "size_bytes": 7447,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/cold_start_verifier.py",
      "name": "cold_start_verifier.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "legacy_v7",
      "description": "{\"description\":\"Cold-Start Verifier runs static validation against the committed files to ensure integrity within the provided bundle; does not allow any file access or modification.  returns 3010 A0  st0 S0 st0 ives 0 0  uch 9  e0  verif  y 3 checks for 4 integrity\n    runs 0  d-checks 3  a  ge 0 checks for each 1  f 0  r  e  verif  y  e  r  a  tional 0  y  st ation  f  r  e  x  e  r  e  x  a  c  h  e  r  e  x  a  t  i  sh  p  ro  w  ar  d  e  t  h  a",
      "classes": [
        "VerificationCheckStatus",
        "VerificationErrorCode",
        "CheckResult",
        "VerificationResult",
        "ColdStartVerifier"
      ],
      "functions": [
        "verify_bundle"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing",
        "core.proofs.commitment_hash"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "likely_stale",
      "staleness_score": 0.6,
      "staleness_indicators": [
        "Has 'old_' prefix suggesting superseded"
      ],
      "recommendation": "Likely stale - update or archive soon. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T13:50:05.454023",
        "modified": "2026-01-22T07:53:46.442867",
        "modified_days_ago": 29,
        "lines": 565,
        "size_bytes": 20614,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/commitment_hash.py",
      "name": "commitment_hash.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "(sig) includes  (self, \n    base: optional\n    includes (self, \n    verif fixed\n    (base)\n    (self contains\n    verif label\n    Commit keeps\n    the root\n    of cert \"sempif\":  requires\n    hash( ) (this)\n    verif  (this)\n    type  (self)\n    Note: the\n    verif  (this)\n    verif  (this)\n    does\n    commit\n    key (  )\n    verif  (  commit\n    requires \n    ver  (  requires  (signing key\n    optional",
      "classes": [
        "CommitmentDomain",
        "CommitmentHash",
        "RateFraction"
      ],
      "functions": [
        "quantize_rate",
        "dequantize_rate",
        "quantize_cost",
        "dequantize_cost",
        "compute_commitment_hash",
        "verify_commitment_hash",
        "is_volatile_field",
        "filter_volatile_fields",
        "compute_provenance_closure_hash",
        "compute_provenance_chain_hash"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "decimal",
        "enum",
        "typing",
        "core.canonicalization"
      ],
      "constants": [
        "_RATE_SCALE",
        "_COST_SCALE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T13:43:35.979291",
        "modified": "2026-01-22T07:53:46.022812",
        "modified_days_ago": 29,
        "lines": 450,
        "size_bytes": 13623,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/determinism.py",
      "name": "determinism.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"...\":null,\"don't store user defined abs\nCheck if the same  claim value\n  if the same  claim\n  if  new claim\n  if  new  evidence\n  -  claim  for  it  claim\n  - exactly one  the  claim's  structure\n  (dict  (merged  check  with  claim  - exactly  one  the  relations of  the  claim's when  needed for  it  evidence.",
      "classes": [
        "CaseRecord",
        "DeterminismMismatch",
        "DeterminismReport",
        "DeterminismError"
      ],
      "functions": [
        "write_case_results",
        "read_case_results",
        "check_determinism",
        "compare_run_files"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [
        "IDENTITY_FIELDS",
        "CLAIM_FIELDS",
        "DETERMINISTIC_FIELDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T18:06:46.089312",
        "modified": "2026-01-22T07:53:46.090350",
        "modified_days_ago": 29,
        "lines": 321,
        "size_bytes": 10237,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/equivalence_adjudication.py",
      "name": "equivalence_adjudication.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"Adjudication, the demo. It evaluates, the, at least one genuine counterexample. Mism, the operator, the\n    by, the\n    (RHS_ and LHS_ digest. It never\n    by the\n    step. If\n    Mismatch at a given\n    as in the\n    by the 1\n    by the by\n    by a  as  as\n    the  and\n    step. The\n    mis  and\n    non- and\n    by\n    (by step.  and\n    by  and\n    step. It\n    by\n  and\n    step.  and\n    step.  It\n    and\n    It\n    non- and\n    step. It\n    The\n    and\n    step.  and\n    The",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.441807",
        "modified": "2026-02-19T09:08:21.442072",
        "modified_days_ago": 1,
        "lines": 200,
        "size_bytes": 9107,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/equivalence_adjudicator.py",
      "name": "equivalence_adjudicator.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"Adjudicator samples both states using provided witnesses; does not call state.evaluate(). Requires lhs and rhs StepWitnessV1 for each, returns classification or fails when neighbours differ; uses EqEvidenceV1 when possible. Fails close on undefined points. Uses StepWitness for evaluation. Classifies as EQUIVALENCE if all neighbors match and evidence matches. Otherwise, returns skip with reason. Does not mutate state.",
      "classes": [
        "AdjudicationResult",
        "EquivalenceAdjudicatorV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.operators.evidence_contract",
        "core.proofs.adjudicable_state",
        "core.proofs.equivalence_witness",
        "core.proofs.eval_witness",
        "core.proofs.sampling_policy",
        "core.proofs.step_witness"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.442109",
        "modified": "2026-02-19T09:08:21.442311",
        "modified_days_ago": 1,
        "lines": 337,
        "size_bytes": 12465,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/equivalence_gates.py",
      "name": "equivalence_gates.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"Equivalence validation gates (G5/6) use local witnesses for G5/6 validation. G5: artifact-verified soundness( G5 witness check with eval( G5/6 proof: G6 artifact(derivation, check) via G6 replay( record-and-verify). G1 demo var(uses G6 e(valuation sub-check.",
      "classes": [
        "EquivalenceGateWitness"
      ],
      "functions": [
        "check_counterexample_soundness",
        "check_minimality"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.adjudicable_state",
        "core.proofs.equivalence_witness",
        "core.proofs.eval_witness",
        "core.proofs.refinement"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T11:35:10.278556",
        "modified": "2026-02-19T11:35:10.278863",
        "modified_days_ago": 1,
        "lines": 350,
        "size_bytes": 13372,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/equivalence_witness.py",
      "name": "equivalence_witness.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Generates content-addressed equivalence witnesses for pairwise adjudication. Records domain, classification, digest, counterexamples, and exceptions. Used for TD12/MS certificate validation.",
      "classes": [
        "EquivalenceWitnessV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.proofs.sampling_policy"
      ],
      "constants": [
        "_EQUIV_WITNESS_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.442661",
        "modified": "2026-02-19T09:08:21.442879",
        "modified_days_ago": 1,
        "lines": 87,
        "size_bytes": 3269,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/eval_witness.py",
      "name": "eval_witness.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Content-addressed evaluation witness for numeric sampling, capturing policy and sample digests in a domain-agnostic proof artifact.",
      "classes": [
        "EvalWitnessV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils",
        "core.proofs.sampling_policy"
      ],
      "constants": [
        "_EVAL_WITNESS_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T11:35:10.278965",
        "modified": "2026-02-19T11:35:10.279254",
        "modified_days_ago": 1,
        "lines": 80,
        "size_bytes": 3150,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/evidence_item_ir.py",
      "name": "evidence_item_ir.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Ensures evidence items are deterministic (no forbidden fields, no wall-clock timestamps, no randomized IDs, no unordered containers).",
      "classes": [],
      "functions": [
        "canonicalize_evidence_item",
        "_validate_no_forbidden_fields",
        "_normalize_dict"
      ],
      "imports": [
        "__future__",
        "re",
        "typing"
      ],
      "constants": [
        "FORBIDDEN_FIELD_PATTERNS",
        "ALLOWED_ID_SUFFIXES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.773017",
        "modified": "2026-02-17T10:09:41.567729",
        "modified_days_ago": 3,
        "lines": 168,
        "size_bytes": 6099,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/evidence_schema_registry.py",
      "name": "evidence_schema_registry.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Evidence Schema Registry enforces a strict v0 evidence contract and maintains a validated schema registry to prevent unversioned evidence from being treated as schemas. Stage K report evidence is validated and bound for promotion.",
      "classes": [
        "EvidenceSchemaV0",
        "EvidenceSchemaRegistry"
      ],
      "functions": [
        "build_stage_k_report_evidence"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.induction.artifact_store",
        "core.proofs.evidence_item_ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T15:00:34.611279",
        "modified": "2026-02-20T18:06:46.680496",
        "modified_days_ago": 0,
        "lines": 234,
        "size_bytes": 8887,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/fixture_ir.py",
      "name": "fixture_ir.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\n    \"input\": \"...\": always\n    # hash once for the given test\n    # to ensure input\n    fixup to remove meta\n    fixup to root.",
      "classes": [
        "FixtureIRV1",
        "FixtureManifestV1",
        "SolverContractIR",
        "SolverContractBundleV1"
      ],
      "functions": [
        "_filter_volatile_fields",
        "compute_fixture_hash",
        "verify_fixture_hash"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-04T17:05:05.389819",
        "modified": "2026-02-06T11:48:30.706414",
        "modified_days_ago": 14,
        "lines": 564,
        "size_bytes": 20038,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/h2_evidence_bundle.py",
      "name": "h2_evidence_bundle.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"H2 Evidence bundles as a verifiable set of trusted voices, exact match on operator bundle data structure. H2 validation.",
      "classes": [
        "MeasurementStatus",
        "CapabilityId",
        "VerificationPhase",
        "VerificationStatus",
        "ArtifactRole",
        "ArtifactRef",
        "CheckResult",
        "PhaseResult",
        "VerificationResult"
      ],
      "functions": [
        "get_regime_minimum_for_capability",
        "compute_manifest_identity",
        "verify_manifest_identity",
        "compute_file_hash",
        "get_file_size",
        "verify_integrity",
        "verify_schema",
        "verify_consistency",
        "_verify_replay",
        "verify_replay"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "core.canonicalization"
      ],
      "constants": [
        "EVIDENCE_BUNDLE_SPEC",
        "VERIFIER_VERSION",
        "SCHEMA_MANIFEST",
        "SCHEMA_SUMMARY",
        "SCHEMA_INVARIANCE",
        "SCHEMA_SAFEGUARDS",
        "SCHEMA_VERIFICATION",
        "DEFAULT_REGIME_MINIMUM",
        "MANIFEST_VOLATILE_FIELDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T05:09:43.181562",
        "modified": "2026-01-24T11:12:19.019655",
        "modified_days_ago": 27,
        "lines": 1203,
        "size_bytes": 39440,
        "author": "@darianrosebrook",
        "has_main": true
      }
    },
    {
      "path": "proofs/h2_evidence_bundle_generator.py",
      "name": "h2_evidence_bundle_generator.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"Generates H2 evidence bundles from Stage K outputs for verification\nAuthor: darianrose\n  evidence_bundles: \"sterlingu_mercle\n    capability\n    # 'H2' rome_  outputs\n    capability 'H2'  evidence_path\n    invariance_  bundle_  hub_  bundle_  evidence_  hub_ rome_  output\n    capability\n    #  evidence_ rome_  outputs\n    #  capability\n    #  hub_ rome_  outputs\n    #  capability\n    #  evidence_  hub_  bundle  hub_  evidence_  bundle  hub\n    #  evidence_  bundle\n    #  hub ...",
      "classes": [
        "InvarianceTestResult",
        "InvarianceResults",
        "SafeguardAttestation",
        "LandmarkSnapshot",
        "PerformanceMetrics",
        "RegimeRunOutput",
        "BundleGeneratorConfig"
      ],
      "functions": [
        "get_git_commit",
        "compute_quarantine_registry_digest",
        "copy_artifact",
        "write_json_artifact",
        "generate_invariance_results",
        "generate_safeguard_attestations",
        "generate_capability_summary",
        "generate_replay_instructions",
        "generate_evidence_bundle",
        "main"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "shutil",
        "subprocess",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing"
      ],
      "constants": [
        "GENERATOR_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-14T23:19:08.330334",
        "modified": "2026-02-14T23:19:08.330449",
        "modified_days_ago": 6,
        "lines": 946,
        "size_bytes": 32628,
        "author": "@darianrosebrook",
        "has_main": true
      }
    },
    {
      "path": "proofs/handover_gates.py",
      "name": "handover_gates.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Sterling's provenance authority policy validates attestation during upgrades, using TD12/MS certificates and hash checks on claim artifacts via the handover gates.",
      "classes": [
        "ProvenanceAuthorityPolicy",
        "AttestationValidationResult",
        "HandoverGateFailure"
      ],
      "functions": [
        "validate_provenance_attestation",
        "_load_schema_registry",
        "verify_snapshot_integrity",
        "verify_hash_stability",
        "verify_provenance_continuity"
      ],
      "imports": [
        "json",
        "logging",
        "pathlib",
        "typing",
        "jsonschema",
        "referencing",
        "core.proofs.artifact_hashing"
      ],
      "constants": [
        "SCHEMA_DIR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-18T12:30:29.208461",
        "modified": "2026-01-22T07:53:46.351222",
        "modified_days_ago": 29,
        "lines": 407,
        "size_bytes": 15491,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Domain induction proof contracts for the induction+synthesis lane.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.421879",
        "modified": "2026-02-21T15:38:13.421994",
        "modified_days_ago": 0,
        "lines": 1,
        "size_bytes": 73,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/builders.py",
      "name": "builders.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Deterministic builders that transform evidence streams into domain IR, manifest, and report artifacts; exceptions converted to FailureRefV1.",
      "classes": [],
      "functions": [
        "_extract_fields",
        "_extract_clauses",
        "_extract_invariants",
        "_extract_affordances",
        "_decode_payload",
        "_stable_failure_observed",
        "_build_failure_manifest",
        "build_evidence_stream",
        "induce_domain_spec",
        "_induce_domain_spec_inner"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.failures",
        "core.proofs.shared.manifest",
        "core.proofs.induction.exceptions",
        "core.proofs.induction.failures",
        "core.proofs.induction.domain_spec_ir",
        "core.proofs.induction.evidence_stream"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.697617",
        "modified": "2026-02-21T21:49:26.697742",
        "modified_days_ago": 0,
        "lines": 503,
        "size_bytes": 18780,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/capsule_spec_di.py",
      "name": "capsule_spec_di.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "CapsuleSpecV1 builder for p22.di (Domain Induction lane).",
      "classes": [],
      "functions": [
        "validate_suite_id",
        "_validate_suite_ids",
        "build_p22_di_capsule_spec",
        "spec_hash_surface_bytes"
      ],
      "imports": [
        "__future__",
        "re",
        "typing",
        "core.capsules.capsule_spec",
        "core.proofs.shared.canonical_json"
      ],
      "constants": [
        "_SUITE_ID_PATTERN",
        "_FORBIDDEN_SUITE_MARKERS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422070",
        "modified": "2026-02-21T15:38:13.422171",
        "modified_days_ago": 0,
        "lines": 86,
        "size_bytes": 3427,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/domain_spec_ir.py",
      "name": "domain_spec_ir.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Generates digest-verified domain specification IR artifacts for TD12/MS induction.",
      "classes": [
        "BoundsV1",
        "FieldDeclV1",
        "InvariantDeclV1",
        "AffordanceDeclV1",
        "EquivalenceDeclV1",
        "UnknownsPolicyV1",
        "DomainSpecProvenanceV1",
        "DomainSpecIRv1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.697832",
        "modified": "2026-02-21T21:49:26.697963",
        "modified_days_ago": 0,
        "lines": 232,
        "size_bytes": 8061,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/evidence_stream.py",
      "name": "evidence_stream.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Evidence stream artifacts for domain induction. EvidenceItemV1 and EvidenceStreamV1 define ordered, content-addressed inputs for the induction capsule. Deserialization ensures strict seq order and cryptographic validation.",
      "classes": [
        "EvidenceItemV1",
        "EvidenceStreamV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "base64",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698002",
        "modified": "2026-02-21T21:49:26.698097",
        "modified_days_ago": 0,
        "lines": 124,
        "size_bytes": 3927,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/exceptions.py",
      "name": "exceptions.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Raising EvidenceValidationError for invalid identifiers or missing payload keys; propagating only internal invariant failures to DICompilationFailureV1. Distinguishes user vs internal evidence issues.",
      "classes": [
        "EvidenceValidationError",
        "EvidenceKeyError"
      ],
      "functions": [],
      "imports": [
        "__future__"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698128",
        "modified": "2026-02-21T21:49:26.698205",
        "modified_days_ago": 0,
        "lines": 34,
        "size_bytes": 1179,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/failures.py",
      "name": "failures.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Typed DI failure details for deterministic failure artifacts.",
      "classes": [
        "DICompilationFailureV1",
        "DIEvidenceInvalidV1",
        "DIEvidenceInsufficientV1",
        "DIProbeFailureV1",
        "DIDriftDetectedV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422205",
        "modified": "2026-02-21T15:38:13.422341",
        "modified_days_ago": 0,
        "lines": 134,
        "size_bytes": 4397,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/induction_report.py",
      "name": "induction_report.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Certified claim surface for DI capsules. InductionReportV1 contains digest references to artifacts and fail-closed refusal digest if present.",
      "classes": [
        "InductionReportV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.manifest"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698251",
        "modified": "2026-02-21T21:49:26.698359",
        "modified_days_ago": 0,
        "lines": 115,
        "size_bytes": 4675,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/policies.py",
      "name": "policies.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Induction policy artifacts for deterministic policy digest binding.\n\nEvery policy digest in an artifact payload is the digest of a real canonical\npolicy object, not a magic constant. This ensures policy evolution is an\nexplicit version bump rather than accidental digest churn.",
      "classes": [
        "InductionPolicyV1",
        "OrderingPolicyV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698391",
        "modified": "2026-02-21T21:49:26.698553",
        "modified_days_ago": 0,
        "lines": 112,
        "size_bytes": 3539,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/probes.py",
      "name": "probes.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "ProbeResultsV1 aggregates probe outcomes for domain invariants using ProbeResultsV1 and ProbeResultV1 representations; only verified artifacts are included in certified bundles.",
      "classes": [
        "ProbeSuiteRefV1",
        "ProbeResultV1",
        "ProbeResultsV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698615",
        "modified": "2026-02-21T21:49:26.698735",
        "modified_days_ago": 0,
        "lines": 128,
        "size_bytes": 4131,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/induction/rule_ir.py",
      "name": "rule_ir.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Rule IR artifacts for domain induction. RuleIRv1 contains extracted clauses with evidence support tracing to specific items and probes.",
      "classes": [
        "SupportV1",
        "RuleClauseV1",
        "RuleIRv1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.698774",
        "modified": "2026-02-21T21:49:26.698872",
        "modified_days_ago": 0,
        "lines": 141,
        "size_bytes": 3999,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/k6_e3_fence.py",
      "name": "k6_e3_fence.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"Enforces K6-E3 checks (including configuration checks are passed, including orbital require_ review_ as input from  l_ ap_1 (divi_ t e_ 4_5  (all  checks passed in_cl_4_  (an) a_ 4  (check_ 6  (all)  a_8_  check_ 4  (an) 5 configuration\n    GAT_  check_  status\n    # 4  (manual)  a_  check_ 6  a  check_8  (all)  check_1  (an) 6_8  require_ 0 0  require_ 0  (all) 5  require_ 3  checks_ 6 0  check_ 8  require_1  (",
      "classes": [
        "FenceCheckType",
        "FenceViolation",
        "K6E3FenceConfig",
        "FenceCheckResult",
        "K6E3FenceResult",
        "K6E3FenceError",
        "K6E3VerificationFence"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.memory.landmark_gate",
        "core.memory.landmark_node"
      ],
      "constants": [
        "DEFAULT_FENCE_CONFIG",
        "STRICT_FENCE_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:43:44.369551",
        "modified": "2026-01-22T07:53:46.351215",
        "modified_days_ago": 29,
        "lines": 449,
        "size_bytes": 14588,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/key_parsing.py",
      "name": "key_parsing.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Provides strict Ed25519 public key parsing with explicit error handling for hex, base64, and PEM formats. Automatically detects format and rejects malformed or wrong-curve keys with clear error codes. Used for verifying key inputs in Sterling's fail-closed reasoning.",
      "classes": [
        "PublicKeyFormat",
        "KeyParseError",
        "KeyFormatDetectionError",
        "KeyParseMalformedError",
        "KeyParseWrongCurveError"
      ],
      "functions": [
        "detect_key_format",
        "parse_public_key",
        "_parse_hex_key",
        "_parse_base64_key",
        "_parse_pem_key",
        "validate_ed25519_public_key"
      ],
      "imports": [
        "base64",
        "logging",
        "enum",
        "typing",
        "cryptography.hazmat.primitives",
        "cryptography.hazmat.primitives.asymmetric"
      ],
      "constants": [
        "ED25519_PUBLIC_KEY_SIZE"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-07T12:57:13.389606",
        "modified": "2026-01-22T07:53:46.022772",
        "modified_days_ago": 29,
        "lines": 327,
        "size_bytes": 10279,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/p22/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "P22 proof-layer scaffold exports.",
      "classes": [],
      "functions": [],
      "imports": [
        "capsule_spec_p22",
        "evidence_types_v0",
        "verification_types_v1"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:11:21.242301",
        "modified": "2026-02-21T15:11:21.242603",
        "modified_days_ago": 0,
        "lines": 14,
        "size_bytes": 455,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/p22/capsule_spec_p22.py",
      "name": "capsule_spec_p22.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Builds P22 capsule specifications with deterministic identity for TD12/MS certificates and proof bundles.",
      "classes": [],
      "functions": [
        "build_p22_capsule_spec"
      ],
      "imports": [
        "__future__",
        "core.capsules.capsule_spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T18:02:40.769335",
        "modified": "2026-02-20T18:02:40.770890",
        "modified_days_ago": 0,
        "lines": 69,
        "size_bytes": 3247,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/p22/evidence_types_v0.py",
      "name": "evidence_types_v0.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "P22 evidence envelope dataclasses (v0).\n\nPerceptObservationIRv0 is re-exported from the canonical capsule types.\nPerceptDeltaIRv0 is defined here (no capsule equivalent yet).",
      "classes": [
        "PerceptDeltaIRv0"
      ],
      "functions": [
        "derive_delta_from_observation"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.capsules.p22.canonical_json",
        "core.capsules.p22.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-21T15:11:21.242801",
        "modified": "2026-02-21T15:11:21.242894",
        "modified_days_ago": 0,
        "lines": 64,
        "size_bytes": 2241,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/p22/verification_types_v1.py",
      "name": "verification_types_v1.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "P22 realization intent and verification report types.\n\nRe-exported from the canonical capsule types to maintain a single source of truth.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.capsules.p22.types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2026-02-21T15:11:21.242978",
        "modified": "2026-02-21T15:11:21.243071",
        "modified_days_ago": 0,
        "lines": 10,
        "size_bytes": 287,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/pinned_env.py",
      "name": "pinned_env.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"Compute deterministic hashes of interpreter surface, kernel ABI, and world state from registry to bind certified operator environment to Dossier, prevent semantic drift by pinning ABI, DS field hashes. Author: @darianrosebrook. Date: January 26 2024.0\n\"\"\" (from pinning one time hash of interpreter surfaces\"\"\"\n\"\"\"Return shas text.",
      "classes": [
        "KernelProvider"
      ],
      "functions": [
        "compute_interpreter_surface_hash",
        "compute_kernel_abi_hash_from_provider",
        "compute_default_pn_kernel_abi",
        "compute_world_semantics_hash_from_registry",
        "compute_default_pn_world_semantics_hash",
        "build_pinned_env",
        "verify_pinned_env"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing"
      ],
      "constants": [
        "INTERPRETER_STRICTNESS_MODE",
        "CANONICALIZATION_VERSION",
        "PN_KERNEL_ABI_VERSION"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-20T07:47:18.400143",
        "modified": "2026-01-21T11:21:45.583836",
        "modified_days_ago": 30,
        "lines": 333,
        "size_bytes": 11432,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/pre_certificate_ref.py",
      "name": "pre_certificate_ref.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"Computes a deterministic reference hash of all gate inputs used for binding pre-certified states to certificate (sketched from raw inputs (w_1, exactly the pre and all_observable_ and_ compute_ the operator digest along with all_ and both_ the_ and commit_ to all_ operator_ inputs, includes_ all_ the_ operator_ to_ prove_ the_ operator_ hashes for the_ each_ operator_ in_ provenance\n- operator_ commits to_ internal_ the_ to_ prove_ the_ operator_ and_ all_ and_ and_ prove_ and_...",
      "classes": [
        "PreCertificateRefV1"
      ],
      "functions": [
        "compute_supporting_episode_hashes_digest_v1",
        "compute_pinned_env_hash_v1",
        "build_pre_certificate_ref_v1",
        "build_pre_certificate_ref_from_core_and_dossier",
        "verify_pre_certificate_ref_v1"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-20T09:28:59.681610",
        "modified": "2026-01-21T11:21:45.584684",
        "modified_days_ago": 30,
        "lines": 322,
        "size_bytes": 11971,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/provenance_chain.py",
      "name": "provenance_chain.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "ProvenanceChainV1 performs full closure verification: all referenced artifacts must exist and hash-match. EvidenceBinding links episode and selection rule digests. P0 scope enforces direct artifact references; transitive checks deferred to Horizon 2.",
      "classes": [
        "_LegacyProvenanceVerificationResult",
        "EvidenceBinding",
        "ProvenanceChainV1"
      ],
      "functions": [
        "validate_v2_provenance_fields"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "typing",
        "core.canonicalization"
      ],
      "constants": [
        "PROVENANCE_CHAIN_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-20T08:39:54.208736",
        "modified": "2026-01-22T07:53:46.007458",
        "modified_days_ago": 29,
        "lines": 440,
        "size_bytes": 15959,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/provenance_closure_projection.py",
      "name": "provenance_closure_projection.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Computes EvidenceSliceDigest for third-party provenance verification using minimal projection of episode and selection rule evidence. Domain-separated hashes ensure no collision risk.",
      "classes": [
        "EvidenceSliceDigest",
        "ProvenanceClosureProjectionV1"
      ],
      "functions": [
        "compute_closure_projection_hash",
        "build_projection_from_chain"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.commitment_hash"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T11:48:18.510289",
        "modified": "2026-01-22T07:53:46.087841",
        "modified_days_ago": 29,
        "lines": 245,
        "size_bytes": 9168,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/provenance_verifier.py",
      "name": "provenance_verifier.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Provenance verifier ensures promotion gate and loader use same validation logic. Implements Milestone 1.2 governance: strict/non-strict modes, no duplicated paths. Prevents false accept/reject mismatches by enforcing consistent validation across both stages.",
      "classes": [
        "VerificationMode",
        "VerificationError",
        "ProvenanceVerificationResult",
        "ProvenanceVerifier"
      ],
      "functions": [
        "get_verifier"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T11:59:46.115086",
        "modified": "2026-01-22T07:53:46.030816",
        "modified_days_ago": 29,
        "lines": 595,
        "size_bytes": 20705,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/refinement.py",
      "name": "refinement.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Records grid-search results and refinement steps for counterexample minimization. Generates minimization witness with hashed artifacts and bisection metadata.",
      "classes": [
        "RefinementStepV1",
        "MinimizationWitnessV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_MINIMIZATION_WITNESS_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.443236",
        "modified": "2026-02-19T09:08:21.443432",
        "modified_days_ago": 1,
        "lines": 104,
        "size_bytes": 3754,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/replay_verification.py",
      "name": "replay_verification.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"Replay protocol to verify determinism using captured state. Re-run the exact input to produce identical output\n    verifiable: contains\n        the replay\n    check_start_ from replay_main",
      "classes": [
        "RNGStateV1",
        "ReplayMode",
        "VerificationStatus",
        "ReplayVerificationArtifactV1"
      ],
      "functions": [
        "capture_rng_state",
        "restore_rng_state",
        "verify_replay_determinism"
      ],
      "imports": [
        "__future__",
        "random",
        "subprocess",
        "sys",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-04T17:50:06.492474",
        "modified": "2026-02-06T07:05:28.807533",
        "modified_days_ago": 14,
        "lines": 409,
        "size_bytes": 13370,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/run_manifest.py",
      "name": "run_manifest.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Builds TD12 run manifest by computing file hashes and dependency lock info; writes the manifest atomically to JSON. Used for proof generation and replay verification in Sterling.",
      "classes": [],
      "functions": [
        "get_git_info",
        "get_deps_lock_info",
        "build_run_manifest",
        "write_run_manifest_atomic"
      ],
      "imports": [
        "json",
        "platform",
        "subprocess",
        "datetime",
        "pathlib",
        "typing",
        "core.proofs.artifact_hashing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T15:13:18.336044",
        "modified": "2026-01-22T07:53:46.435683",
        "modified_days_ago": 29,
        "lines": 131,
        "size_bytes": 4153,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/sampling_policy.py",
      "name": "sampling_policy.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Content-addressed sampling policy for numeric evaluation.\n\nExtracted from test-scenarios/graphing-calc-demo/proof_artifacts.py.\nThis is a domain-agnostic proof artifact type \u2014 no expression-specific imports.\n\nAuthor: @darianrosebrook",
      "classes": [
        "SamplingPolicy"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_SAMPLING_POLICY_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.443465",
        "modified": "2026-02-19T09:08:21.443686",
        "modified_days_ago": 1,
        "lines": 91,
        "size_bytes": 3100,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/schema_validation.py",
      "name": "schema_validation.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Validates proof verdicts against declared schemas in the proof schema gate; fails if verdicts do not conform. Enforces mandatory schema and hash checks via explicit entrypoints. Non-negotiable for proof acceptance.",
      "classes": [
        "SchemaValidationError"
      ],
      "functions": [
        "_find_repo_root",
        "validate_verdict_schema_only",
        "validate_verdict_and_hashes",
        "validate_evidence_list",
        "validate_and_raise",
        "validate_and_raise_with_hashes",
        "validate_evidence_and_raise"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "pathlib",
        "typing"
      ],
      "constants": [
        "SCHEMAS_DIR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:48:21.898425",
        "modified": "2026-01-22T07:53:46.007431",
        "modified_days_ago": 29,
        "lines": 288,
        "size_bytes": 9249,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Shared proof-side utilities for the induction+synthesis promotion lane.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422380",
        "modified": "2026-02-21T15:38:13.422467",
        "modified_days_ago": 0,
        "lines": 1,
        "size_bytes": 78,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/canonical_json.py",
      "name": "canonical_json.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Canonical JSON helpers for deterministic proof artifact hashing.\n\nThis module intentionally enforces a strict input type surface to prevent\nsilent serialization drift across environments.",
      "classes": [
        "CanonicalizationError"
      ],
      "functions": [
        "encode_canonical_bytes",
        "decode_canonical_bytes",
        "sorted_ints",
        "sorted_strs",
        "sorted_digests",
        "sorted_pairs",
        "_normalize",
        "normalize_for_canonical_json",
        "canonical_json_bytes"
      ],
      "imports": [
        "__future__",
        "base64",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_CANONICAL_BYTES_PREFIX",
        "_ALLOWED_PRIMITIVE_TYPES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422501",
        "modified": "2026-02-21T15:38:13.422583",
        "modified_days_ago": 0,
        "lines": 127,
        "size_bytes": 3869,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/claim_surface.py",
      "name": "claim_surface.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Claim-surface digest helper for deterministic success/refusal threading.",
      "classes": [
        "ClaimSurfaceV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422617",
        "modified": "2026-02-21T15:38:13.422713",
        "modified_days_ago": 0,
        "lines": 88,
        "size_bytes": 3282,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/digesting.py",
      "name": "digesting.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Digest helpers for proof-side content-addressed artifacts.",
      "classes": [],
      "functions": [
        "sha256_hex",
        "ensure_sha256_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "re"
      ],
      "constants": [
        "_SHA256_PATTERN"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422743",
        "modified": "2026-02-21T15:38:13.422814",
        "modified_days_ago": 0,
        "lines": 21,
        "size_bytes": 626,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/failures.py",
      "name": "failures.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Shared failure wrapper for deterministic refusal/verification artifacts.",
      "classes": [
        "FailureCode",
        "FailureKind",
        "FailureDetails",
        "FailureRefV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.422843",
        "modified": "2026-02-21T15:38:13.422980",
        "modified_days_ago": 0,
        "lines": 136,
        "size_bytes": 4883,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/identifiers.py",
      "name": "identifiers.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Validates user-facing identifiers in proof-layer artifacts to prevent environment or test marker leakage before embedding in digest surfaces.",
      "classes": [],
      "functions": [
        "validate_marker_free",
        "validate_identifier"
      ],
      "imports": [
        "__future__",
        "re"
      ],
      "constants": [
        "ID_PATTERN",
        "FORBIDDEN_MARKERS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.699004",
        "modified": "2026-02-21T21:49:26.699207",
        "modified_days_ago": 0,
        "lines": 43,
        "size_bytes": 1495,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/manifest.py",
      "name": "manifest.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Shared dependency manifest for deterministic DI/PS coupling.",
      "classes": [
        "SchemaDescriptorV1",
        "RegistryDescriptorV1",
        "DependencyManifestV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.423015",
        "modified": "2026-02-21T15:38:13.423135",
        "modified_days_ago": 0,
        "lines": 128,
        "size_bytes": 4636,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/transfer_domain_descriptor.py",
      "name": "transfer_domain_descriptor.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Validates and serializes transfer domain descriptor contracts for CPG-6 enforcement using structured, verified identifiers and envelope guarantees.",
      "classes": [
        "DistinctnessCheckV1",
        "TransferDomainDescriptorV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.699354",
        "modified": "2026-02-21T21:49:26.699458",
        "modified_days_ago": 0,
        "lines": 114,
        "size_bytes": 4326,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/shared/transfer_verdict.py",
      "name": "transfer_verdict.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"Transfer verdict artifacts for cross-domain checks.  Verifies claim in canonical text format.  Aggregates structured evidence.  Interprelimboiler with Sharded JSON  for AML proofkey  statements.  Evidence record  as  M map for  structured  evidence.  Verify  claim in  structured  text format.  Evidence  a  structured  claim.  supports  JSON  structure:\n  provenance  holds  claim  supports  JSON  with  evidence.  Verify  claim  structure.\n  Evidence  a  structured  text.",
      "classes": [
        "TransferCheckResultV1",
        "TransferVerdictV1"
      ],
      "functions": [
        "check_payload_vocab_disjoint",
        "check_topology_signature_differs",
        "check_constraint_operator_vocab_differs",
        "check_transition_action_vocab_differs",
        "run_all_transfer_checks",
        "_extract_field_ids",
        "_compute_topology_signature",
        "_extract_ops_recursive",
        "_extract_constraint_ops",
        "_extract_action_vocab"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers",
        "core.proofs.induction.domain_spec_ir",
        "core.proofs.induction.evidence_stream"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.699500",
        "modified": "2026-02-21T21:49:26.699712",
        "modified_days_ago": 0,
        "lines": 378,
        "size_bytes": 12891,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/signing.py",
      "name": "signing.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Defines SterlingSigner and provides verify_signature.",
      "classes": [
        "SterlingSigner"
      ],
      "functions": [
        "verify_signature"
      ],
      "imports": [
        "base64",
        "json",
        "logging",
        "pathlib",
        "typing",
        "cryptography.hazmat.primitives",
        "cryptography.hazmat.primitives.asymmetric"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T16:30:35.446033",
        "modified": "2026-01-22T07:53:46.442834",
        "modified_days_ago": 29,
        "lines": 87,
        "size_bytes": 3220,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/stage_k_projection.py",
      "name": "stage_k_projection.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Stage K Report Projection V1: Deterministic commitment surface for Stage K reports.",
      "classes": [
        "StageKReportProjectionV1"
      ],
      "functions": [
        "build_projection_from_report",
        "compare_projections"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.commitment_hash"
      ],
      "constants": [
        "STAGEK_PROJECTION_SCHEMA_ID",
        "STAGEK_PROJECTION_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T13:44:26.234016",
        "modified": "2026-01-22T07:53:22.087110",
        "modified_days_ago": 29,
        "lines": 385,
        "size_bytes": 16317,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/stage_l_transfer_claim.py",
      "name": "stage_l_transfer_claim.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Stage L Transfer Claim V1 - H3.3 Cross-Domain Transfer Evidence.\n\nThis module defines the data structures for H3.3 cross-domain transfer claims.\nA transfer claim asserts that learned capabilities transfer from a source domain\nto a structurally different target domain.\n\nKey Requirements:\n1. Source and target domains must be structurally different\n2.",
      "classes": [
        "DomainType",
        "TransferType",
        "ClaimStatus",
        "DomainDescriptor",
        "StructuralDifferenceMetrics",
        "TransferEvidence",
        "StageLTransferClaimV1"
      ],
      "functions": [
        "compute_structural_difference"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing",
        "core.reasoning.stage_l_controls"
      ],
      "constants": [
        "STAGE_L_TRANSFER_CLAIM_SCHEMA_ID",
        "STAGE_L_TRANSFER_CLAIM_VERSION",
        "MIN_STRUCTURAL_DIFFERENCE_SCORE",
        "MIN_TRANSFER_PERFORMANCE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T07:51:18.483038",
        "modified": "2026-01-22T07:53:46.007326",
        "modified_days_ago": 29,
        "lines": 617,
        "size_bytes": 22831,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/step_witness.py",
      "name": "step_witness.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Content-addressed step witness for operator applications, binding operator execution to contract and state digests for replay verification.",
      "classes": [
        "StepWitnessV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.verification.hash_utils"
      ],
      "constants": [
        "_STEP_WITNESS_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T09:08:21.443718",
        "modified": "2026-02-19T09:08:21.443974",
        "modified_days_ago": 1,
        "lines": 73,
        "size_bytes": 2583,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Program synthesis proof contracts for the induction+synthesis lane.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.423490",
        "modified": "2026-02-21T15:38:13.423618",
        "modified_days_ago": 0,
        "lines": 1,
        "size_bytes": 74,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/builders.py",
      "name": "builders.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Builds deterministic synthesis tasks and program artifacts from DI inputs; generates operator candidates and witness bundles with governance checks; produces PS reports and manifests.",
      "classes": [],
      "functions": [
        "_stable_ps_failure_mode",
        "_build_ps_failure_manifest",
        "build_synthesis_task",
        "synthesize_program",
        "_synthesize_inner",
        "_build_refusal_artifacts"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.failures",
        "core.proofs.shared.manifest",
        "core.proofs.synthesis.exceptions",
        "core.proofs.synthesis.failures",
        "core.proofs.induction.domain_spec_ir",
        "core.proofs.induction.rule_ir"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.699764",
        "modified": "2026-02-21T21:49:26.699965",
        "modified_days_ago": 0,
        "lines": 433,
        "size_bytes": 15213,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/capsule_spec_ps.py",
      "name": "capsule_spec_ps.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "CapsuleSpecV1 builder for p14.ps (Program Synthesis lane).",
      "classes": [],
      "functions": [
        "validate_suite_id",
        "_validate_suite_ids",
        "build_p14_ps_capsule_spec",
        "spec_hash_surface_bytes"
      ],
      "imports": [
        "__future__",
        "re",
        "typing",
        "core.capsules.capsule_spec",
        "core.proofs.shared.canonical_json"
      ],
      "constants": [
        "_SUITE_ID_PATTERN",
        "_FORBIDDEN_SUITE_MARKERS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.423655",
        "modified": "2026-02-21T15:38:13.423749",
        "modified_days_ago": 0,
        "lines": 87,
        "size_bytes": 3559,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/exceptions.py",
      "name": "exceptions.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Throws _BudgetExceeded when synthesis exceeds max program nodes. Routes typed failures to PSBudgetExhaustedV1.",
      "classes": [
        "_BudgetExceeded"
      ],
      "functions": [],
      "imports": [
        "__future__"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700002",
        "modified": "2026-02-21T21:49:26.700130",
        "modified_days_ago": 0,
        "lines": 19,
        "size_bytes": 619,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/failures.py",
      "name": "failures.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Typed PS failure details for deterministic failure artifacts.",
      "classes": [
        "SeedPolicyV1",
        "BudgetV1",
        "BudgetUsageV1",
        "PSIllegalOperatorRefV1",
        "PSBudgetExhaustedV1",
        "PSUnresolvedUnknownsV1",
        "PSVerificationFailureV1",
        "PSInternalInvariantBrokenV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:38:13.423788",
        "modified": "2026-02-21T15:38:13.423923",
        "modified_days_ago": 0,
        "lines": 174,
        "size_bytes": 5278,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/operator_candidate.py",
      "name": "operator_candidate.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Operator candidate artifacts for synthesis.\n\nOperatorSpecCandidateV1 describes a candidate operator with preconditions,\neffects, cost model, and legality constraints.",
      "classes": [
        "PredicateRefV1",
        "DeltaDeclV1",
        "CostModelV1",
        "LegalityDeclV1",
        "OperatorSpecCandidateV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700216",
        "modified": "2026-02-21T21:49:26.700363",
        "modified_days_ago": 0,
        "lines": 229,
        "size_bytes": 7061,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/policies.py",
      "name": "policies.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Creates deterministic policy digest by binding SeedPolicyV1 and BudgetV1 structures for proof artifacts.",
      "classes": [
        "SynthesisPolicyV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.synthesis.failures"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700406",
        "modified": "2026-02-21T21:49:26.700514",
        "modified_days_ago": 0,
        "lines": 91,
        "size_bytes": 2801,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/program_ir.py",
      "name": "program_ir.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Program IR artifacts and typed shapes for deterministic synthesis with canonicalization policy, node/edge representations, and digest binding.",
      "classes": [
        "ProgramCanonicalizationV1",
        "ProgramNodeV1",
        "ProgramEdgeV1",
        "ProgramIRv1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700552",
        "modified": "2026-02-21T21:49:26.700655",
        "modified_days_ago": 0,
        "lines": 208,
        "size_bytes": 6141,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/synthesis_report.py",
      "name": "synthesis_report.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Generates claim-surface reports for program synthesis artifacts. Mirrors InductionReportV1 structure with digest verification. Uses DependencyManifestV1 for dependency tracking.",
      "classes": [
        "SynthesisReportV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.manifest"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700693",
        "modified": "2026-02-21T21:49:26.700791",
        "modified_days_ago": 0,
        "lines": 129,
        "size_bytes": 5361,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/synthesis_task.py",
      "name": "synthesis_task.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Synthesis task artifact defining the goal for program synthesis.",
      "classes": [
        "SynthesisTaskV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700826",
        "modified": "2026-02-21T21:49:26.700916",
        "modified_days_ago": 0,
        "lines": 70,
        "size_bytes": 2405,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/synthesis/witnesses.py",
      "name": "witnesses.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "StepWitnessV1, CounterexampleWitnessV1, MinimalityWitnessV1, and SynthesisWitnessBundleV1 artifacts produced for each synthesis plan step and counterexample evidence.  SHA256 digests and validated identifiers.  Used for verification and replay audit trails.",
      "classes": [
        "StepWitnessV1",
        "CounterexampleWitnessV1",
        "MinimalityWitnessV1",
        "SynthesisWitnessBundleV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.shared.canonical_json",
        "core.proofs.shared.digesting",
        "core.proofs.shared.identifiers"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T21:49:26.700950",
        "modified": "2026-02-21T21:49:26.701078",
        "modified_days_ago": 0,
        "lines": 248,
        "size_bytes": 9115,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/td12_certify.py",
      "name": "td12_certify.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Defines TD12Orchestrator.",
      "classes": [
        "TD12Orchestrator"
      ],
      "functions": [],
      "imports": [
        "json",
        "logging",
        "os",
        "subprocess",
        "sys",
        "uuid",
        "datetime",
        "pathlib",
        "typing",
        "core.proofs.artifact_hashing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T15:13:44.900822",
        "modified": "2026-01-23T18:07:50.706070",
        "modified_days_ago": 30,
        "lines": 584,
        "size_bytes": 23657,
        "author": null,
        "has_main": true
      }
    },
    {
      "path": "proofs/td12_dossier_snapshot.py",
      "name": "td12_dossier_snapshot.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "TD12 Dossier Snapshot: Deterministic snapshot projection for certificate binding.\n\nThis module provides functions for building and verifying the TD12 dossier snapshot\nthat is hashed into the certificate's `dossier_snapshot_hash`. The same function\nis used at promotion time (to build) and install time (to verify).",
      "classes": [
        "TD12DossierSnapshotMismatchError"
      ],
      "functions": [
        "build_td12_dossier_snapshot",
        "compute_td12_dossier_snapshot_hash",
        "verify_td12_dossier_snapshot_hash",
        "verify_td12_dossier_snapshot_hash_strict"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:31.311174",
        "modified": "2026-01-27T07:17:31.311343",
        "modified_days_ago": 24,
        "lines": 230,
        "size_bytes": 9029,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/td12_ms_certificate.py",
      "name": "td12_ms_certificate.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\":\"TD-12/MS Certificate that a promoted sketch is closure-bound (sketch_hash, artifact, D: closure_hash\n    as input (signing input to certified\n    {sketch_hash, policy_set (policy_ digest\n    of pre-dig (signing input\n    to cert (signing) sets\n    as required\n    ",
      "classes": [
        "TD12MSCertificateV1"
      ],
      "functions": [
        "verify_td12_ms_certificate",
        "verify_td12_ms_certificate_v2",
        "recompute_certificate_id"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.proofs.evidence_item_ir",
        "core.proofs.certification_blocker",
        "core.verification.hash_utils",
        "core.verification.hash_utils"
      ],
      "constants": [
        "TD12_MS_CERT_SCHEMA_ID",
        "TD12_MS_CERT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:17:15.995703",
        "modified": "2026-01-27T07:17:15.995838",
        "modified_days_ago": 24,
        "lines": 465,
        "size_bytes": 19743,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/td12_ms_integration.py",
      "name": "td12_ms_integration.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "TD-12 MS Certificate Integration Helper\n\nProvides helpers for integrating MS certificates into TD-12 certification.\nHandles MS verification, policy enforcement, and artifact reference creation.\n\nDESIGN DECISION (Path A - Release Posture):\nTD-12 ALWAYS runs MS verification in STRICT mode.",
      "classes": [],
      "functions": [
        "resolve_artifact_path",
        "verify_ms_certificate_for_td12",
        "create_ms_certificate_ref",
        "build_attempt_report"
      ],
      "imports": [
        "logging",
        "pathlib",
        "typing",
        "core.memory.certification",
        "core.memory.verifier",
        "core.memory.verifier",
        "core.proofs.td12_policy"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-21T19:34:33.800061",
        "modified": "2026-01-22T07:53:46.061575",
        "modified_days_ago": 29,
        "lines": 328,
        "size_bytes": 11823,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/td12_policy.py",
      "name": "td12_policy.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "TD-12 policy specifies TD-12 verification requirements and recovery allowances, enforcing STRICT MS verification only. Never selects FORENSICS mode. Policy attestation must be recorded. Certificates with salvage evidence are rejected. This enforces release posture.",
      "classes": [
        "TD12Policy"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing",
        "core.memory.verifier"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-21T19:27:38.959186",
        "modified": "2026-01-22T07:53:46.081733",
        "modified_days_ago": 29,
        "lines": 144,
        "size_bytes": 5835,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/td12_verify.py",
      "name": "td12_verify.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Verifies TD12 certificates by checking claim and artifact hashes against policy constraints.",
      "classes": [],
      "functions": [
        "verify_certificate"
      ],
      "imports": [
        "json",
        "logging",
        "sys",
        "pathlib",
        "core.memory.certification",
        "core.memory.verifier",
        "core.memory.verifier",
        "core.proofs.artifact_hashing",
        "core.proofs.td12_ms_integration",
        "core.proofs.td12_policy"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-20T16:04:53.646719",
        "modified": "2026-01-22T07:53:46.122593",
        "modified_days_ago": 29,
        "lines": 318,
        "size_bytes": 13685,
        "author": null,
        "has_main": true
      }
    },
    {
      "path": "proofs/td7/__init__.py",
      "name": "__init__.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:25:55.222906",
        "modified": "2026-01-22T07:53:46.086714",
        "modified_days_ago": 32,
        "lines": 0,
        "size_bytes": 0,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "proofs/td7/necessity.py",
      "name": "necessity.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "Provides APIs to prove constraints are necessary to prevent cheating via forbidden shortcuts.",
      "classes": [
        "NecessityVerdict"
      ],
      "functions": [
        "prove_necessity"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "sys",
        "dataclasses",
        "pathlib",
        "typing",
        "core.benchmarks.fence.engine",
        "core.proofs.artifact_hashing",
        "core.proofs.determinism"
      ],
      "constants": [
        "SCHEMA_IDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:26:02.097972",
        "modified": "2026-01-22T07:53:46.442850",
        "modified_days_ago": 29,
        "lines": 295,
        "size_bytes": 10006,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "proofs/verification_bundle.py",
      "name": "verification_bundle.py",
      "category": "TD12/MS certificates, proof bundles, and replay verification",
      "status": "active",
      "description": "{\"description\": \"A JSON does not include over signature data, only includes the \"verified signature\", as per ... ensures authenticity, \n{\"type\": \"provenance\" value\n{\"main\": [see core (not \n\"optional\": J-WITHINHER.",
      "classes": [
        "CertificateProjection",
        "PromotedOperatorProjection",
        "RevocationSnapshot",
        "VerificationBundleV1"
      ],
      "functions": [
        "create_verification_bundle",
        "create_verification_bundle_from_report"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.canonicalization",
        "core.proofs.commitment_hash"
      ],
      "constants": [
        "VERIFICATION_BUNDLE_SCHEMA_ID",
        "VERIFICATION_BUNDLE_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-21T13:49:07.199041",
        "modified": "2026-01-22T07:53:46.043037",
        "modified_days_ago": 29,
        "lines": 468,
        "size_bytes": 18492,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/__init__.py",
      "name": "__init__.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "Sterling Pseudocode IR Module.\n\nLanguage-agnostic intermediate representation for code reasoning.\nThis is the central IR that supports:\n- Code reasoning world (operators over program structure)\n- Spec bridge (human pseudocode <-> code)\n- Future: Latent compression layer\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.pseudocode.ir",
        "core.pseudocode.lowering",
        "core.pseudocode.operators",
        "core.pseudocode.semantics",
        "core.pseudocode.tagger"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:42:56.972572",
        "modified": "2026-01-22T07:53:46.442960",
        "modified_days_ago": 29,
        "lines": 166,
        "size_bytes": 3086,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/ir.py",
      "name": "ir.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "{\"description\": \"Defines IR node types and required invariants for a static single assignment semantics (no effects, track each\n    node meta\n    i8 defined\n    effects\n    (no effects\n    verif\n    class, static\n    verif\n    class\n    meta\n    analysis: static\n    GJ type-checking\n    context: the\n    verif\n    nodes\n    use\n    meta\n    analysis\n    verif\n    class\n    context\n    analysis\n    verif\n    analysis\n    meta\n    analysis\n    nodes\n    meta\n    analysis\n    context\n    analysis\n ...",
      "classes": [
        "IRValidationError",
        "SourceSpan",
        "PMeta",
        "BinaryOpKind",
        "UnaryOpKind",
        "HoleReason",
        "PHole",
        "PNamedType",
        "PUnknownType",
        "PNamePattern",
        "PTargetName",
        "PTargetMember",
        "PTargetIndex",
        "PIdentifier",
        "PLiteral",
        "PBinaryOp",
        "PUnaryOp",
        "PMember",
        "PIndex",
        "PCall",
        "PVarDecl",
        "PAssign",
        "PBlock",
        "PIf",
        "PWhile",
        "PForEach",
        "PReturn",
        "PExprStmt",
        "PParam",
        "PSpecs",
        "PFunction",
        "PImport",
        "PModule",
        "PProgram"
      ],
      "functions": [
        "name_pattern_to_target",
        "_collect_symbol_ids",
        "_collect_binding_symbol_ids",
        "_collect_referencing_symbol_ids",
        "_validate_unique_symbol_ids",
        "_validate_function_has_symbol_id",
        "_validate_empty_names",
        "_validate_symbol_references",
        "_count_holes",
        "validate_program"
      ],
      "imports": [
        "__future__",
        "json",
        "dataclasses",
        "enum",
        "typing",
        "core.pseudocode.semantics"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:45:11.175303",
        "modified": "2026-01-22T07:53:46.442931",
        "modified_days_ago": 29,
        "lines": 2027,
        "size_bytes": 64201,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/lowering/__init__.py",
      "name": "__init__.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "Pseudocode IR Lowering Module.\n\nContains front-ends for lowering language-specific ASTs to Pseudocode IR.\n\nv0: Python only\nFuture: TypeScript, Rust\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.pseudocode.lowering.python"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:45:20.504867",
        "modified": "2026-01-22T07:53:46.443025",
        "modified_days_ago": 29,
        "lines": 23,
        "size_bytes": 379,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/lowering/python.py",
      "name": "python.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "{\"type\":\"function\",\"description\":\"Pars (lowering): Python AST -> canonical node map; only syntax trees\n\"\"\"\n@type: (ast)\n    \"\"\"  \n  (optional-sy\n  ast -> Pseudocode:  (Python) to (IR)  \n  \"\"\"  \n  node and  \n  n  ast  to  (Pseud  ocode  (Python) to  pseud  ( syntax tree emit 5  d nodes  \n  for each  (Python) node and  \n  n  (optional) in  \n  e  ntree\n",
      "classes": [
        "LoweringError",
        "PythonLowerer"
      ],
      "functions": [
        "lower_python_source"
      ],
      "imports": [
        "__future__",
        "ast",
        "logging",
        "dataclasses",
        "typing",
        "core.pseudocode.ir",
        "core.pseudocode.semantics"
      ],
      "constants": [
        "BINARY_OP_MAP",
        "COMPARE_OP_MAP",
        "BOOL_OP_MAP",
        "UNARY_OP_MAP"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-09T13:52:27.345882",
        "modified": "2026-01-22T07:53:46.442977",
        "modified_days_ago": 29,
        "lines": 1229,
        "size_bytes": 42441,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/operators.py",
      "name": "operators.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "{\"type\":\"function\",\"description\":\"Apply left-hand side of a rule application\\n\\n\\n# Rule Applications of a rule\\n# to LHS\\n\\n# each rule at a given a context\\n# of a rule\\n# map: \\n from input to output\\n# node-sym a graph as white nodes (do not use node- with rule process node. Not: Post-nof a graph, node.",
      "classes": [
        "OperatorResult",
        "MapPattern",
        "FilterPattern",
        "ReducePattern",
        "LiftPatternOperator",
        "ExtractableBlock",
        "ExtractBlockOperator"
      ],
      "functions": [
        "_find_foreach_loops",
        "_is_simple_body",
        "_has_early_exit",
        "_detect_map_pattern",
        "_detect_filter_pattern",
        "_find_used_variables",
        "_find_defined_variables",
        "_analyze_block_data_flow",
        "_find_stmt_used_variables",
        "get_operator"
      ],
      "imports": [
        "__future__",
        "copy",
        "dataclasses",
        "typing",
        "core.pseudocode.ir",
        "core.pseudocode.semantics"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:50:54.474003",
        "modified": "2026-01-22T07:53:46.442947",
        "modified_days_ago": 29,
        "lines": 855,
        "size_bytes": 26983,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/semantics.py",
      "name": "semantics.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "Defines domain-specific semantic and effect tags for pseudocode IR. Invariant ensures all tags are known; used to annotate function calls and operations without language dependency.",
      "classes": [
        "EffectTag",
        "SemanticTag"
      ],
      "functions": [],
      "imports": [
        "enum"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:43:25.166191",
        "modified": "2026-01-22T07:53:46.442968",
        "modified_days_ago": 29,
        "lines": 350,
        "size_bytes": 9120,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "pseudocode/tagger.py",
      "name": "tagger.py",
      "category": "Pseudocode IR and processing",
      "status": "active",
      "description": "Semantic tagger for calls in Pseudocode IR. Adds semantic tags via language-specific pattern matching before operator execution. Pure pass; does not transform structure or infer types.",
      "classes": [
        "SemanticTagger"
      ],
      "functions": [
        "tag_program"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.pseudocode.ir",
        "core.pseudocode.semantics"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:48:10.446676",
        "modified": "2026-01-22T07:53:46.442929",
        "modified_days_ago": 29,
        "lines": 316,
        "size_bytes": 10982,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "realization/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Realization Module.\n\nProvides IR \u2192 text realization with governance contracts.\nCurrent implementation is template-based; future versions will support diffusion.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.realization.spec"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T15:22:28.652534",
        "modified": "2026-01-24T15:22:28.652653",
        "modified_days_ago": 27,
        "lines": 38,
        "size_bytes": 923,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "realization/spec.py",
      "name": "spec.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"@type\": \"REALIZATION_Spec_Gen\" to ensure JSON object has all required fields\nMUST_ require_{object} to {value}\nMUST_Masked_ ask: {object} a {asked_ for\nMUST\nMUST_Slot_know\n    JSON\n    \"\"\"\n    @dataclass\n    from core. Realization import\n    slots\n    and\n    style_ aligned\n    for\n        template\n    as\n    JSONL  for\n        a 1.2 t slots\n        I  deterministic\n    output\n    key for z\n    \"\"\"|  JSON  s  ...\"\"\"  JSON  s  ...",
      "classes": [
        "MaskIntent",
        "RealizerMode",
        "RealizerId",
        "MaskSlot",
        "RealizationSpec"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "enum",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [
        "REALIZATION_SPEC_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T18:33:35.763158",
        "modified": "2026-02-17T18:33:35.763383",
        "modified_days_ago": 3,
        "lines": 293,
        "size_bytes": 9811,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/__init__.py",
      "name": "__init__.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Reasoning components for Sterling.\n\nContains rule engine, planner, and verifier modules that perform\nsymbolic reasoning over knowledge graphs and IR structures.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "__getattr__",
        "__dir__"
      ],
      "imports": [
        "importlib",
        "typing",
        "deterministic_replay",
        "failure_taxonomy",
        "instrumented_search",
        "loop.types",
        "pn_task",
        "search",
        "search",
        "staged_search"
      ],
      "constants": [
        "_LAZY_LOOP_EXPORTS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:20:57.573968",
        "modified": "2026-01-22T07:53:46.506042",
        "modified_days_ago": 29,
        "lines": 259,
        "size_bytes": 6336,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/_apply_impl.py",
      "name": "_apply_impl.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "verify for each operator. \n  runs a  in a sandbox or block.  execution. Do not interpret. G",
      "classes": [
        "AcceptedSuccessor"
      ],
      "functions": [
        "_diff_states",
        "_apply_impl",
        "_to_operator_category",
        "_emit_operator_application"
      ],
      "imports": [
        "__future__",
        "logging",
        "time",
        "copy",
        "dataclasses",
        "typing",
        "core.contracts.semantic_edits",
        "core.reasoning.transactional_apply"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.355359",
        "modified": "2026-01-22T16:54:03.355546",
        "modified_days_ago": 29,
        "lines": 913,
        "size_bytes": 38772,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/_transactional_apply.py",
      "name": "_transactional_apply.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Private _transactional_apply executes operators within a gated context. Only permitted via gated_apply in core/operators/gate.py. Used for state transformation under strict governance.",
      "classes": [],
      "functions": [
        "_transactional_apply"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [
        "ALLOWED_CALL_SITES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.355658",
        "modified": "2026-02-17T10:09:41.669005",
        "modified_days_ago": 3,
        "lines": 136,
        "size_bytes": 6049,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/backtracking.py",
      "name": "backtracking.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "BacktrackingManager handles dead-end recovery by storing and matching CheckpointState and DeadEndSignature records. Backtracking uses the KG decay engine to track and avoid repeated failures during search. Class definitions and state tracking are integrated for safe backtracking in Sterling's reasoning loop.",
      "classes": [
        "CheckpointState",
        "BacktrackResult",
        "DeadEndSignature",
        "BacktrackingManager"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T22:57:58.731357",
        "modified": "2026-01-22T07:53:46.504650",
        "modified_days_ago": 29,
        "lines": 336,
        "size_bytes": 10623,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/benchmarks.py",
      "name": "benchmarks.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Defines benchmark cases for Sterling's TD-6 evaluation including long-chain, distractor, backtracking, and invariant-trap scenarios. Provides typed, auditable test cases with metrics for success and error rates.",
      "classes": [
        "BenchmarkType",
        "BenchmarkCase",
        "BenchmarkSuite"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T21:37:58.975610",
        "modified": "2026-01-22T07:53:46.504675",
        "modified_days_ago": 29,
        "lines": 822,
        "size_bytes": 34860,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/confidence.py",
      "name": "confidence.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Confidence estimation from multiple sources guides backtracking, abort, and slow-down decisions in Sterling's reasoning loop.",
      "classes": [
        "ConfidenceAction",
        "ConfidenceThresholds",
        "ConfidenceSignal",
        "ConfidenceHistory",
        "ConfidenceTracker"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T23:00:37.558575",
        "modified": "2026-01-22T07:53:46.506145",
        "modified_days_ago": 29,
        "lines": 330,
        "size_bytes": 10195,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/dataset_builder.py",
      "name": "dataset_builder.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Builds TransitionExample datasets from reasoning episodes to train a model that scores valid transitions (parent_ state \u2192 child_state via edge).",
      "classes": [],
      "functions": [
        "get_success_path_edge_ids",
        "build_transition_examples_from_episode",
        "build_transition_dataset",
        "save_transition_dataset_jsonl",
        "transition_dataset_to_numpy"
      ],
      "imports": [
        "__future__",
        "json",
        "pathlib",
        "typing",
        "loop.types",
        "state_graph",
        "value_features"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-29T11:42:30.638949",
        "modified": "2026-01-22T07:53:46.506005",
        "modified_days_ago": 29,
        "lines": 307,
        "size_bytes": 9316,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/deterministic_replay.py",
      "name": "deterministic_replay.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "ReplayManager. Records every action.",
      "classes": [
        "RNGState",
        "OrderedCandidate",
        "ReplayMetadata",
        "ReplayArtifact",
        "ReplayManager"
      ],
      "functions": [
        "set_deterministic_mode",
        "canonical_state_hash",
        "canonical_candidate_hash",
        "stable_sort_candidates"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "os",
        "random",
        "subprocess",
        "dataclasses",
        "datetime",
        "pathlib"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.583364",
        "modified": "2026-02-21T15:51:43.583483",
        "modified_days_ago": 2,
        "lines": 721,
        "size_bytes": 21603,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/episode_loader.py",
      "name": "episode_loader.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Loads and reconstructs episodes from log data to enable analysis and dataset creation. Validates episodes using prior influence and registry hash. Supports filtering and statistics extraction from logged episodes.",
      "classes": [
        "ValidationIssue",
        "EpisodeValidationResult",
        "LoggedEpisode",
        "EpisodeLoader"
      ],
      "functions": [
        "load_episodes_from_log",
        "_reconstruct_episode_from_record",
        "_reconstruct_state_graph",
        "_reconstruct_episode_profile",
        "filter_episodes_by_criteria",
        "get_episode_statistics"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "episode_profile",
        "loop.types",
        "state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.094067",
        "modified": "2026-01-22T23:15:28.725380",
        "modified_days_ago": 29,
        "lines": 575,
        "size_bytes": 22038,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/episode_logger.py",
      "name": "episode_logger.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Episode logging infrastructure for Sterling reasoning episodes. Serializes StateGraph and component states to JSONL with typed episode schema. Supports v1 (ad-hoc) and v2 (typed state snapshots).",
      "classes": [
        "EpisodeLogger",
        "EpisodeLoggerV2"
      ],
      "functions": [
        "_to_serializable",
        "create_run_directory",
        "serialize_state_node",
        "serialize_utterance_state",
        "serialize_world_state",
        "serialize_prior_influence",
        "deserialize_prior_influence",
        "deserialize_state_node",
        "load_episodes",
        "load_v2_episodes"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "os",
        "datetime",
        "pathlib",
        "typing",
        "episode_profile",
        "loop.types",
        "state_graph"
      ],
      "constants": [
        "SCHEMA_V1",
        "SCHEMA_V2"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T19:08:49.367989",
        "modified": "2026-02-18T19:08:49.368536",
        "modified_days_ago": 2,
        "lines": 1258,
        "size_bytes": 51367,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/episode_profile.py",
      "name": "episode_profile.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Computes and stores episode metrics from StateGraph and ReasoningResult for analysis and training. Produces an EpisodeProfile with operator mix, search statistics, and outcome indicators.",
      "classes": [
        "OperatorMix",
        "EpisodeProfile"
      ],
      "functions": [
        "compute_episode_profile",
        "format_episode_profile"
      ],
      "imports": [
        "__future__",
        "math",
        "dataclasses",
        "typing",
        "state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-29T11:37:03.412261",
        "modified": "2026-01-22T07:53:46.504812",
        "modified_days_ago": 29,
        "lines": 237,
        "size_bytes": 7836,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/episode_report.py",
      "name": "episode_report.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "TD-6 Episode Report Printer.\n\nGenerates human-readable episode reports with:\n- Branch allocation summary\n- First-breakpoint diff\n- Failure taxonomy summary\n\nAuthor: @darianrosebrook",
      "classes": [
        "EpisodeReport",
        "EpisodeReportPrinter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T21:38:15.486407",
        "modified": "2026-01-22T07:53:46.505961",
        "modified_days_ago": 29,
        "lines": 295,
        "size_bytes": 10048,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/episode_select.py",
      "name": "episode_select.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Episode selection language for filtering reasoning episodes.\n\nProvides a simple, expressive DSL for slicing episode corpora without\ntouching the core loop or re-running episodes.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [
        "get_field",
        "eval_condition",
        "eval_expr",
        "filter_episode_records",
        "success_only",
        "failures_only",
        "task_type_is",
        "task_type_in",
        "goal_depth_le",
        "goal_depth_between"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [
        "SELECTORS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413314",
        "modified": "2026-01-22T07:53:46.504788",
        "modified_days_ago": 29,
        "lines": 453,
        "size_bytes": 13769,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/failure_taxonomy.py",
      "name": "failure_taxonomy.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\": \"Provides a structured failure taxonomy and audit trail for search episode failures using P5-Lite for context recording. Failure types, step, branch, and drift data. \n failure analysis and graph state diff debugging data from states. \nRecord/Log as structured. \nFail/Log with test & context. \n",
      "classes": [
        "FailureType",
        "FailureRecord",
        "BranchSummary",
        "BranchAllocationSummary",
        "AuditEntry",
        "AuditTrail",
        "FailureAnalyzer"
      ],
      "functions": [
        "format_state_diff",
        "print_first_breakpoint"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T19:17:42.002722",
        "modified": "2026-01-22T07:53:46.506012",
        "modified_days_ago": 29,
        "lines": 739,
        "size_bytes": 22686,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/graph_emitter.py",
      "name": "graph_emitter.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "StateGraph population interface with event handlers for node creation, edge expansion, and meta payload injection. Enforces canonical StateGraphEmitter for ENG-3A compliance.",
      "classes": [
        "GraphEmitter",
        "StateGraphEmitter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "os",
        "re",
        "abc",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:52:39.908696",
        "modified": "2026-02-18T17:52:39.908851",
        "modified_days_ago": 2,
        "lines": 670,
        "size_bytes": 25491,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/__init__.py",
      "name": "__init__.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Instrumented Search Package.\n\nModular implementation of comprehensive search instrumentation, extracted from\nthe monolithic instrumented_search.py.\n\nPublic API exports for backward compatibility.\n\nAuthor: @darianrosebrook\nDate: January 2026",
      "classes": [],
      "functions": [],
      "imports": [
        "core.reasoning.instrumented.core",
        "core.reasoning.instrumented.influence_seam",
        "core.reasoning.instrumented.types",
        "core.reasoning.instrumented.utils",
        "core.reasoning.instrumented.witness_sink"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T22:54:08.545044",
        "modified": "2026-01-24T22:54:08.545171",
        "modified_days_ago": 27,
        "lines": 79,
        "size_bytes": 2578,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/core.py",
      "name": "core.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "InstrumentedSearch wraps ImmutableSearchTree with step-level logging, failure taxonomy analysis, audit trails, and branch tracking.",
      "classes": [
        "InstrumentedSearch"
      ],
      "functions": [
        "_now_or_anchor",
        "_is_parallel_expansion_enabled_legacy"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "os",
        "time",
        "datetime",
        "typing",
        "core.reasoning.failure_taxonomy",
        "core.reasoning.instrumented.diagnostics"
      ],
      "constants": [
        "_CERTIFYING_TIME_ANCHOR"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:52:39.909096",
        "modified": "2026-02-18T17:52:39.909389",
        "modified_days_ago": 2,
        "lines": 2570,
        "size_bytes": 117091,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/diagnostics.py",
      "name": "diagnostics.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Tracks timing and diagnostics for instrumented search node expansion in Sterling's reasoning engine.",
      "classes": [
        "ExpansionDiagnostics",
        "DiagnosticManager"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-14T16:11:39.773551",
        "modified": "2026-01-21T11:21:45.568830",
        "modified_days_ago": 30,
        "lines": 172,
        "size_bytes": 6644,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/governance.py",
      "name": "governance.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Manages governance, emits audit trails, and flushes observations for operator execution using a structured registry and world adapter integration.",
      "classes": [
        "GovernanceManager"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "datetime",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:52:39.909513",
        "modified": "2026-02-18T17:52:39.909669",
        "modified_days_ago": 2,
        "lines": 384,
        "size_bytes": 15088,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/influence_seam.py",
      "name": "influence_seam.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Influence Seam: Single Integration Point for Landmark Influence (Milestone 3.4.1).\n\nThis module provides the SINGLE seam where landmark influence can modify search decisions.\nAll influence must flow through this seam to ensure:\n\n1. No hidden routers (every score change has a typed witness)\n2. Replay-grade determinism (identical inputs produce identical witnesses)\n3.",
      "classes": [
        "HiddenRouterViolation",
        "StaleEpochError",
        "InfluenceWitnessDigestV1",
        "DiscoveryWitnessV1",
        "InfluenceSeamContext",
        "InfluenceSeamResult",
        "InfluenceSeam"
      ],
      "functions": [
        "quantize_float",
        "compute_candidate_ids_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "core.reasoning.landmark_influence"
      ],
      "constants": [
        "QUANTIZATION_FACTOR"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T00:01:54.049182",
        "modified": "2026-02-15T00:01:54.049333",
        "modified_days_ago": 6,
        "lines": 1012,
        "size_bytes": 38854,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/parallel_expansion.py",
      "name": "parallel_expansion.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Parallel expansion infrastructure for instrumented search.\n\nImplements PR-3 from the parallelization integration plan:\n- Worker function for candidate application (pure, no side effects)\n- Deterministic reducer for candidate selection\n- StepIndexPlan preallocation\n- ReducerWitnessV1 emission\n\nArchitecture:\n    Workers propose. Reducers decide. Commit writes truth.",
      "classes": [
        "CachePuritySnapshot",
        "CachePurityViolationError",
        "StepIndexPlanV1",
        "WorkerContext"
      ],
      "functions": [
        "build_step_index_plan",
        "apply_single_candidate",
        "reduce_candidate_results",
        "expand_node_parallel"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "time",
        "dataclasses",
        "typing",
        "core.reasoning.instrumented.types",
        "core.reasoning.parallel_executor"
      ],
      "constants": [
        "_PRAGMATIC_OPERATOR_IDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T22:55:13.814375",
        "modified": "2026-02-15T22:55:13.814777",
        "modified_days_ago": 5,
        "lines": 923,
        "size_bytes": 36071,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/policy.py",
      "name": "policy.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Manages search policy by tracking hypothesis influence and prior boosts, maintaining diagnostic data and witness sets for certified evaluation.",
      "classes": [
        "PolicyManager"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.reasoning.instrumented.types",
        "core.reasoning.search"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-29T06:50:07.738170",
        "modified": "2026-01-29T06:50:07.738287",
        "modified_days_ago": 22,
        "lines": 549,
        "size_bytes": 22436,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/types.py",
      "name": "types.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "InstrumentedSearch types for tracking operator application, status, and dependency identity in Sterling's reasoning engine.",
      "classes": [
        "CandidateIdentityV1",
        "CandidateResultStatus",
        "CandidateSpecV1",
        "CandidateResultV1",
        "ApplyEnvelopeV1",
        "EnvelopeTelemetryV1",
        "ExpansionReducerResultV1",
        "CandidateSetDiff",
        "InstrumentationConfig",
        "WitnessDeclaration",
        "InstrumentedSearchResult"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "datetime",
        "enum",
        "pathlib",
        "typing",
        "hashlib",
        "json"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:18:06.370972",
        "modified": "2026-01-24T23:18:06.371183",
        "modified_days_ago": 27,
        "lines": 920,
        "size_bytes": 33956,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/utils.py",
      "name": "utils.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Provides utility functions for instrumented search, including graph emission and state management. Exports helpers from core reasoning and induction modules for instrumented search workflows.",
      "classes": [],
      "functions": [
        "run_instrumented_search"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-11T01:18:47.635603",
        "modified": "2026-01-21T11:07:23.563086",
        "modified_days_ago": 30,
        "lines": 118,
        "size_bytes": 5226,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented/witness_sink.py",
      "name": "witness_sink.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\": {\"value\": \"a function (optional, a\n  - Asynchronous emission\n  - returns (dict)\n  - Properly formatted\n  -  and\n  -  -  Form/verify\n  -  Go- 1 256  -  Use\n  -  As in commit\n  -  return (other states\n  -  As 1  -  As 1  -  return (optional)\n -  As 1  -  return  (optional)\n  -  As 0  -  return  (optional)\n  -  As 0  -  As 0  -  As 1  -  As 1  -  As 0  -  As 0  -  As  -  return 0  -  As 0  -  return  (optional",
      "classes": [
        "WitnessProtocol",
        "WitnessEntryV1",
        "EpisodeWitnessManifestV1",
        "_StagedWrite",
        "WitnessSink"
      ],
      "functions": [
        "_validate_logical_name"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "os",
        "re",
        "tempfile",
        "dataclasses",
        "pathlib",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [
        "LOGICAL_NAME_PATTERN"
      ],
      "decorators_used": [
        "runtime_checkable",
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T23:52:04.344672",
        "modified": "2026-01-24T23:52:04.344779",
        "modified_days_ago": 27,
        "lines": 631,
        "size_bytes": 23376,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/instrumented_search.py",
      "name": "instrumented_search.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Provides backward compatibility for core.reasoning.instrumented_search by wrapping its functionality in core.reasoning.search.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.reasoning.instrumented.core",
        "core.reasoning.instrumented.types",
        "core.reasoning.instrumented.utils"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-10T15:31:19.688334",
        "modified": "2026-01-11T02:11:05.342662",
        "modified_days_ago": 40,
        "lines": 50,
        "size_bytes": 1892,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/intent_prior.py",
      "name": "intent_prior.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Intent-Guided Action Prior for search guidance.\n\nThis module implements action priors that use intent predictions to guide\nsearch toward operators more likely to satisfy the user's goal.\n\nThe prior works by:\n1. Predicting intent distribution for the current state\n2. Computing affinity between intents and operator categories\n3.",
      "classes": [
        "IntentPriorConfig",
        "IntentGuidedActionPrior"
      ],
      "functions": [
        "compute_linguistic_prior_boost",
        "_safe_call",
        "create_intent_prior",
        "action_prior_from_linguistic_intent"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.intent.model",
        "core.intent.types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T21:30:08.691056",
        "modified": "2026-01-22T07:53:46.504758",
        "modified_days_ago": 29,
        "lines": 502,
        "size_bytes": 15608,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/landmark_influence.py",
      "name": "landmark_influence.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\n  \"description\": \"...\",\n  \"influence\" f\" in class(Booster, # ... else\n    # default- option to check\n    if input(1.0 (no i nput(ste in py\n    # all(1. py\n    # All m (when to check ex(1. py\n    # require\n    influence(1.10  == \"no\" in py\n    # all(1. py\n    # require(1.0\n    m  ==2.0() # a(1.0 graph\n    # all(landmark) == own\n    # new class(3.0 data\n    # at each(2. config to\n    #  require(2.1: 0  require\n    # a 1.0 data\n    # 4 require",
      "classes": [
        "InfluenceType",
        "InfluenceOutcome",
        "LandmarkInfluenceConfig",
        "InfluenceAttempt",
        "InfluenceResult",
        "InfluenceTelemetry",
        "LandmarkInfluence",
        "InfluenceGuard"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [
        "DEFAULT_INFLUENCE_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.691187",
        "modified": "2026-01-22T23:14:27.691619",
        "modified_days_ago": 29,
        "lines": 821,
        "size_bytes": 28556,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/learning.py",
      "name": "learning.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "In-world learning infrastructure for Sterling reasoning loop.\n\nProvides pattern memory, failure catalog, and online adaptation\nthat integrates with the KG decay system.\n\nAuthor: @darianrosebrook",
      "classes": [
        "SuccessPattern",
        "PatternMemory",
        "FailureEntry",
        "FailureCatalog",
        "LearningController"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T23:01:47.361969",
        "modified": "2026-01-22T07:53:46.504706",
        "modified_days_ago": 29,
        "lines": 695,
        "size_bytes": 21493,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/__init__.py",
      "name": "__init__.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [
        "__getattr__",
        "__dir__"
      ],
      "imports": [
        "importlib",
        "typing",
        "kg_interface",
        "types"
      ],
      "constants": [
        "_LAZY_EXPORTS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-10T23:58:49.896041",
        "modified": "2026-01-15T20:38:16.810369",
        "modified_days_ago": 38,
        "lines": 54,
        "size_bytes": 1541,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/components.py",
      "name": "components.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "stable",
      "description": "Enforces deterministic value-head scoring by pinning model via content hash and quantizing scores to defined precision.",
      "classes": [
        "ValueHeadScoringContract",
        "SWMSelector",
        "ValueHead"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.contracts.governance_status",
        "core.reasoning.state_graph",
        "core.reasoning.value_features",
        "kg.swm_policy"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 169,
            "content": "# TODO: Implement policy-based candidate scoring and selection",
            "file_path": "core/reasoning/loop/components.py"
          },
          {
            "line_number": 375,
            "content": "# TODO: Implement learned node scoring with encoder or transition scorer",
            "file_path": "core/reasoning/loop/components.py"
          }
        ]
      },
      "staleness_level": "potentially_stale",
      "staleness_score": 0.5,
      "staleness_indicators": [
        "Imports deprecated module 'core.reasoning.value_features'. Use core.features instead"
      ],
      "recommendation": "Review for relevance - consider updating or archiving. Check test coverage and usage.",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T16:24:17.111502",
        "modified": "2026-02-17T16:24:17.111601",
        "modified_days_ago": 3,
        "lines": 623,
        "size_bytes": 24280,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/frontier_snapshot.py",
      "name": "frontier_snapshot.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Captures a structured, time-stamped snapshot of the current frontier state for debugging and analysis. Does not affect search ordering or result hashing. Schema: 'packed_frontier_snapshot.v1. Used for parity and divergence diagnosis.",
      "classes": [
        "FrontierSnapshotEntry",
        "FrontierSnapshot"
      ],
      "functions": [
        "_compute_frontier_fingerprint",
        "capture_frontier_snapshot"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "heapq",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "SNAPSHOT_SCHEMA",
        "_DEFAULT_MAX_ENTRIES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T21:20:58.757288",
        "modified": "2026-02-18T21:20:58.757411",
        "modified_days_ago": 2,
        "lines": 240,
        "size_bytes": 8685,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/kg_interface.py",
      "name": "kg_interface.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Provides a minimal interface for the Sterling reasoning loop to access KG nodes and edges efficiently with caching. Abstracts over KG implementations for neighbor and degree lookups.",
      "classes": [
        "KGInterface"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T18:58:05.671938",
        "modified": "2026-02-17T18:58:05.672291",
        "modified_days_ago": 3,
        "lines": 468,
        "size_bytes": 19519,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/main.py",
      "name": "main.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Orchestrates reasoning by linking state graphs, SWM policies, path algebra, and value heads. Orchestrates search via selected strategies and enforces heuristic scoring with stand-in nodes/edges for performance.",
      "classes": [
        "_LightChild",
        "_DummyStateNode",
        "_DummyOperatorEdge",
        "SterlingReasoningLoop",
        "Candidate"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "pathlib",
        "typing",
        "core.reasoning.state_graph",
        "kg.path_algebra",
        "kg.query",
        "kg.swm_policy",
        "components"
      ],
      "constants": [
        "_DUMMY_STATE_NODE",
        "_DUMMY_OPERATOR_EDGE"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T11:50:43.067182",
        "modified": "2026-02-18T11:50:43.067586",
        "modified_days_ago": 2,
        "lines": 604,
        "size_bytes": 25183,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/node_key_hash.py",
      "name": "node_key_hash.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Computes a fixed u64 node key from node_id for tie-breaking in packed-frontier ordering. Stores bidirectional id/key mapping to detect collisions. Uses SHA-256 hash truncated to u64. Node_id no longer used for ordering after key computed.",
      "classes": [
        "NodeKeyRegistry"
      ],
      "functions": [
        "compute_node_key"
      ],
      "imports": [
        "__future__",
        "hashlib"
      ],
      "constants": [
        "DOMAIN_SEP"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T06:59:41.735741",
        "modified": "2026-02-17T06:59:41.736081",
        "modified_days_ago": 3,
        "lines": 56,
        "size_bytes": 2003,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/score_quantizer.py",
      "name": "score_quantizer.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\"Q4 score quantization using half-up rounding (floor(x * 10000.0 + 0.5 \u2192 integer via floor(x * 10000.0 (ties- to even for positive .5 \u2192 12\nReturn integer (x \u2192 i64 (half-up: floor(x * 10000.0 (ties- to-even)\nAuthor: @darianrose\n",
      "classes": [],
      "functions": [
        "quantize_q4",
        "priority_q4_to_score"
      ],
      "imports": [
        "__future__",
        "math"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T20:15:41.884957",
        "modified": "2026-02-17T20:15:41.885113",
        "modified_days_ago": 3,
        "lines": 52,
        "size_bytes": 1616,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/search_strategies.py",
      "name": "search_strategies.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Search strategies for the Sterling reasoning loop.",
      "classes": [],
      "functions": [
        "_get_task_max_steps",
        "_get_allowed_edge_types",
        "_build_reverse_adjacency",
        "_get_reverse_neighbors",
        "_filter_and_sort_neighbors",
        "_validate_start_goal",
        "run_bfs",
        "run_greedy_search",
        "run_best_first_search",
        "_export_edge_weights_readonly"
      ],
      "imports": [
        "__future__",
        "logging",
        "weakref",
        "typing"
      ],
      "constants": [
        "_TRUTHY_VALUES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T21:20:58.757629",
        "modified": "2026-02-18T21:20:58.757801",
        "modified_days_ago": 4,
        "lines": 1159,
        "size_bytes": 45064,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/shadow_frontier_adapter.py",
      "name": "shadow_frontier_adapter.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "ShadowFrontierAdapter maintains a heap mirroring the authoritative ordering surface (5-tuple or 6-tuple per mode). It verifies shadow pop order matches authoritative pop, does not modify heap surface. Used for equivalence checking during search.",
      "classes": [
        "LegacyEntry",
        "ParityEntry",
        "ShadowFrontierAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "heapq",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T21:20:58.758033",
        "modified": "2026-02-18T21:20:58.758142",
        "modified_days_ago": 2,
        "lines": 179,
        "size_bytes": 6574,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/snapshot_verifier.py",
      "name": "snapshot_verifier.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Verifies frontier snapshot ordering and mode field consistency. Confirms sorted entries by declared key and checks tuple field parity. Enables machine-checkable ordering semantics across implementations.",
      "classes": [
        "SnapshotVerificationError"
      ],
      "functions": [
        "verify_snapshot",
        "_verify_schema",
        "_verify_mode_fields",
        "_ordering_key",
        "_verify_ordering"
      ],
      "imports": [
        "__future__",
        "typing",
        "core.reasoning.loop.frontier_snapshot"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T09:14:38.403557",
        "modified": "2026-02-17T09:14:38.403717",
        "modified_days_ago": 3,
        "lines": 113,
        "size_bytes": 3991,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/state.py",
      "name": "state.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Manages runtime state for the reasoning loop, tracking execution progress and visited nodes/edges in stateful but thread-safe structures.",
      "classes": [
        "LoopState"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-17T18:46:04.692948",
        "modified": "2026-02-17T18:46:04.693076",
        "modified_days_ago": 3,
        "lines": 86,
        "size_bytes": 2924,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/tasks.py",
      "name": "tasks.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Runs specialized verification and consistency tasks on the reasoning loop state graphs.",
      "classes": [],
      "functions": [
        "run_pn_verification_task",
        "run_requirement_consistency_task"
      ],
      "imports": [
        "typing",
        "main",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-11T00:03:43.639275",
        "modified": "2026-01-21T11:21:45.573009",
        "modified_days_ago": 30,
        "lines": 48,
        "size_bytes": 1237,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/loop/types.py",
      "name": "types.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "The Sterling reasoning loop defines a structured configuration for state and path expansion, tracks step and result metadata, and uses typed StateGraph nodes and edges with instrumentation for traceability and fail-closed evaluation.",
      "classes": [
        "ReasoningConfig",
        "ReasoningPhase",
        "ReasoningStep",
        "ReasoningResult",
        "ReasoningTask"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T21:20:58.758455",
        "modified": "2026-02-18T21:20:58.758800",
        "modified_days_ago": 4,
        "lines": 296,
        "size_bytes": 11581,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/models/intent_aware_scorer_v2.py",
      "name": "intent_aware_scorer_v2.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"type\":\"component\",\"description\":\"A multi-task model for intent-aware scoring with 5 (default: 0 (struct) with 4 (default) (struct with 5  (default) (struct with 3\n  (default) (str, optional) (default) (no) (default) (str, 4, (default) (str) (optional) (default) (struct) (default) (str) (default) (str) (default) (struct) (default) (str) (default) (struct) (default) (optional) (struct) (default) (optional) (struct) (default) (struct) (default) (str) (optional) (struct) (default) (struct)...",
      "classes": [
        "IntentAwareScorerV2Config"
      ],
      "functions": [
        "compute_multi_task_loss",
        "compute_ranking_loss",
        "save_intent_aware_scorer_v2",
        "load_intent_aware_scorer_v2",
        "create_v84_model_from_v83"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2025-12-03T18:52:09.732960",
        "modified": "2026-01-22T07:53:46.506259",
        "modified_days_ago": 29,
        "lines": 699,
        "size_bytes": 23796,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/models/transition_scorer.py",
      "name": "transition_scorer.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Calculates transition preference scores using an MLP on feature vectors derived from utterance and world state. Configurable dimensions and dropout. Used for scoring state graph transitions.",
      "classes": [
        "TransitionScorerConfig"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-29T11:47:13.745468",
        "modified": "2026-01-22T07:53:46.506246",
        "modified_days_ago": 29,
        "lines": 93,
        "size_bytes": 2875,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/mutation_pipeline.py",
      "name": "mutation_pipeline.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "MutationPipeline enforces canonical state deltas via DeltaPack for operator induction. Normalizes state changes to ensure deterministic hashes. Used by K2 for mutation tracking in Sterling's IR.",
      "classes": [
        "MutationResult",
        "MutationPipeline"
      ],
      "functions": [
        "_compute_semantic_projection_hash",
        "_canonicalize_semantic_node",
        "_canonicalize_semantic_edge",
        "_event_key",
        "_role_key",
        "_canonicalize_event",
        "_canonicalize_role",
        "_compute_semantic_patch_ops",
        "_extract_environment_refs",
        "_extract_witnesses"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 410,
            "content": "# TODO: Switch to allowlist approach with schema versioning:",
            "file_path": "core/reasoning/mutation_pipeline.py"
          },
          {
            "line_number": 784,
            "content": "# TODO: Extract KG fact witnesses if operator used KG lookups",
            "file_path": "core/reasoning/mutation_pipeline.py"
          },
          {
            "line_number": 785,
            "content": "# TODO: Extract input span witnesses if operator references input text",
            "file_path": "core/reasoning/mutation_pipeline.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T16:54:03.357197",
        "modified": "2026-01-22T16:54:03.357370",
        "modified_days_ago": 29,
        "lines": 906,
        "size_bytes": 34227,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/parallel_executor.py",
      "name": "parallel_executor.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\" parallel executor infrastructure that maps typed results and enforces deterministic ordering without side effects. It's main entry and exit points. It provides Candidate key collision handling\n",
      "classes": [
        "CandidateAttributionError",
        "CandidateKeyCollisionError",
        "ResultStatus",
        "TypedFailureV1",
        "Result",
        "CandidateKeyV1",
        "EvidenceKeyV1",
        "DedupeActionV1",
        "ReducerWitnessV1",
        "CandidateSpecKeyV1",
        "ParallelExecutor",
        "SequentialExecutor",
        "ThreadPoolExecutorAdapter",
        "DiagFragmentV1",
        "MergedDiagnosticsV1"
      ],
      "functions": [
        "quantize_float",
        "dequantize_float",
        "compute_canonical_hash",
        "compute_effect_identity",
        "get_default_executor",
        "create_test_executor",
        "dedupe_by_key",
        "sort_by_candidate_key",
        "enforce_budget"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "os",
        "random",
        "concurrent.futures",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "QUANTIZATION_FACTOR",
        "ENV_PARALLEL_WORKERS",
        "T",
        "E"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T23:14:27.691681",
        "modified": "2026-01-23T20:36:46.959714",
        "modified_days_ago": 28,
        "lines": 830,
        "size_bytes": 25393,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/planner.py",
      "name": "planner.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Builds structured explanation objects from rule application results and optional Knowledge Graph for evaluation and LLM styling. Uses Colen, Hawkins, and Frazier theories to reconstruct PN subtype explanations in v0.",
      "classes": [],
      "functions": [
        "_determine_pn_subtype_with_semantics",
        "_determine_pn_subtype_colen_diagnostics",
        "_is_proper_noun",
        "_get_subject_text",
        "_has_indefinite_article_before",
        "_has_definite_article_before",
        "determine_pn_subtype",
        "build_colen_explanation",
        "build_hawkins_eic_explanation",
        "build_frazier_interpretation_explanation"
      ],
      "imports": [
        "__future__",
        "typing",
        "ir_serialization"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:53:21.605199",
        "modified": "2026-01-22T07:53:46.506228",
        "modified_days_ago": 29,
        "lines": 768,
        "size_bytes": 27564,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/pn_task.py",
      "name": "pn_task.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\"PN verification task that checks CAWS tier 1 LOC constraints are enforced via abstract WRS state machine model check with symbolic execution. Gated constraints (e.g., on all execution paths max_loc (n) <= 30 on abstract syntax tree. Check node constraints. 1.5. Check node constraints.  Check node.  Check node.  Verify (k) the  W.1.  Verify (k) all node sets.  Validate set state transitions.  Validate next state(n) step.  Validate step.  Validate step.  Validate step.",
      "classes": [
        "VerificationResult",
        "ConstraintType",
        "TierConstraint",
        "Change",
        "VerificationProof"
      ],
      "functions": [
        "get_constraints_for_tier",
        "verify_loc_constraint",
        "verify_approval_constraint",
        "verify_change",
        "create_loc_test_examples",
        "create_approval_test_examples",
        "run_loc_self_test",
        "run_approval_self_test",
        "run_self_test"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "TIER_1_LOC_CONSTRAINT",
        "TIER_2_LOC_CONSTRAINT",
        "TIER_3_LOC_CONSTRAINT",
        "TIER_1_APPROVAL_CONSTRAINT",
        "ALL_CONSTRAINTS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413455",
        "modified": "2026-01-22T07:53:46.504701",
        "modified_days_ago": 29,
        "lines": 535,
        "size_bytes": 15948,
        "author": "@darianrosebrook",
        "has_main": true
      }
    },
    {
      "path": "reasoning/prior_scope.py",
      "name": "prior_scope.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Canonical scope_key computation for prior influence system.\n\nPhase 4.5: This module provides the ONE TRUE builder for scope_key strings.\nAll code that constructs or parses scope_keys MUST use these functions to\nensure deterministic replay verification.",
      "classes": [
        "ParsedScopeKey"
      ],
      "functions": [
        "_normalize_value",
        "compute_prior_scope_key",
        "_decode_value",
        "parse_scope_key",
        "validate_scope_key",
        "is_scope_key_canonical"
      ],
      "imports": [
        "__future__",
        "re",
        "urllib.parse",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "SCOPE_SEGMENT_WORLD",
        "SCOPE_SEGMENT_TASK",
        "SCOPE_DEFAULT_VALUE",
        "SCOPE_SEGMENT_SEPARATOR",
        "SCOPE_KEY_VALUE_SEPARATOR",
        "SCOPE_SEGMENT_ORDER",
        "_SCOPE_KEY_PATTERN_FULL",
        "_SCOPE_KEY_PATTERN_WORLD_ONLY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T21:56:37.512486",
        "modified": "2026-01-22T07:53:46.506187",
        "modified_days_ago": 30,
        "lines": 301,
        "size_bytes": 10034,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/resource_envelope.py",
      "name": "resource_envelope.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\": \"Tracks and certifies resource consumption during search execution. Validates against ResourceLimits. Provides final_*, peak_*, and step_ record_ metrics. Enables TD-7.4 compliance checking. Fails run if limits exceeded. Logs resource events on exceeding, computes a ResourceEnvelope. Stores the last run values for audit. Can serialize Resource state. Proves (fence_*, step_*, heap_*, kg_*, time_*, memory_*, trace_*, step_*, total_*, current_*, and max_* values.",
      "classes": [
        "ResourceLimits",
        "ResourceEnvelope",
        "ResourceTracker",
        "SoakTestResults",
        "AbortSemantics"
      ],
      "functions": [
        "validate_abort_semantics"
      ],
      "imports": [
        "__future__",
        "logging",
        "time",
        "tracemalloc",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "DEFAULT_LIMITS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T11:57:49.490995",
        "modified": "2026-01-22T07:53:46.506156",
        "modified_days_ago": 29,
        "lines": 458,
        "size_bytes": 15127,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/rules.py",
      "name": "rules.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"A rule application: \\\"PN in rule-sentences (\\\" in rule-objects (\\\" to check: returns a set of rule names.",
      "classes": [
        "RuleHit",
        "RuleApplicationResult",
        "RuleFamily",
        "RuleFamilyRegistry"
      ],
      "functions": [
        "parse_rule_id",
        "validate_rule_id",
        "create_versioned_rule_id",
        "register_rule_family",
        "get_rule_family_registry",
        "_apply_pn_rule_has_subject_and_copula",
        "_apply_pn_rule_has_pred_nominal_span",
        "apply_predicate_nominal_rules",
        "apply_all_rules",
        "is_predicate_nominal"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "ir_serialization"
      ],
      "constants": [
        "RULE_PN_HAS_SUBJECT_AND_COPULA",
        "RULE_PN_HAS_PRED_NOMINAL_SPAN",
        "RULE_PN_HAS_SUBJECT_AND_COPULA_V1",
        "RULE_PN_HAS_PRED_NOMINAL_SPAN_V1",
        "CONSTRUCTION_PREDICATE_NOMINAL"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-16T21:15:56.245136",
        "modified": "2026-01-22T07:53:46.506076",
        "modified_days_ago": 29,
        "lines": 536,
        "size_bytes": 15801,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/search.py",
      "name": "search.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\"Implements frontier-based search over immutable StateNodes\n    - Selects each operator in parallel, non-deterministic\n    execution.",
      "classes": [
        "SearchStrategy",
        "ParallelExpansionMode",
        "SearchConfig",
        "SearchNode",
        "Candidate",
        "CandidateApplicationResult",
        "SearchResult",
        "ImmutableSearchTree"
      ],
      "functions": [
        "_now_or_anchor",
        "apply_single_candidate",
        "run_search"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "heapq",
        "json",
        "logging",
        "os",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [
        "_CERTIFYING_TIME_ANCHOR",
        "_PRAGMATIC_OPERATOR_IDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 1907,
            "content": "# TODO: Implement comprehensive frontier addition logic",
            "file_path": "core/reasoning/search.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.973563",
        "modified": "2026-02-21T23:57:28.973832",
        "modified_days_ago": 0,
        "lines": 2472,
        "size_bytes": 112935,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/self_correction.py",
      "name": "self_correction.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Self-correction integration for Sterling reasoning loop. Provides unified interfaces for backtracking, confidence tracking, and learning within the existing state graph. Author: @darianrosebrook",
      "classes": [
        "SelfCorrectionConfig",
        "SelfCorrectionController"
      ],
      "functions": [
        "create_self_correction_controller"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "backtracking",
        "confidence",
        "learning"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T23:05:16.365731",
        "modified": "2026-01-22T07:53:46.506207",
        "modified_days_ago": 29,
        "lines": 431,
        "size_bytes": 14036,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/semantic_delta_enforcement.py",
      "name": "semantic_delta_enforcement.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Return type:  class  (str ->  DeltaEnforcementMode)\n    Context  (str)  ->  mode\n    (class  (str)  ->  mode\n    (class)  ->  mode\n    Context (class) ->  mode\n    from  (context)  ->  mode\n    (class)  ->  mode\n    from  context  ->  mode\n    ",
      "classes": [
        "DeltaEnforcementMode",
        "DeltaEnforcementError",
        "DeltaEnforcementPolicy"
      ],
      "functions": [
        "policy_from_options"
      ],
      "imports": [
        "dataclasses",
        "enum",
        "typing",
        "logging",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T15:22:02.403694",
        "modified": "2026-01-24T17:31:27.847427",
        "modified_days_ago": 27,
        "lines": 290,
        "size_bytes": 9305,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/stage_l_controls.py",
      "name": "stage_l_controls.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"validate\", \"Label scramble, component swap, and no target exposure attestation\n\"\"\" \n 1.  Label scramble controls verify performance degradation\n    for claims\n    from h3.  (precondition, postcondition,  and\n    a  (architectural)\n    test\n    is  not\n    transfer\n    must\n    fail safe\n    (arch)  only\n    (strict)\n    pass\n    the\n    test\n    for\n    component\n    must\n    see\n    only\n    label  from\n    the\n    the\n    (  pass 1.",
      "classes": [
        "NegativeControlType",
        "ControlResult",
        "LabelScrambleConfig",
        "ComponentSwapConfig",
        "NoTargetExposureConfig",
        "NegativeControlResult",
        "StageLNegativeControls"
      ],
      "functions": [
        "compute_config_digest",
        "run_label_scramble_control",
        "run_component_swap_control",
        "run_no_target_exposure_control",
        "validate_transfer_claim_controls",
        "create_negative_control_attestation"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "random",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T07:44:08.416398",
        "modified": "2026-01-22T07:53:46.506099",
        "modified_days_ago": 29,
        "lines": 529,
        "size_bytes": 18702,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/staged_search.py",
      "name": "staged_search.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\": \"Per the Cross-Domain Bridge: Two-stage search with cost tracking and hysteresis enforcement for each domain\n  A post conditions, backward chainer (support) for n-step and gas estimation\n  ",
      "classes": [
        "BridgeCosts",
        "DiscourseSearchResult",
        "LandmarkSearchResult",
        "TargetWorldSearchResult",
        "StagedSearchResult",
        "StagedSearchCoordinator"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "time",
        "dataclasses",
        "typing",
        "core.contracts.governance_status",
        "core.reasoning.state_graph",
        "core.worlds.discourse",
        "core.worlds.landmarks"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [
          {
            "line_number": 602,
            "content": "Implement full search execution in target world",
            "file_path": "core/reasoning/staged_search.py"
          }
        ],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 460,
            "content": "# TODO: Implement learned goal-to-world mapping",
            "file_path": "core/reasoning/staged_search.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T07:13:56.431919",
        "modified": "2026-01-26T07:13:56.432184",
        "modified_days_ago": 25,
        "lines": 680,
        "size_bytes": 24955,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/state_graph.py",
      "name": "state_graph.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "StateGraph: First-class representation of reasoning episodes.\n\nThe StateGraph captures the full audit trail of a reasoning process,\nenabling inspection, visualization, training, and analysis.",
      "classes": [
        "EdgeCollisionError",
        "SearchNodeType",
        "EdgeKind",
        "EdgeType",
        "SearchNode",
        "OperatorEdge",
        "StateGraph",
        "EpisodeObjectStore"
      ],
      "functions": [
        "compute_edge_id",
        "compute_edge_id_v2",
        "is_content_addressed_edge_id",
        "is_governance_grade_edge_id",
        "_edge_identity_tuple",
        "_warn_state_node_deprecated"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "warnings",
        "dataclasses",
        "enum",
        "logging",
        "typing",
        "core.operators.registry"
      ],
      "constants": [
        "EDGE_ID_HASH_LENGTH"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.583811",
        "modified": "2026-02-21T15:51:43.584011",
        "modified_days_ago": 0,
        "lines": 2055,
        "size_bytes": 79668,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/step_instrumentation.py",
      "name": "step_instrumentation.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Sterling Step-Level Instrumentation.",
      "classes": [
        "StepRecord",
        "BreakpointCapture",
        "StepLogger"
      ],
      "functions": [
        "dump_candidate_ranking",
        "compute_state_diff"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "pathlib",
        "typing",
        "core.contracts.semantic_edits"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T19:09:53.501366",
        "modified": "2026-02-17T10:09:41.567862",
        "modified_days_ago": 6,
        "lines": 690,
        "size_bytes": 25328,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/step_record.py",
      "name": "step_record.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\"Splits StepRecord into core (stable, minimal) and regime-specific evidence overlays. \"\"\"\n    @dataclass\n    def __init__(self) ... (init) ...\n    @type {inst} ucheat. Terng (wrappo) s\n    # Evidence\n    from_ observed\n    @.",
      "classes": [
        "StepRecordCore",
        "EdgeTraversalEffect",
        "CorrectnessEvidenceOverlay",
        "ValueEvidenceOverlay",
        "ResourceEvidenceOverlay",
        "StepRecordWithOverlays"
      ],
      "functions": [
        "migrate_step_record"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "constants": [
        "STEP_RECORD_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 395,
            "content": "# TODO: Implement full resource evidence overlay extraction",
            "file_path": "core/reasoning/step_record.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T12:03:26.067290",
        "modified": "2026-01-22T07:53:46.506133",
        "modified_days_ago": 29,
        "lines": 542,
        "size_bytes": 19825,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/telemetry.py",
      "name": "telemetry.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Sterling Telemetry and Trace Policy.\n\nEnforces the Policy of Truth at the serialization boundary.\nOracle information is filtered out of production traces based on\nthe declared Information Regime.\n\nAuthor: @darianrosebrook",
      "classes": [
        "InformationRegime",
        "TraceSerializer"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "enum",
        "typing",
        "core.reasoning.step_record"
      ],
      "constants": [
        "FORBIDDEN_FIELDS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-19T16:26:15.968576",
        "modified": "2026-01-22T07:53:46.506032",
        "modified_days_ago": 29,
        "lines": 67,
        "size_bytes": 1867,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/trace_audit.py",
      "name": "trace_audit.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\n  \"No Hidden Router detection: A module-level checks for allowed operators.  No untyped checks for world/landmark/operational\n  route checks (allow only\n  routing\n    (no-op for\n  check (allow, marked\n    # a\n# A\n# Each\n    Decision\n    type, signed\n    reasons\n}",
      "classes": [
        "DecisionSource",
        "DecisionType",
        "RoutingDecision",
        "ReasoningTrace",
        "AuditResult",
        "TraceAuditor",
        "HiddenRouterViolation"
      ],
      "functions": [
        "create_world_selection_decision",
        "create_landmark_selection_decision",
        "create_operator_selection_decision",
        "get_global_auditor",
        "set_strict_mode",
        "audit_trace"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:03:38.709676",
        "modified": "2026-02-15T12:03:38.709821",
        "modified_days_ago": 5,
        "lines": 364,
        "size_bytes": 11414,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reasoning/transactional_apply.py",
      "name": "transactional_apply.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "{\"description\":\"Apply mutations through semantic edits, tracking via ProvenanceTree edit tracker. Enforces preconditions, structural delta, and allows only If- applied. ",
      "classes": [
        "EnforcementMode",
        "InvariantContext",
        "InvariantResult",
        "InvariantChecker",
        "StructuralDeltaChecker",
        "EmptyEditDeltaPolicyViolation",
        "ApplyResult",
        "AppliedOutcome"
      ],
      "functions": [
        "evaluate_invariants_and_enforce",
        "_diff_states",
        "transactional_apply",
        "create_successor_state",
        "apply_with_edits"
      ],
      "imports": [
        "__future__",
        "logging",
        "uuid",
        "copy",
        "dataclasses",
        "enum",
        "typing",
        "core.contracts.semantic_edits"
      ],
      "constants": [
        "INVARIANT_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-02T05:11:18.491525",
        "modified": "2026-02-17T10:09:41.653473",
        "modified_days_ago": 3,
        "lines": 1009,
        "size_bytes": 38466,
        "author": "ity",
        "has_main": false
      }
    },
    {
      "path": "reasoning/value_features.py",
      "name": "value_features.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "(state, transition\n    feature\n    a fixed-size input (stacked for\n    each candidate exp\n    resul\n    lated\n    (best\n    and\n    d\n    (state)  features\n    for\n    test\n    (A M\n    (A, best: was\n    (A, B, C (A, B, C,  A,  B, C\n    features\n    (A,  B, C, D, E features\n    (A,",
      "classes": [
        "Label",
        "TransitionExample",
        "FeatureSpec",
        "IntentFeatureSpec",
        "ClaimFeatureSpec",
        "DomainType",
        "DomainFeatureSpec"
      ],
      "functions": [
        "_clamp",
        "_safe_div",
        "_norm_depth",
        "_norm_degree",
        "_edge_type_one_hot",
        "_operator_category_one_hot",
        "compute_parent_child_features",
        "make_transition_features",
        "compute_full_transition_features",
        "train_transition_scorer"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "math",
        "typing",
        "state_graph"
      ],
      "constants": [
        "MAX_DEGREE_CLIP",
        "MAX_CANDIDATES_CLIP",
        "EDGE_TYPE_VOCAB",
        "EDGE_TYPE_INDEX",
        "EDGE_TYPE_DIM",
        "FEATURE_SPEC",
        "INTENT_FEATURE_SPEC",
        "CLAIM_FEATURE_SPEC",
        "DOMAIN_FEATURE_SPEC"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T21:20:06.387067",
        "modified": "2026-01-25T21:20:06.387221",
        "modified_days_ago": 26,
        "lines": 1627,
        "size_bytes": 52828,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "reasoning/verifier.py",
      "name": "verifier.py",
      "category": "Search, state graphs, instrumentation, and failure taxonomy",
      "status": "active",
      "description": "Verifies claims by checking logical consistency against KG using rule engine. For 'is_predicate_nominal' claim, performs deterministic check with optional closed-world logic. Caches results for reuse.",
      "classes": [
        "VerificationResult",
        "Verifier"
      ],
      "functions": [
        "verify_claim",
        "_apply_verification_mode",
        "_get_cache_key",
        "_cache_result",
        "verify_claims_batch",
        "clear_verification_cache",
        "get_cache_stats",
        "_verify_claim_generic",
        "_call_kg_helper",
        "_safe_get_sentence_node"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "_TRUE_STRINGS",
        "_FALSE_STRINGS",
        "_UNKNOWN_STRINGS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 697,
            "content": "# TODO: Implement parallel claim verification",
            "file_path": "core/reasoning/verifier.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-16T21:15:59.333747",
        "modified": "2026-01-22T07:53:46.504748",
        "modified_days_ago": 29,
        "lines": 1058,
        "size_bytes": 38328,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reconstruction/__init__.py",
      "name": "__init__.py",
      "category": "Linguistic reconstruction",
      "status": "active",
      "description": "Reconstruction layer for Sterling Full.\n\nThis module provides explicit reconstruction from compressed semantics\nusing linguistic theory (Colen, Hawkins, Frazier) as reconstruction templates.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "linguistic_reconstruction"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-17T18:18:42.888845",
        "modified": "2026-01-22T07:53:46.507018",
        "modified_days_ago": 29,
        "lines": 27,
        "size_bytes": 655,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "reconstruction/linguistic_reconstruction.py",
      "name": "linguistic_reconstruction.py",
      "category": "Linguistic reconstruction",
      "status": "active",
      "description": "Decompresses IR tokens or RGBA codes into linguistic structure using templates from Colen, Hawkins, and Frazier. Maps compressed representations to pn_subtype, eic_preferences, and interpretations.",
      "classes": [
        "LinguisticStructure"
      ],
      "functions": [
        "decompress_to_ir",
        "_get_default_tokenizer",
        "set_default_tokenizer",
        "decompress_from_rgba",
        "decompress_from_latent",
        "reconstruct_pn_structure",
        "reconstruct_eic_preferences",
        "reconstruct_interpretations",
        "reconstruct_from_compressed",
        "reconstruct_from_ir"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "ir_serialization"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-17T18:19:00.311913",
        "modified": "2026-01-22T07:53:46.507076",
        "modified_days_ago": 29,
        "lines": 489,
        "size_bytes": 16561,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "recursion/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Recursion package exports.",
      "classes": [],
      "functions": [],
      "imports": [
        "budget",
        "enums",
        "rc2_walk",
        "rc4_closure",
        "rc9_resolve"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:01:54.747242",
        "modified": "2026-01-23T12:15:09.460266",
        "modified_days_ago": 28,
        "lines": 21,
        "size_bytes": 653,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/adapters.py",
      "name": "adapters.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides link types for recursion traversal and protocol adapters for deterministic StateGraph operations.",
      "classes": [
        "WalkChildLinkV1",
        "StateGraphWalkAdapterV1",
        "ClosureDepLinkV1",
        "ClosureAdapterV1",
        "RegistryResolveAdapterV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "hashing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:02:36.125439",
        "modified": "2026-01-23T12:12:52.679495",
        "modified_days_ago": 28,
        "lines": 54,
        "size_bytes": 1348,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/budget.py",
      "name": "budget.py",
      "category": "Core module",
      "status": "active",
      "description": "Budget enforcement for recursive expansion limits in MOC.",
      "classes": [
        "RecursionBudgetV1",
        "BudgetStateV1"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "enums"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:02:03.913175",
        "modified": "2026-01-23T12:29:44.686539",
        "modified_days_ago": 28,
        "lines": 61,
        "size_bytes": 1526,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/enums.py",
      "name": "enums.py",
      "category": "Core module",
      "status": "active",
      "description": "Defines recursion-related enum classes for execution modes, termination reasons, traversal orders, and resolution outcomes in the core module.",
      "classes": [
        "RecursionMode",
        "TerminationReason",
        "WalkOrder",
        "ResolveOutcome"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "enum"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:01:59.084284",
        "modified": "2026-01-23T12:34:48.923117",
        "modified_days_ago": 28,
        "lines": 42,
        "size_bytes": 936,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/hashing.py",
      "name": "hashing.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides canonical JSON hashing for recursion artifacts using domain separation and digest computation.",
      "classes": [
        "RecursionHasher"
      ],
      "functions": [
        "_reject_floats",
        "canonical_recursion_json_bytes",
        "domain_separated_digest",
        "digest_json"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.canonicalization.json"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:12:32.019480",
        "modified": "2026-01-23T12:12:32.019610",
        "modified_days_ago": 28,
        "lines": 59,
        "size_bytes": 1699,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/rc2_walk.py",
      "name": "rc2_walk.py",
      "category": "Core module",
      "status": "active",
      "description": "Deterministic StateGraph walk with trace, visited node digests, and witness verification.",
      "classes": [
        "WalkResultV1"
      ],
      "functions": [
        "_stable_child_sort_key",
        "_sorted_children",
        "walk_stategraph_v1"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "collections",
        "adapters",
        "budget",
        "enums",
        "hashing",
        "store",
        "witness"
      ],
      "constants": [
        "RC2_TRACE_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:14:02.173267",
        "modified": "2026-01-23T12:35:21.950022",
        "modified_days_ago": 28,
        "lines": 265,
        "size_bytes": 9558,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/rc4_closure.py",
      "name": "rc4_closure.py",
      "category": "Core module",
      "status": "active",
      "description": "RC-4 performs recursive closure verification using typed operators and traceable evidence.",
      "classes": [
        "ClosureVerificationResultV1"
      ],
      "functions": [
        "verify_provenance_closure_v1"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "adapters",
        "budget",
        "enums",
        "hashing",
        "store",
        "witness"
      ],
      "constants": [
        "RC4_TRACE_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:14:28.466864",
        "modified": "2026-01-23T12:31:09.262438",
        "modified_days_ago": 28,
        "lines": 116,
        "size_bytes": 3598,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/rc9_resolve.py",
      "name": "rc9_resolve.py",
      "category": "Core module",
      "status": "active",
      "description": "RC-9: deterministic registry resolution via structured trace and auditable choices.",
      "classes": [
        "ResolveResultV1"
      ],
      "functions": [
        "resolve_operator_impl_v1"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "adapters",
        "budget",
        "enums",
        "hashing",
        "store",
        "witness"
      ],
      "constants": [
        "RC9_TRACE_DOMAIN"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:14:54.258309",
        "modified": "2026-01-23T12:23:15.339133",
        "modified_days_ago": 28,
        "lines": 84,
        "size_bytes": 2725,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/store.py",
      "name": "store.py",
      "category": "Core module",
      "status": "active",
      "description": "Content-addressed store interfaces for recursion artifacts with in-memory and adapter implementations.",
      "classes": [
        "RecursionStoreRefV1",
        "RecursionStoreV1",
        "InMemoryRecursionStore",
        "ArtifactStoreRecursionAdapter"
      ],
      "functions": [
        "_schema_version_from_id"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "hashing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:02:16.535191",
        "modified": "2026-01-23T12:15:20.329890",
        "modified_days_ago": 28,
        "lines": 71,
        "size_bytes": 2211,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "recursion/witness.py",
      "name": "witness.py",
      "category": "Core module",
      "status": "active",
      "description": "Recursion witness envelopes.",
      "classes": [
        "WitnessEnvelopeV1"
      ],
      "functions": [
        "emit_witness_v1"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "hashing",
        "store"
      ],
      "constants": [
        "WITNESS_SCHEMA_ID",
        "WITNESS_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T12:02:20.304027",
        "modified": "2026-01-23T12:30:24.733856",
        "modified_days_ago": 28,
        "lines": 41,
        "size_bytes": 1152,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "safeguards/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Safeguards Module (Milestone 2.3-2.4).",
      "classes": [],
      "functions": [],
      "imports": [
        "core.safeguards.invariance_tests",
        "core.safeguards.observation_schema",
        "core.safeguards.oracle_separation",
        "core.safeguards.semantic_labels",
        "core.safeguards.world_quarantine",
        "core.safeguards.model_gateway",
        "core.safeguards.certifying_boundary",
        "core.safeguards.placeholder_audit"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:10:40.081556",
        "modified": "2026-01-23T18:07:50.604677",
        "modified_days_ago": 30,
        "lines": 290,
        "size_bytes": 8290,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/certifying_boundary.py",
      "name": "certifying_boundary.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"H3 Certifying boundary enforces all downstream verifications. No execution of a certifying didn't pass.  No 1.  Holes checks are bypassed, but not\n    enforce. 2.  No execution of certifying\n    \"\"\" Holes must be checked at least\n    once for current_ownership\n\"\"\" H3. Check that\n    failures. 0\nIf  a certifying\n    reason over rule\n    execution\n    #  re-strict execution\n    of reason\n    verifiable\n    \"\"\"Holes and\n    reasons an\n    architectural\n    enforcement\n\"\"\"H3.",
      "classes": [
        "MeasurementStatus",
        "DigestVisibilityPolicyEnum",
        "HolesPolicyResult",
        "CertifyingValidationResult",
        "CertifyingValidationError"
      ],
      "functions": [
        "validate_h3_certifying_run",
        "create_holes_policy_result"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T07:36:40.340078",
        "modified": "2026-01-22T07:53:46.506397",
        "modified_days_ago": 29,
        "lines": 475,
        "size_bytes": 18531,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/invariance_tests.py",
      "name": "invariance_tests.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"graph_isomorphism_test\": \"nou\n    In var graph isomorphism test for\n    graphs and permutations\n    of node labels\n    for each test. Proven\n    graph: A\n    isomorphs. Proven\n    graph data\n    A graph tests\n    non- graph\n    isomorphism\n    test.",
      "classes": [
        "InvarianceTestNode",
        "InvarianceTestEdge",
        "InvarianceTestGraph",
        "InvarianceTestResult",
        "InvarianceComparison",
        "InvarianceViolationError",
        "InvarianceTestSuite"
      ],
      "functions": [
        "generate_test_graph",
        "permute_node_ids",
        "permute_labels",
        "generate_topology_independent_permutation",
        "apply_topology_independent_permutation",
        "verify_topology_independence",
        "run_isomorphism_invariance_test",
        "run_label_permutation_invariance_test",
        "create_invariance_gate"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "random",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:19:57.746145",
        "modified": "2026-01-22T07:53:22.087109",
        "modified_days_ago": 29,
        "lines": 867,
        "size_bytes": 27706,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/model_gateway.py",
      "name": "model_gateway.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"ModelGateway\",\"input_tokens\",\"model\":\"H3.2  gateway  in  search  phase  with  H3  guard  for  model  calls  in  strict  mode  enforces  H3  gateway  for  every  model  call  in  search  phase  with  H3  gate  for  search  phase  with 3  gate  for  search  phase  with  gates 2  in  search  phase\n  with  gate  verif  H  mode\n  with  gateway  (  model  call  in  search  phase\n  with  gate  enfor  model  calls  in  search  phase",
      "classes": [
        "ModelGatewayError",
        "SearchPhaseModelCallError",
        "GatewayNotRegisteredError",
        "EnforcementMode",
        "ModelCallRecord",
        "TokenizerProvenance",
        "TokenBudgetWitnessV1",
        "ModelGateway"
      ],
      "functions": [
        "get_global_gateway",
        "set_global_gateway",
        "reset_global_gateway"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "threading",
        "contextlib",
        "dataclasses",
        "datetime",
        "enum",
        "typing"
      ],
      "constants": [
        "T"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T07:32:37.203069",
        "modified": "2026-01-22T07:53:46.506454",
        "modified_days_ago": 29,
        "lines": 770,
        "size_bytes": 27285,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/observation_schema.py",
      "name": "observation_schema.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"schema\": \"closed_oracle\" (from_observations\n    - exactly_observable_ as input to  (premation\n    -  Observing - step\n    - aleness (self-attribute\n    - step\n    in\n    - schema\n    - harden\n    - each\n    step - nced observations\n    - al\n    -  observation\n    step - pre\n    validation for\n    each - node.",
      "classes": [
        "CertifiedObservation",
        "GovernanceViolation",
        "DigestVisibilityPolicy",
        "DigestVisibilityGuard"
      ],
      "functions": [
        "is_derived_oracle_field",
        "is_any_oracle_field",
        "validate_no_oracle_in_dict",
        "validate_no_oracle_in_nested",
        "validate_observation_no_digests",
        "is_audit_plane_field",
        "is_text_ir_forbidden_field",
        "get_non_schema_fields",
        "validate_schema_compliance",
        "get_global_digest_guard"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "re",
        "dataclasses",
        "typing",
        "core.safeguards.oracle_separation"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T04:01:22.372822",
        "modified": "2026-01-22T07:53:46.506462",
        "modified_days_ago": 29,
        "lines": 938,
        "size_bytes": 29662,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/oracle_separation.py",
      "name": "oracle_separation.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"Enforces strict separation between environment observations and model state.  Enforces that no goal_ oracle  access unless  allowed  by  configuration.",
      "classes": [
        "OracleChannel",
        "OracleSeparationConfig",
        "OracleAccessError",
        "SemanticLabelAccessError"
      ],
      "functions": [
        "get_current_oracle_config",
        "is_oracle_forbidden",
        "oracle_forbidden_context",
        "oracle_allowed_context",
        "check_oracle_separation",
        "check_semantic_label_access",
        "is_oracle_field",
        "is_observation_field",
        "classify_field",
        "oracle_protected"
      ],
      "imports": [
        "__future__",
        "contextvars",
        "functools",
        "logging",
        "contextlib",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "DEFAULT_CERTIFIED_CONFIG",
        "DEFAULT_EVAL_CONFIG",
        "F",
        "SAFEGUARD_VERSION"
      ],
      "decorators_used": [
        "contextmanager",
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:14:18.609791",
        "modified": "2026-01-22T07:53:22.087145",
        "modified_days_ago": 29,
        "lines": 561,
        "size_bytes": 16412,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/placeholder_audit.py",
      "name": "placeholder_audit.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"type\":\"placeholder\",\"value\":\"sha256\",\"msg\":\"Empty hash found\",\"url\":\"https://sterling it at prom: placeholder in path check\",\"sevP: return \"https://.../na K3, \"Check placeholder file hashes before file load in check def> \"Mintegrity\": (return \"ad\" at \"test\" options file_ check_ function",
      "classes": [
        "PlaceholderViolation",
        "PlaceholderAuditResult",
        "PlaceholderAuditError"
      ],
      "functions": [
        "_check_hash_value",
        "_check_string_value",
        "_check_vh_score",
        "_audit_recursive",
        "audit_for_placeholders",
        "audit_hash_value",
        "audit_artifact_ref",
        "validate_at_mint_boundary"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "re",
        "dataclasses",
        "datetime",
        "typing",
        "core.contracts.governance_status"
      ],
      "constants": [
        "PATTERN_ALL_ZERO_HASH",
        "PATTERN_PLACEHOLDER_STRING",
        "PATTERN_NA_PLACEHOLDER",
        "PATTERN_UNKNOWN_HASH",
        "PATTERN_EMPTY_STRING",
        "PATTERN_VH_SCORE_HALF",
        "PLACEHOLDER_HASH_PATTERNS",
        "PLACEHOLDER_STRING_PATTERNS",
        "HASH_FIELD_NAMES",
        "ARTIFACT_REF_FIELD_NAMES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-23T17:47:29.189871",
        "modified": "2026-01-23T18:07:50.578659",
        "modified_days_ago": 28,
        "lines": 545,
        "size_bytes": 16974,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/semantic_labels.py",
      "name": "semantic_labels.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"description\":\"...\",\"labe...\":null,\"govern...\": (False, ){\"local\":null,\"node\": true, \"global\": \"G in this implementation\n    # A label  # and fail if not ...",
      "classes": [
        "SemanticLabelConfig",
        "OpaqueNodeLabels"
      ],
      "functions": [
        "make_opaque_label",
        "make_goal_label",
        "hash_label",
        "get_current_semantic_config",
        "are_semantic_labels_enabled",
        "semantic_labels_context",
        "get_semantic_label_if_allowed",
        "get_goal_label_if_allowed",
        "detect_semantic_leakage",
        "validate_opaque_labels"
      ],
      "imports": [
        "__future__",
        "contextvars",
        "functools",
        "hashlib",
        "logging",
        "contextlib",
        "dataclasses",
        "typing",
        "core.safeguards.oracle_separation"
      ],
      "constants": [
        "DEFAULT_OPAQUE_CONFIG",
        "DEFAULT_SEMANTIC_CONFIG",
        "F"
      ],
      "decorators_used": [
        "contextmanager",
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T01:16:49.670263",
        "modified": "2026-01-22T07:53:46.506477",
        "modified_days_ago": 29,
        "lines": 563,
        "size_bytes": 16345,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/text_ir_invariance.py",
      "name": "text_ir_invariance.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"Text IR invariance: check_grammar_admiss() A\n    # check ( grammar validity\n    # to\n    # check syntax\n    (validity).check_ (syntax_a\n    # check syntax (j\n    # ir_uses\n    #  verif\n    #  grammar\n    #  to\n    #  (se\n    #  M_  (syntax_  a\n#  context (test\n    #  grammar (optional\n    #  verif (  tests\n#  grammar  (se\n    #  context\n    #  look\n    # each\n    #  each test\n#  grammar  look  like\n    #  each test\n    #  each\n    #  grammar\n    #  context\n    #  grammar  (optional)\n    # ...",
      "classes": [
        "InvarianceTestType",
        "InvarianceTestResult",
        "InvarianceSuiteResult",
        "TextIRInvarianceSuite"
      ],
      "functions": [
        "check_canonicalization_determinism",
        "check_parser_version_binding",
        "check_canonicalization_version_gating",
        "check_holes_coverage",
        "check_parser_class_admissibility",
        "check_holes_policy_enforcement",
        "run_text_ir_invariance_tests"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.linguistics.holes_policy",
        "core.linguistics.parser_trust",
        "core.text.intake_ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T06:06:43.474085",
        "modified": "2026-01-22T07:53:46.506419",
        "modified_days_ago": 29,
        "lines": 476,
        "size_bytes": 15014,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "safeguards/world_quarantine.py",
      "name": "world_quarantine.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"certified\"} context: returns\n    # Certified worlds: None\n#  \"\"\"  #  reasons  \"\"\"  #  world\n#  usage in  \"\"\"  \"\"\"\n#  reason  \"\"\"  \"\"\"\n#  usage  in  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  allowed  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#  \"\"\"  \"\"\"\n#",
      "classes": [
        "WorldQuarantineStatus",
        "QuarantineReason",
        "WorldQuarantineEntry",
        "QuarantinedWorldError",
        "UnknownWorldError",
        "CertifiedContextConfig",
        "StageKQuarantineViolation"
      ],
      "functions": [
        "register_quarantine_entry",
        "get_quarantine_entry",
        "is_quarantined_world",
        "is_certified_world",
        "get_current_certified_config",
        "is_certified_context",
        "certified_context",
        "experimental_context",
        "enforce_quarantine_at_construction",
        "validate_world_for_stage_k_run"
      ],
      "imports": [
        "__future__",
        "contextvars",
        "functools",
        "logging",
        "warnings",
        "contextlib",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "F"
      ],
      "decorators_used": [
        "contextmanager",
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T02:00:46.902508",
        "modified": "2026-01-22T07:53:46.506397",
        "modified_days_ago": 29,
        "lines": 761,
        "size_bytes": 22771,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "search_health.py",
      "name": "search_health.py",
      "category": "Core module",
      "status": "active",
      "description": "SearchHealthAccumulator maintains O(1 metrics during A* search. Calls on expansion to update _nodes_expanded, _h_mean/var via Welford's algorithm, and quantizes h for pctSameH. Finalize() returns TS field names plus searchHealthVersion 1 for forward compatibility.",
      "classes": [
        "TerminationReason",
        "SearchHealthAccumulator"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "math",
        "collections",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-29T07:19:14.768651",
        "modified": "2026-01-29T07:19:14.768783",
        "modified_days_ago": 22,
        "lines": 165,
        "size_bytes": 5354,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "simple_kg.py",
      "name": "simple_kg.py",
      "category": "Core module",
      "status": "active",
      "description": "Stores IR objects in-memory for Sterling Light. Provides get_ir and get_sentence_node interfaces. Minimal KG for Tasks B and C.",
      "classes": [
        "SimpleKG"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "ir_serialization"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-26T21:32:27.245170",
        "modified": "2026-01-22T07:53:45.756873",
        "modified_days_ago": 29,
        "lines": 219,
        "size_bytes": 6922,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "state_model.py",
      "name": "state_model.py",
      "category": "Core module",
      "status": "active",
      "description": "{\"MOC\": \"The canonical state hierarchy in core. \n{\"U\": \"as text\n  returns \n{\"E:  return \n{\"E: Optional[ast] as explained\n{\"E}  return \n{\"E}  return the \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{\"U}  return \n{\"E}  return \n{\"E}  return \n{\"U}  return \n{\"E} return \n{\"E}  return \n{\"U}  return \n{\"E} return \n{\"U}  return \n{\"E}  return \n{\"E} \n{\"U} return \n{\"E}  return \n{\"E}  return \n{\"E}  return \n{",
      "classes": [
        "InvariantViolation",
        "Modality",
        "WorldID",
        "UtteranceStage",
        "SyntaxLayer",
        "SemanticIR",
        "SemioticMappings",
        "PragmaticContext",
        "UtteranceState",
        "WorldState",
        "StateNode"
      ],
      "functions": [
        "set_strict_invariants",
        "get_strict_invariants",
        "get_utterance_stage",
        "check_task_precondition",
        "get_missing_layers_for_task",
        "create_utterance_state",
        "create_state_node",
        "utterance_state_from_pn_ir",
        "world_state_from_pn_metadata"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.contracts.operator_application"
      ],
      "constants": [
        "CANONICAL_VERSION",
        "STRICT_INVARIANTS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 232,
            "content": "# TODO: Typed IR Node/Edge Classes",
            "file_path": "core/state_model.py"
          },
          {
            "line_number": 474,
            "content": "# TODO: Typed IntentAnnotation References",
            "file_path": "core/state_model.py"
          },
          {
            "line_number": 985,
            "content": "# TODO: Typed DialogueState Reference",
            "file_path": "core/state_model.py"
          },
          {
            "line_number": 1042,
            "content": "# TODO: Remove Legacy KG Fields (Phase D)",
            "file_path": "core/state_model.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.973956",
        "modified": "2026-02-21T23:57:28.974151",
        "modified_days_ago": 0,
        "lines": 1877,
        "size_bytes": 71779,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks.py",
      "name": "tasks.py",
      "category": "Core module",
      "status": "active",
      "description": "Top-level task interfaces for Sterling Light.\n\nThis module defines the public, typed entry points for:\n- Task A: IR reconstruction (encoder baseline)\n- Task B: Rule-guided explanation\n- Task C: Logical consistency verification\n\nThese functions are thin orchestrators that:\n- take IR / claims / KG as inputs,\n- call into the reasoning/planning/encoder layers,\n- return strongly-typed result objects.",
      "classes": [
        "Claim",
        "ExplanationDict",
        "TaskAResult",
        "KnowledgeGraph",
        "EncoderBaseline"
      ],
      "functions": [
        "run_task_a",
        "_calculate_structural_similarity",
        "run_task_b_explain",
        "run_task_c_verify"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "ir_serialization"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 132,
            "content": "# TODO: Implement Task A encoder/decoder baseline",
            "file_path": "core/tasks.py"
          },
          {
            "line_number": 297,
            "content": "# TODO: Enhance Task B explanation generation",
            "file_path": "core/tasks.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:53:21.605558",
        "modified": "2026-01-22T07:53:46.007420",
        "modified_days_ago": 29,
        "lines": 395,
        "size_bytes": 13780,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/__init__.py",
      "name": "__init__.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Sterling Task Implementations.\n\nThis package contains task implementations that are registered with\nthe SterlingEngine. Tasks own goal predicates and success criteria,\nwhile worlds own input parsing and operators.\n\nPer Commitment 2: Tasks own goals, worlds own operators.\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "importlib.util",
        "pathlib"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-01T13:39:19.094138",
        "modified": "2026-01-22T07:53:46.530353",
        "modified_days_ago": 29,
        "lines": 69,
        "size_bytes": 2269,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/claims.py",
      "name": "claims.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Sterling ClaimVerificationTask: determines the truth status of a claim against the Truth KG, optionally using external support from WordNet or Wikidata.",
      "classes": [
        "TruthStatus",
        "ClaimVerificationTask",
        "ClaimVerificationResult"
      ],
      "functions": [
        "claim_verification_goal_predicate",
        "build_claim_task_from_claim_row"
      ],
      "imports": [
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413531",
        "modified": "2026-01-22T07:53:46.530373",
        "modified_days_ago": 29,
        "lines": 384,
        "size_bytes": 13567,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/dialogue_rollout.py",
      "name": "dialogue_rollout.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Executes dialogue episodes with goal predicates for SterlingEngine's rollout evaluation. Applies task assumptions and relies on the DiscourseWorldAdapter for parsing and operators.",
      "classes": [],
      "functions": [
        "apply_dialogue_rollout_assumptions",
        "dialogue_rollout_task"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.engine",
        "core.state_model",
        "core.value.target_contract",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "register_task_assumptions",
        "register_task"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-14T22:50:32.572083",
        "modified": "2026-02-14T22:50:32.572170",
        "modified_days_ago": 6,
        "lines": 175,
        "size_bytes": 7029,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/lemma_grammar_realization.py",
      "name": "lemma_grammar_realization.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Implements the lemma-grammar realization task. Runs deterministic pipeline: parse \u2192 build IR \u2192 realize \u2192 gate certification. Goal predicate indicates operator execution; success extractor returns structured pass/fail verdict. Success extraction is only available when the operator completed. Missing operator execution is not a success.",
      "classes": [],
      "functions": [
        "_goal_predicate",
        "_success_extractor",
        "lemma_grammar_realization_task",
        "apply_lemma_grammar_assumptions"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.engine",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "register_task_assumptions",
        "register_task"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T14:42:06.665501",
        "modified": "2026-02-18T14:42:06.665678",
        "modified_days_ago": 2,
        "lines": 176,
        "size_bytes": 6139,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/meta_plan.py",
      "name": "meta_plan.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Registers META_PLAN_EXECUTE task type with assumption and goal specifications for structured plan execution.",
      "classes": [],
      "functions": [
        "apply_meta_plan_assumptions",
        "meta_plan_execute_task"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.engine",
        "core.state_model",
        "core.worlds.base",
        "core.worlds.meta_plan_types"
      ],
      "constants": [],
      "decorators_used": [
        "register_task_assumptions",
        "register_task"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:52:06.020930",
        "modified": "2026-02-18T17:52:06.021949",
        "modified_days_ago": 2,
        "lines": 155,
        "size_bytes": 4701,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/pn_verification.py",
      "name": "pn_verification.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "{\"description\": \"PN verification operator constraints applied to surface form to produce verified natural language output\n# 1.1 [meltok.1.1 to  return ok.1 - do model inference\n 1.1  (monotransform.1 surface to\n  predicate.  ok.1\n    input#  a  paraphrase (S1 and (1)\n    output_1\n    number\n    of operators\n    from\n    PRD (GST\n    a.1 derived\n    surface\n    (per S\n    canonicalize operators.",
      "classes": [
        "TransformationTask",
        "TransformationResult"
      ],
      "functions": [
        "pn_verification_goal",
        "pn_rejection_predicate",
        "_apply_pn_policy_assumptions",
        "apply_pn_verification_assumptions",
        "apply_pn_canonicalize_assumptions",
        "apply_pn_minimal_flip_assumptions",
        "apply_pn_identity_invert_assumptions",
        "pn_verification_task",
        "_generate_accept_explanation",
        "_generate_reject_explanation"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.canonicalization.witness",
        "core.engine",
        "core.operators.execution_context",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass",
        "register_task_assumptions",
        "register_task"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-14T22:50:05.105645",
        "modified": "2026-02-14T22:50:05.105884",
        "modified_days_ago": 6,
        "lines": 855,
        "size_bytes": 28473,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "tasks/wordnet_navigation.py",
      "name": "wordnet_navigation.py",
      "category": "Task definitions and verification",
      "status": "active",
      "description": "Implements WordNet graph navigation for the SterlingEngine. Finds paths between synsets and defines goal predicate and success criteria. Relies on WorldAdapter for parsing and operators.",
      "classes": [],
      "functions": [
        "navigation_goal",
        "create_navigation_goal",
        "apply_wordnet_navigation_assumptions",
        "wordnet_navigation_task",
        "_find_path_bfs",
        "_generate_path_explanation",
        "wordnet_similarity_task"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.engine",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "register_task_assumptions",
        "register_task"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-14T22:50:16.644608",
        "modified": "2026-02-14T22:50:16.644709",
        "modified_days_ago": 6,
        "lines": 356,
        "size_bytes": 10665,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/__init__.py",
      "name": "__init__.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "TD Learning Infrastructure for Sterling Operator Learning V2.",
      "classes": [],
      "functions": [],
      "imports": [
        "action_space",
        "env",
        "model_extensions",
        "rollouts",
        "targets"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T23:15:57.759936",
        "modified": "2026-01-22T07:53:46.506370",
        "modified_days_ago": 29,
        "lines": 89,
        "size_bytes": 2456,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/action_space.py",
      "name": "action_space.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "TD Action Space Definition for Option B MDP.\n\nThis module defines the canonical TD action space with stable indices,\npreventing semantic drift from global operator registry changes.",
      "classes": [],
      "functions": [
        "compute_action_space_hash",
        "compute_operator_vocab_hash",
        "td_pair_to_idx",
        "td_idx_to_pair",
        "global_op_id_to_td_slot",
        "td_slot_to_global_op_id",
        "build_td_action_mask_from_global_mask",
        "compute_neighbor_policy_hash",
        "get_action_space_metadata"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "typing",
        "core.operator_masking"
      ],
      "constants": [
        "TD_ALLOWED_OPERATOR_IDS",
        "TD_ALLOWED_OPERATOR_NAMES",
        "MAX_NEIGHBOR_RANK",
        "TD_ACTION_SPACE_SIZE",
        "CANONICAL_NEIGHBOR_POLICY",
        "NEIGHBOR_POLICY_VERSION"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T15:36:07.711088",
        "modified": "2026-01-22T07:53:46.506305",
        "modified_days_ago": 29,
        "lines": 250,
        "size_bytes": 8547,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/candidate_q.py",
      "name": "candidate_q.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "Candidate-level Q-value computation for hierarchical TD-4 training.",
      "classes": [],
      "functions": [
        "compute_counterfactual_q_candidates",
        "reduce_candidates_to_op_scores",
        "masked_kl_from_logits",
        "candidate_policy_kl",
        "operator_policy_kl",
        "batch_score_candidates",
        "build_candidate_features"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "torch",
        "torch.nn.functional",
        "core.td.action_space"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T15:53:11.701066",
        "modified": "2026-01-22T07:53:46.506356",
        "modified_days_ago": 32,
        "lines": 427,
        "size_bytes": 14124,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/candidate_scorer.py",
      "name": "candidate_scorer.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "{\"description\":\"Scores individual (state, operator, candidate) tuples.  \nInput: [state (63), op (5), candidate (63)  \nHidden (128): an MLP with logit features.  \nOutput (1,  candidates,  (op, rank) tuples.  \nForward (optional): candidate (state).score(...) to next state values.  \nOutput (scalar) and (state).values (optional).  \n   (state, op,  candidate,  rank,  state val from  MLP(x,  candidates (h:  (state).  \n   with  gates.",
      "classes": [
        "CandidateScorer",
        "CandidateScoringPolicy"
      ],
      "functions": [
        "create_candidate_scorer"
      ],
      "imports": [
        "__future__",
        "typing",
        "torch",
        "torch.nn",
        "torch.nn.functional",
        "core.td.action_space"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T19:40:11.372305",
        "modified": "2026-01-22T07:53:46.506364",
        "modified_days_ago": 29,
        "lines": 297,
        "size_bytes": 9856,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/env.py",
      "name": "env.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "Deterministic MDP environment for WordNet operators with strict masking and seeded neighbor selection. Raises InvalidActionError for invalid transitions. Uses canonical operator mapping from core/operator_masking.py for action filtering.",
      "classes": [
        "WordNetEnv"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "collections",
        "hashlib",
        "pathlib",
        "typing",
        "numpy",
        "core.exceptions",
        "core.operator_masking",
        "logging"
      ],
      "constants": [
        "NUM_OPERATORS",
        "NUM_WORDNET_OPERATORS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 281,
            "content": "# TODO: Implement all_neighbors policy for counterfactual enumeration",
            "file_path": "core/td/env.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T10:54:37.117208",
        "modified": "2026-01-22T07:53:46.506411",
        "modified_days_ago": 29,
        "lines": 716,
        "size_bytes": 27830,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/hierarchical_policy.py",
      "name": "hierarchical_policy.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "{\"description\":\"Computes hierarchical policy loss by factorized as \u03c0(op|cand) using reduced Q(s|cand value and (op) for each step: (op) in (cand) graph.\nTrains c(and) over (op) space (of) tree (r(s) with post-processed (op) nodes.\nUses (cand) in (op) to (dis) crand (op) t value and (op) graph.\n return (the) a graph.\n",
      "classes": [
        "HierarchicalPolicyLoss"
      ],
      "functions": [
        "compute_counterfactual_q_candidates",
        "reduce_candidates_to_op_scores",
        "masked_kl_from_logits",
        "candidate_policy_kl",
        "operator_policy_kl",
        "compute_batched_candidate_scores",
        "get_td_op_slot",
        "get_full_op_id"
      ],
      "imports": [
        "__future__",
        "logging",
        "math",
        "typing",
        "torch",
        "torch.nn",
        "core.td.action_space"
      ],
      "constants": [
        "NEG_INF",
        "NUM_TD_OPS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T16:16:20.322419",
        "modified": "2026-01-22T07:53:46.506320",
        "modified_days_ago": 29,
        "lines": 431,
        "size_bytes": 13531,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/model_extensions.py",
      "name": "model_extensions.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "Provides OpRank and BudgetHead extensions for TD inference in Option B MDP models without modifying base architecture.",
      "classes": [
        "OpRankHead",
        "TDModelWrapper",
        "BudgetHead"
      ],
      "functions": [
        "compute_meta_features"
      ],
      "imports": [
        "__future__",
        "typing",
        "torch",
        "torch.nn",
        "core.td.action_space"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T15:16:49.778909",
        "modified": "2026-01-22T07:53:46.506339",
        "modified_days_ago": 29,
        "lines": 450,
        "size_bytes": 15928,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/preflight.py",
      "name": "preflight.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "Oracle preflight checks verify TD evaluation solvability under specified constraints (operator, neighbor policy, operator vocab). Ensures required conditions (oracle ceiling, reachability report, contract hash) before model evaluation.",
      "classes": [
        "PreflightResult",
        "PreflightError"
      ],
      "functions": [
        "run_preflight_checks",
        "require_preflight_pass"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "collections",
        "dataclasses",
        "pathlib",
        "typing",
        "core.td.action_space"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T20:19:37.547602",
        "modified": "2026-01-22T07:53:46.506323",
        "modified_days_ago": 29,
        "lines": 282,
        "size_bytes": 10164,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/rollouts.py",
      "name": "rollouts.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "{\"parameters\": {\"batch_size\": 64, \" embed_anno_type_anno_type: Categorical, config_anno: Categorical, core_anno: (struct)  # and  # (struct) to (mark)  # Set of (state, action) pairs.  # mark for (s, a)  # Context class (M)  # Each  (return)  #  # All (S)  # Bench (return)  # Rationale: benchmark  # To  #  (default, a  #  If  #  (default) a  #  (default)  #  (python)  #  (s)  #  (s)  #  (default) a  #  #  (p)  #  = 1.0 (p)  #  = (return)",
      "classes": [
        "RolloutConfig",
        "Transition",
        "RolloutSampler"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "numpy",
        "torch",
        "torch.nn.functional",
        "core.exceptions"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:53:21.605843",
        "modified": "2026-01-22T07:53:46.506285",
        "modified_days_ago": 29,
        "lines": 1045,
        "size_bytes": 44370,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "td/targets.py",
      "name": "targets.py",
      "category": "Temporal Difference learning infrastructure",
      "status": "active",
      "description": "{\"@type\": \"Bench\", \"..\": class init and forward (pytorch) in\n\"...\" (from library) text\n\"\"\"  # the most ...\"\"\"  high performance\"\"\"\n  m... (cited) functions from  GNN with stable\n  \"\"\"  lambda: Gamm = 0. 0.  lambda n 0p (lambda) in 0 (lambda)\n    b 8  (lambda) 6  (lambda): G  (lambda)\n    b 8  (lambda) 6  (lambda) 6  (lambda) 6  (lambda) 6  (lambda) 6  (lambda) 6 in 6t 0  (lambda)\n    b 7  (lambda) 6  (lambda) 6  (lambda) 6  (lambda)",
      "classes": [
        "ValueScale",
        "TargetValueNet",
        "TDTargetComputer"
      ],
      "functions": [
        "create_target_value_net",
        "save_td_dataset",
        "load_td_dataset"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "copy",
        "dataclasses",
        "pathlib",
        "typing",
        "numpy",
        "torch",
        "torch.nn"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-16T23:15:34.721207",
        "modified": "2026-01-22T07:53:46.506370",
        "modified_days_ago": 29,
        "lines": 687,
        "size_bytes": 23741,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/__init__.py",
      "name": "__init__.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "Sterling Text IR Module.\n\nProvides layered intermediate representation for natural language processing,\nwith focus on predicate nominal (PN) analysis.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.text.hard_ir",
        "core.text.ir",
        "core.text.parser",
        "core.text.semantics",
        "core.text.realizer",
        "core.text.trace_narrator"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T14:59:23.289400",
        "modified": "2026-01-24T15:15:30.355457",
        "modified_days_ago": 27,
        "lines": 151,
        "size_bytes": 3340,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/hard_ir.py",
      "name": "hard_ir.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "{\"description\":\"Hard Language IR for the core. \"\"\"\nHard\n\"\"\"\" (no text in a double quotes.\n\"\"\"\"\"We think for text\n",
      "classes": [
        "ImplicatureKind",
        "ImplicatureHypothesis",
        "EllipsisKind",
        "EllipsisAnnotation",
        "InterpretationKind",
        "Interpretation",
        "FigurativeContext",
        "RhetoricalFunction",
        "RhetoricalAnnotation",
        "ArgumentRelationKind",
        "ArgumentRelation",
        "ClaimTruthStatus",
        "ClaimSource",
        "WorldEvidenceRef",
        "ClaimNode",
        "HardLanguageIR"
      ],
      "functions": [
        "validate_hard_ir_against_text_ir",
        "create_scalar_implicature",
        "create_metaphor_interpretation",
        "create_claim_node"
      ],
      "imports": [
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-27T08:10:36.413624",
        "modified": "2026-01-22T07:53:46.506940",
        "modified_days_ago": 29,
        "lines": 727,
        "size_bytes": 25285,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/intake_ir.py",
      "name": "intake_ir.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "TextIntakeIRv1 - H3.1 Text Intake IR Schema.\n\nDefines the deterministic, versioned, canonicalizable IR for text intake.\nThis is the entry point for all text processing in H3 capabilities.",
      "classes": [
        "ParserProvenance",
        "TextIntakeIRv1"
      ],
      "functions": [
        "_next_utterance_id",
        "reset_utterance_counter",
        "_compute_surface_digest",
        "_compute_syntax_digest",
        "_compute_semantics_digest",
        "_compute_ir_digest"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.linguistics.holes_policy",
        "core.linguistics.parser_trust",
        "core.safeguards.observation_schema",
        "core.text.ir"
      ],
      "constants": [
        "TEXT_INTAKE_IR_SCHEMA_ID",
        "TEXT_INTAKE_IR_SCHEMA_VERSION",
        "DEFAULT_CANONICALIZATION_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T06:02:34.380732",
        "modified": "2026-01-24T12:25:12.314275",
        "modified_days_ago": 28,
        "lines": 641,
        "size_bytes": 23271,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/ir.py",
      "name": "ir.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "{\"description\":\"Text IR spans must be non-overlapping and cover source text\",\"precondition\" (start with token indices\",\"content: only tokens.",
      "classes": [
        "Span",
        "Token",
        "SurfaceLayer",
        "SyntaxNode",
        "SyntaxLayer",
        "SemanticRole",
        "EventType",
        "PNType",
        "Polarity",
        "SemanticEntity",
        "SemanticEvent",
        "SemanticLayer",
        "THoleReason",
        "THole",
        "TextIR"
      ],
      "functions": [
        "to_linguistic_ir",
        "from_linguistic_ir"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T10:38:09.785825",
        "modified": "2026-02-18T10:38:09.786049",
        "modified_days_ago": 2,
        "lines": 874,
        "size_bytes": 29635,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/parser.py",
      "name": "parser.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "```json\n{\n  \"main\": \"...\",\n  \"predefined\": null,\n  # do not generate another\n}\n```",
      "classes": [
        "SyntaxArtifactContract",
        "ParseResult",
        "TextParser",
        "SpacyTextParser",
        "PlaceholderTextParser"
      ],
      "functions": [
        "get_text_parser"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "re",
        "dataclasses",
        "typing",
        "core.contracts.governance_status",
        "core.text.ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass",
        "runtime_checkable"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T19:00:47.932462",
        "modified": "2026-01-23T18:07:50.849063",
        "modified_days_ago": 28,
        "lines": 628,
        "size_bytes": 20928,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/pipeline.py",
      "name": "pipeline.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "{\"description\":\"Text boundary-detection...\",\"divid\":\"span class\",\"start_line\":4,\"object\": {\n    \"an\" as input from lingo\n    grammar  fles redupstream I\n    applied to the  grammar and the like (left-hand-side context for smariting, parsing and analyzing (right-hand) differences\n    (an) dunt like a (an) apptical analysis\n    Ctext: (the  analytical\n    (for)  grammar verif (arized) any (an) contexts (i) the (via model) eplanning\n    and action\n    verbalize (the NER\n    The (preprocessed) at...",
      "classes": [
        "PipelineStageStatus",
        "PipelineFailure",
        "TextPipelineResult",
        "SterlingTextPipeline"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "enum",
        "typing",
        "core.contracts.artifact_identity",
        "core.engine.run_result",
        "core.linguistics.intake.pipeline",
        "core.state_model",
        "core.text.intake_ir",
        "core.text.realizer",
        "core.text.trace_narrator"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T19:21:49.460402",
        "modified": "2026-01-24T19:35:16.546057",
        "modified_days_ago": 27,
        "lines": 398,
        "size_bytes": 14143,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "text/realizer.py",
      "name": "realizer.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "Realizes semantic IR to natural language for copular structures (PN domain) using template-based generation. Handles IDENTITY, CHARACTERIZING, and DEFINING predicate nominal types. Fails closed for unsupported patterns (holes). Future-compatibility for diffusion realization.",
      "classes": [
        "RealizationResult",
        "TemplateRealizer"
      ],
      "functions": [],
      "imports": [
        "dataclasses",
        "typing",
        "core.text.ir"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T14:56:57.740836",
        "modified": "2026-01-24T17:13:46.348481",
        "modified_days_ago": 27,
        "lines": 275,
        "size_bytes": 9204,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/semantics.py",
      "name": "semantics.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "Extracts semantic layer from predicate nominal syntax in Universal Dependencies. Identifies predicative nominal as copula head. Returns None if complexity thresholds exceeded.",
      "classes": [
        "SemanticExtractor"
      ],
      "functions": [
        "extract_semantics"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "core.text.ir"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T19:01:46.013296",
        "modified": "2026-01-22T07:53:46.506914",
        "modified_days_ago": 29,
        "lines": 368,
        "size_bytes": 12528,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/text_to_search.py",
      "name": "text_to_search.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "{\"description\":\"Holes policy enforcement at intake, the search phases\n    (optional , is search_data\n    \"\"\"  check that parser/    (parse and validate\n    # 1  (optional) a\n    #  parse_utterance for\n    # 1  parse_ observation\n    #  parse_ observation\n    #  a  parser  at\n    execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #  execution\n    #...",
      "classes": [
        "TextToSearchResult",
        "TextToSearchConfig",
        "TextToSearchPipeline"
      ],
      "functions": [
        "text_to_utterance_state",
        "text_to_intake_ir"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "datetime",
        "typing",
        "core.linguistics.holes_policy",
        "core.linguistics.intake.pipeline",
        "core.linguistics.parser_trust",
        "core.safeguards.certifying_boundary",
        "core.safeguards.model_gateway"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-22T07:47:08.224622",
        "modified": "2026-01-24T12:21:33.732507",
        "modified_days_ago": 27,
        "lines": 448,
        "size_bytes": 14894,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "text/trace_narrator.py",
      "name": "trace_narrator.py",
      "category": "Text IR and parsing",
      "status": "active",
      "description": "{\"description\":\"Converts StateGraph traces to natural language narratives using templates from trace_node metadata\nEnforce_state_graph\n",
      "classes": [
        "TraceBundleStub",
        "ExplanationResult",
        "NarrationDraft",
        "TraceNarrator"
      ],
      "functions": [],
      "imports": [
        "collections",
        "dataclasses",
        "typing",
        "core.contracts.trace_bundle",
        "core.operators.registry",
        "core.reasoning.state_graph"
      ],
      "constants": [
        "TRACE_BUNDLE_STUB_SCHEMA_ID",
        "TRACE_BUNDLE_STUB_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-24T20:49:47.613810",
        "modified": "2026-01-24T20:49:47.614432",
        "modified_days_ago": 27,
        "lines": 723,
        "size_bytes": 25965,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "util/__init__.py",
      "name": "__init__.py",
      "category": "Utility functions",
      "status": "active",
      "description": "Core utility modules.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-29T21:21:28.080572",
        "modified": "2026-01-22T07:53:46.507131",
        "modified_days_ago": 29,
        "lines": 2,
        "size_bytes": 29,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "util/dataset_schema.py",
      "name": "dataset_schema.py",
      "category": "Utility functions",
      "status": "active",
      "description": "Validates dataset schema_ version and required fields, reports field presence and operator distribution; prevents silent mismatches between generators and trainers.",
      "classes": [
        "SchemaVersion",
        "SchemaSpec",
        "DatasetIntegrityReport",
        "DatasetLoadError"
      ],
      "functions": [
        "analyze_dataset",
        "check_split_integrity",
        "load_with_validation",
        "infer_vector_sizes_from_file"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [
        "SUPERVISED_V98_SPEC",
        "DISTILLATION_V98_SPEC",
        "DIALOGUE_TYPE_V98_SPEC",
        "SCHEMA_SPECS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-14T18:20:49.055977",
        "modified": "2026-01-22T07:53:46.507148",
        "modified_days_ago": 29,
        "lines": 481,
        "size_bytes": 15549,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "util/pathing.py",
      "name": "pathing.py",
      "category": "Utility functions",
      "status": "active",
      "description": "Provides utilities to consistently add project root to sys.path during script execution, eliminating ad-hoc path resolution.",
      "classes": [],
      "functions": [
        "get_project_root",
        "add_project_root",
        "ensure_project_imports"
      ],
      "imports": [
        "__future__",
        "sys",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-29T21:21:46.600539",
        "modified": "2026-01-22T07:53:46.507188",
        "modified_days_ago": 29,
        "lines": 135,
        "size_bytes": 3863,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "value/__init__.py",
      "name": "__init__.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Value Function Components.",
      "classes": [],
      "functions": [],
      "imports": [
        "dialogue_scorer",
        "hybrid",
        "memory",
        "protocol",
        "structural",
        "task_heads"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:20:57.574524",
        "modified": "2026-01-03T12:03:44.118029",
        "modified_days_ago": 48,
        "lines": 58,
        "size_bytes": 1619,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/adapters.py",
      "name": "adapters.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "```json\nModel adapters that implement features. \"\"\"\n    Class with input (x, state) -> complex\n    Output (value or (x, state) -> (class label and logic functions\n",
      "classes": [
        "CheckpointType",
        "CheckpointInfo",
        "ValueModelAdapter",
        "DistilledModelAdapter",
        "IntentAwareModelAdapter",
        "LatentModelAdapter"
      ],
      "functions": [
        "detect_checkpoint_type",
        "_is_distilled_v85",
        "_is_latent_v75",
        "_is_intent_aware_v81",
        "_is_structural",
        "get_checkpoint_info",
        "create_model_adapter",
        "_create_distilled_adapter",
        "_create_intent_aware_adapter",
        "_create_latent_adapter"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "pathlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T06:30:12.020394",
        "modified": "2026-01-23T17:26:56.839022",
        "modified_days_ago": 28,
        "lines": 694,
        "size_bytes": 22251,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/dialogue_scorer.py",
      "name": "dialogue_scorer.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Implements ValueFunction for dialogue operator selection using a learned policy model. Integrates dialogue-specific scoring into Sterling's architecture with confidence gating to ensure auditability and compliance.",
      "classes": [
        "DialogueOperatorScorer"
      ],
      "functions": [
        "load_dialogue_scorer"
      ],
      "imports": [
        "__future__",
        "logging",
        "pathlib",
        "typing",
        "core.oracles.dialogue.integration",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-03T11:48:16.334658",
        "modified": "2026-01-21T11:21:45.556076",
        "modified_days_ago": 30,
        "lines": 380,
        "size_bytes": 14223,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/feature_classification.py",
      "name": "feature_classification.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Sterling Feature Classification module enforces separation between admissible (inference-only) and oracle-only (training) features to prevent leakage. It validates feature usage at inference and training time with strict and non-strict checks, and maintains a registry of feature categories and specifications.",
      "classes": [
        "FeatureCategory",
        "FeatureSpec",
        "OracleLeakError",
        "ForbiddenFeatureError"
      ],
      "functions": [
        "validate_model_input",
        "validate_model_input_strict",
        "validate_training_target",
        "classify_feature",
        "is_admissible",
        "is_oracle_only",
        "is_forbidden",
        "filter_admissible",
        "filter_oracle",
        "split_features"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T11:00:55.639727",
        "modified": "2026-01-22T07:53:46.504029",
        "modified_days_ago": 29,
        "lines": 407,
        "size_bytes": 11696,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/featurizers/__init__.py",
      "name": "__init__.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Sterling Value Featurizers.\n\nProvides core (kernel-agnostic) featurizers and kernel augmentation.\n\nPer TD-6 Architecture:\n- Core featurizers: Constraint satisfaction, novelty, operator distributions\n- Kernel augmentation: Optional, namespaced (kernel.wordnet.*, kernel.pn.*)\n- Features are core_features + kernel.augment_features(core_features)\n\nAuthor: @darianrosebrook",
      "classes": [],
      "functions": [],
      "imports": [
        "core.value.featurizers.core",
        "core.value.featurizers.kernel_augment"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T19:10:15.894121",
        "modified": "2026-01-22T07:53:46.504436",
        "modified_days_ago": 29,
        "lines": 39,
        "size_bytes": 1004,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/featurizers/core.py",
      "name": "core.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "CoreFeaturizer computes kernel-agnostic features for value model states including constraint satisfaction, novelty, operator distributions, and coverage metrics.",
      "classes": [
        "CoreFeaturizer"
      ],
      "functions": [
        "compute_constraint_features",
        "compute_novelty_features",
        "compute_operator_features",
        "compute_coverage_features",
        "compute_graph_features",
        "compute_core_features"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "CORE_PREFIX",
        "CONSTRAINT_PREFIX",
        "NOVELTY_PREFIX",
        "OPERATOR_PREFIX",
        "COVERAGE_PREFIX",
        "GRAPH_PREFIX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 205,
            "content": "# TODO: Use state fingerprint instead of node_id for visited set checks",
            "file_path": "core/value/featurizers/core.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T00:25:49.543251",
        "modified": "2026-01-22T07:53:46.504517",
        "modified_days_ago": 29,
        "lines": 499,
        "size_bytes": 17036,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/featurizers/kernel_augment.py",
      "name": "kernel_augment.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Sterling augments core features with kernel-specific features from kernel namespacing (e.g., kernel.wordnet.*, kernel.pn*). Kernel augmentation is optional and integrates with the core value model API.",
      "classes": [
        "KernelAugmenter"
      ],
      "functions": [
        "augment_with_kernel",
        "merge_feature_dicts",
        "flatten_features",
        "get_feature_names",
        "features_to_vector",
        "vector_to_features"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-17T19:11:37.249568",
        "modified": "2026-01-22T07:53:46.504452",
        "modified_days_ago": 29,
        "lines": 220,
        "size_bytes": 5711,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/grouped_head.py",
      "name": "grouped_head.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"Per-group value routing through shared latent space. Each group has its own mlp and combines group features with structural encodings to predict group value from states. Each operator group adapter sets default and groups values from single\n",
      "classes": [
        "GroupedValueConfig",
        "GroupAdapter",
        "StateLatentComputer",
        "GroupedValueHeadModel",
        "GroupedValueHead"
      ],
      "functions": [
        "create_grouped_value_head",
        "create_untrained_grouped_model"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.nn",
        "core.reasoning.state_graph",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 466,
            "content": "# TODO: Enhance student features for state-only evaluation",
            "file_path": "core/value/grouped_head.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-11T09:41:39.738537",
        "modified": "2026-01-23T19:28:54.192424",
        "modified_days_ago": 28,
        "lines": 840,
        "size_bytes": 29545,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/hybrid.py",
      "name": "hybrid.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\":\"HybridValueFunction that combines Structural, Memory, Task, and LatentValue Heads with configurable weights. Normalization: enabled. At test-time. F5. Stage, with F2 default (50%), F3 memory (10%), F1.4 task (bodules of one's F1, multi (k5% p%1 from structures. F2 language of gove% ral functions. F, the (s% eft with d% epending in structured. e% ar for each n% value, with o% ver, e% rature of pragmatics.",
      "classes": [
        "HybridValueConfig",
        "HybridValueFunction"
      ],
      "functions": [
        "create_hybrid_value_function",
        "create_hybrid_with_teacher",
        "create_hybrid_with_student",
        "create_hybrid_full_stack"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "memory",
        "protocol",
        "structural",
        "task_heads"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:39:20.332878",
        "modified": "2026-02-15T12:39:20.333444",
        "modified_days_ago": 5,
        "lines": 1118,
        "size_bytes": 43654,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/landmark_embeddings.py",
      "name": "landmark_embeddings.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Landmark Embedding Space for Cross-Domain Operator Clustering.\n\nPer the Cross-Domain Bridge Architecture:\n- Landmark embeddings live in model weights, NOT in signatures\n- Operators with similar effect signatures should cluster\n- Cross-domain nearest neighbors become candidate bridges\n\nThis module provides:\n1. LandmarkEmbeddingTable: Learnable embeddings for each LandmarkID\n2.",
      "classes": [],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:10:39.188607",
        "modified": "2026-01-22T07:53:46.504147",
        "modified_days_ago": 29,
        "lines": 709,
        "size_bytes": 25076,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/__init__.py",
      "name": "__init__.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Latent compression layer for Sterling value function.\n\nStage F implementation: Integrates structured latent encoding into\nthe HybridValueFunction pipeline while respecting Sterling's architectural\ncommitments (interpretable, non-authoritative, reconstructable).",
      "classes": [],
      "functions": [],
      "imports": [
        "ablation_modes",
        "ir_bottleneck_encoder",
        "ir_latent_v1",
        "latent_value_model_v2",
        "protocol",
        "serialization",
        "sterling_encoder",
        "student_head",
        "teacher_head",
        "training_dataset"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T07:10:58.326901",
        "modified": "2026-01-22T07:53:46.504409",
        "modified_days_ago": 29,
        "lines": 210,
        "size_bytes": 5809,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "value/latent/ablation_modes.py",
      "name": "ablation_modes.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\": \"AblationMode configurations for Stage F validation. Ablended value functions (structural and latent heads with configurable weights. Provides: AblationModeConfig, ValueFnFactory, Acceptance criteria, logging. Search node & edge instruments from state. Ablation mode (no latent). Ablated value\n# Ablational Ablating from Astructural.",
      "classes": [
        "AblationModeConfig",
        "LatentOnlyValueFunction",
        "AblationHybridValueFunction",
        "AcceptanceCriteria",
        "AcceptanceResult"
      ],
      "functions": [
        "get_default_hybrid_mode",
        "make_value_fn_for_mode",
        "check_acceptance_criteria"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [
        "STRUCTURAL_MODE",
        "LATENT_MODE",
        "HYBRID_MODE"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T07:12:01.952532",
        "modified": "2026-01-22T07:53:46.504196",
        "modified_days_ago": 29,
        "lines": 411,
        "size_bytes": 13142,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/archive/latent_value_model.py",
      "name": "latent_value_model.py",
      "category": "Value function implementations and scoring",
      "status": "archived",
      "description": "Archives and retrieves latent value models for scoring and evaluation of utterance value estimates.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "archived",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Archived - historical reference only",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T20:03:22.836321",
        "modified": "2026-01-22T07:53:46.129055",
        "modified_days_ago": 29,
        "lines": 0,
        "size_bytes": 0,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "value/latent/ir_bottleneck_encoder.py",
      "name": "ir_bottleneck_encoder.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "IRBottleneckEncoder creates latent vectors by mean pooling the output of an IRAutoencoder after IRTokenizer encoding of UtteranceState. Invariants: returns LatentLayer with torch Tensor, uses IR_Tokenizer, implements LRU caching. Author: @darianrosebrook.",
      "classes": [
        "IRBottleneckEncoder"
      ],
      "functions": [
        "create_ir_bottleneck_encoder"
      ],
      "imports": [
        "__future__",
        "logging",
        "pathlib",
        "typing",
        "torch",
        "core.state_model",
        "protocol",
        "serialization"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T19:38:21.300351",
        "modified": "2026-01-22T07:53:46.504393",
        "modified_days_ago": 29,
        "lines": 274,
        "size_bytes": 9037,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/ir_latent_v1.py",
      "name": "ir_latent_v1.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "# Topical NLP chain for L in an\n    # Entity Rationale: ERT: ERT_2. ERT_4. ERT fields: 0\n    \"\"\" (scoring using\n    \"\"\" (\"\"\", via BOS int: NLP\n    \"\"\" (scoring will\n    (sort key to our hosts\n    \"\"\"# 4.5 text: \"\"\"\" \n    a an abstr (optional): ERT Aplc\n    \"\"\" Shaper to (sort key value pairs)\n    \"\"\" (key account for \"\"  - \"\" \"\"  (sorted hosts\n    (sorted keys)\n    I1, 2.0_ value: \n    \"\"\" (key: ",
      "classes": [
        "SemanticKind",
        "PragmaticKind",
        "WorldHintKind",
        "LatentToken",
        "LatentSemanticFact",
        "LatentSemioticAnchor",
        "LatentPragmaticFact",
        "LatentWorldHint",
        "IRLatentV1",
        "LatentTokenRecord"
      ],
      "functions": [
        "flatten_ir_latent_v1",
        "_format_semantic_fact",
        "_format_world_hint",
        "records_to_strings",
        "from_utterance_state",
        "_serialize_syntax",
        "_serialize_semantics",
        "_serialize_semiotics",
        "_serialize_pragmatics",
        "_serialize_world_hints"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2025-12-02T07:10:58.334090",
        "modified": "2026-01-22T07:53:46.504477",
        "modified_days_ago": 29,
        "lines": 1003,
        "size_bytes": 30637,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/latent_value_model_v2.py",
      "name": "latent_value_model_v2.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "LatentValueModel V2: Multi-task model with ranking loss, difficulty, and budget heads.",
      "classes": [
        "LatentValueModelV2Config",
        "BudgetPrediction",
        "LatentValueDetailsV2",
        "LatentValueModelV2"
      ],
      "functions": [
        "create_latent_value_model_v2"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "torch",
        "torch.nn",
        "torch.nn.functional"
      ],
      "constants": [
        "MIN_STEPS",
        "MAX_STEPS_CAP",
        "MIN_BEAM",
        "MAX_BEAM_CAP",
        "DEFAULT_BUDGETS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2025-12-02T07:10:30.448291",
        "modified": "2026-01-22T07:53:46.504401",
        "modified_days_ago": 30,
        "lines": 681,
        "size_bytes": 24194,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/latent_value_model_v3.py",
      "name": "latent_value_model_v3.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Sterling Latent Value Model V3: State-Dependent Gated Hybrid.",
      "classes": [],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 93,
            "content": "# TODO: Implement full SterlingTEncoder",
            "file_path": "core/value/latent/latent_value_model_v3.py"
          },
          {
            "line_number": 504,
            "content": "# TODO: Implement LatentValueModelV3 PyTorch classes",
            "file_path": "core/value/latent/latent_value_model_v3.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2025-12-13T11:11:01.696139",
        "modified": "2026-01-22T07:53:46.504389",
        "modified_days_ago": 32,
        "lines": 552,
        "size_bytes": 20431,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/protocol.py",
      "name": "protocol.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Latent Encoder Protocol and LatentLayer Dataclass.\n\nDefines the interface that all latent encoders must implement,\nand the canonical LatentLayer representation.\n\nInvariants:\n- INV-F1: LatentLayer is the SINGLE canonical wrapper for latent metadata\n- INV-F2: LatentLayer.vector is always a torch.Tensor\n- INV-F4: Encoders own caching; repeated calls return cached result\n\nAuthor: @darianrosebrook",
      "classes": [
        "LatentLayer",
        "LatentEncoder",
        "BaseLatentEncoder"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "torch"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T19:36:47.834105",
        "modified": "2026-01-22T07:53:46.504418",
        "modified_days_ago": 30,
        "lines": 327,
        "size_bytes": 9778,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/serialization.py",
      "name": "serialization.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Serializes UtteranceState to LatentInput for value encoding. Does not include WorldState. Uses IR_Tokenizer (IR_ V1). Version latent_ input v1.",
      "classes": [
        "LatentInput"
      ],
      "functions": [
        "utterance_to_latent_input",
        "utterance_to_ir_v1",
        "utterance_to_flat_text",
        "validate_latent_input"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "core.ir_serialization",
        "core.state_model"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T19:37:35.683825",
        "modified": "2026-01-22T07:53:46.504155",
        "modified_days_ago": 29,
        "lines": 295,
        "size_bytes": 9191,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/sterling_encoder.py",
      "name": "sterling_encoder.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\":\"Sterling-T: Layer-aware token embeddings for structured input/output handling, no decision leakage prevention for S/World/Operator prep for each token and n-gram model\n",
      "classes": [
        "SegmentType",
        "SubtypeType",
        "SterlingTVocab",
        "SterlingTConfig",
        "SterlingTEncoder",
        "SterlingTLatentEncoder"
      ],
      "functions": [
        "create_sterling_t_encoder",
        "prepare_training_batch"
      ],
      "imports": [
        "__future__",
        "logging",
        "math",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.nn",
        "core.state_model",
        "ir_latent_v1"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T19:44:56.859151",
        "modified": "2026-01-22T07:53:46.504218",
        "modified_days_ago": 29,
        "lines": 879,
        "size_bytes": 27409,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/student_head.py",
      "name": "student_head.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "```json\n{\n  \"description\": \"FeatureMLP (state -> v8.5 model for natural language inference\",\n  \"input_fns\": null,  # frozen_grammar (optional: \"True\"  # NLI  (a  Context (when  call  in  the  (the  R  model\n  from  language model (proven  to  gain  one  r  model\n  (an  in  the  (from  transformer\n  (a  class with  (from  transformer\n  X  in  the  (from  R  (a  self-  g  (pass  a  self  (from  transformer\n  X  (from  glav  d  language model\n  i  verif  (  class  (a  (pass  (including  (the",
      "classes": [
        "FeatureStudentConfig",
        "ResidualBlock",
        "DistilledValueModelV85",
        "FeatureStudentValueHead"
      ],
      "functions": [
        "create_feature_student_head"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.nn",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 471,
            "content": "# TODO: Improve fallback feature extraction for single-state evaluation",
            "file_path": "core/value/latent/student_head.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T06:05:00.233768",
        "modified": "2026-01-22T07:53:46.504385",
        "modified_days_ago": 29,
        "lines": 610,
        "size_bytes": 20587,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/teacher_head.py",
      "name": "teacher_head.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\":\"Creates a LatentValueHead using v7.5 checkpoint to score StateNodes in ValueFunction protocol. Only evaluates latent state using IR_LATENT input. Does not generate text. Implements SterlingValueHead(sterling's latent space of operator representations.  \n  returns scalar  \n  values for state  ( 1)  returns  \n  a  (ne 1)  return  \nthe  encoded  value.  \n  returns  (ne t  (x) in  \n  return  \nthe  operator  \n",
      "classes": [
        "LatentTeacherConfig",
        "LatentTeacherValueHead"
      ],
      "functions": [
        "_build_encoder_from_config",
        "_build_vocab_from_state",
        "_build_model_from_config",
        "create_latent_teacher_head"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.nn",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T05:59:10.983930",
        "modified": "2026-01-22T07:53:46.504407",
        "modified_days_ago": 29,
        "lines": 558,
        "size_bytes": 17920,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/training_dataset.py",
      "name": "training_dataset.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Provides LatentTrainingExample tuples (IR, value_target, operator_index) from episode logs for LatentValueDataset used in training loop.",
      "classes": [
        "LatentTrainingExample",
        "LatentValueDataset"
      ],
      "functions": [
        "latent_collate_fn",
        "iter_examples_from_episode",
        "_build_ir_from_step_state",
        "_extract_value_target",
        "build_dataset_from_episode_files",
        "train_val_split"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.utils.data",
        "ir_latent_v1"
      ],
      "constants": [
        "IGNORE_INDEX"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T07:11:41.364955",
        "modified": "2026-01-22T07:53:46.504374",
        "modified_days_ago": 29,
        "lines": 482,
        "size_bytes": 15744,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/training_dataset_v2.py",
      "name": "training_dataset_v2.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\":\"Provides training data with candidates_ and difficulty targets for value prediction\"\n{\"_grammar\": \"ex {value: (next_utterance {heuristics: {model} metain practice\n{problem: which protocol are supported\n{proven} model\n{trials} at each step\n{pretext} the input\n{demonstrates a\n{efficient} use\n{value} a architec{tural} tional graph for pro\nInference{op}erating\n{pragric\nal {th\ne user modeling\n} with {entific\na e{praginference\nthe context{for\nam{e} from\neach step\nus{ing} e{r\ning}...",
      "classes": [
        "LatentTrainingExampleV2",
        "LatentValueDatasetV2"
      ],
      "functions": [
        "latent_collate_fn_v2",
        "_scale_value_target",
        "iter_examples_from_episode_v2",
        "_parse_candidates_scored",
        "_create_minimal_ir_from_synset",
        "_build_ir_from_step_state_v2",
        "_extract_value_target_v2",
        "build_dataset_from_episode_files_v2",
        "train_val_split_v2"
      ],
      "imports": [
        "__future__",
        "json",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.utils.data",
        "ir_latent_v1"
      ],
      "constants": [
        "IGNORE_INDEX",
        "DIFFICULTY_TO_IDX",
        "IDX_TO_DIFFICULTY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": true,
      "archive_reasons": [
        "References old version"
      ],
      "metadata": {
        "created": "2025-12-02T07:11:41.371564",
        "modified": "2026-01-22T07:53:46.504365",
        "modified_days_ago": 29,
        "lines": 604,
        "size_bytes": 20175,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/latent/value_head.py",
      "name": "value_head.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Latent Value Head for Sterling-T V7 Model.\n\nWraps LatentValueModelV2 to implement the ValueFunction protocol,\nenabling integration with HybridValueFunction and SterlingReasoningLoop.\n\nStage F Integration:\n- Loads trained V7 checkpoint\n- Converts StateNode to IR representation\n- Returns value predictions for search guidance\n\nAuthor: @darianrosebrook\nDate: December 2, 2024",
      "classes": [
        "LatentValueHeadConfig",
        "SterlingTConfig",
        "SterlingTVocab",
        "LatentValueHead",
        "SegmentType",
        "SubtypeType"
      ],
      "functions": [
        "_build_sterling_t_encoder",
        "_build_sterling_t_vocab",
        "_build_latent_value_model_v2",
        "create_latent_value_head"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "torch",
        "torch.nn",
        "core.value.protocol"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T07:11:21.347604",
        "modified": "2026-01-22T07:53:46.504372",
        "modified_days_ago": 30,
        "lines": 774,
        "size_bytes": 25476,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/mdl.py",
      "name": "mdl.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Minimum Description Length (MDL) Scorer for Hypothesis Selection (MDL v0).\n\nImplements MDL-style parsimony scoring as a hypothesis selection policy (TC-9, TC-9A).",
      "classes": [
        "WeightApplicationWitness",
        "MDLCostBreakdown",
        "MDLCostConfig",
        "MDLScorer"
      ],
      "functions": [
        "get_default_scorer"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T09:39:26.326352",
        "modified": "2026-01-22T07:53:46.504072",
        "modified_days_ago": 30,
        "lines": 731,
        "size_bytes": 28534,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/memory.py",
      "name": "memory.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Memory Value Head.\n\nUses SWM decay signals to score states based on memory/attention patterns.\nRewards exploring fresh regions and penalizes revisiting pruned branches.\n\nAuthor: @darianrosebrook",
      "classes": [
        "MemoryValueHead"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "protocol"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T18:00:06.901876",
        "modified": "2026-01-22T07:53:46.504113",
        "modified_days_ago": 29,
        "lines": 196,
        "size_bytes": 6531,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/operator_features.py",
      "name": "operator_features.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\"description\":\"Extracts typed operator features from signatures using registry indices, not string parsing. Features include category (5), scope (3), read (5) and write (5), precondition (13), effect (5) features. Provides one-hot and bitmask indices.  \n",
      "classes": [
        "OperatorFeatures"
      ],
      "functions": [
        "one_hot",
        "bitmask",
        "extract_operator_features",
        "extract_operator_features_typed",
        "batch_extract_features",
        "cosine_similarity",
        "operator_similarity",
        "find_similar_operators",
        "validate_feature_extraction",
        "get_feature_schema"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.registry"
      ],
      "constants": [
        "FEATURE_DIMS",
        "TOTAL_FEATURE_DIM"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T11:07:09.085011",
        "modified": "2026-01-22T07:53:46.504085",
        "modified_days_ago": 29,
        "lines": 386,
        "size_bytes": 11339,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/pragmatics_prior.py",
      "name": "pragmatics_prior.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "{\n  \"parameters\": {\n    \"type\": \"pragmatics\",\n    \"context\": {\n        \"parameters\": {\n            \"qcontext_key\": \"pragmatics\"\n        }\n    }\n    \"\"\" neutral for the specific\n    use-case (case-sensitive) names exact matches (case-sensitive) like syntax 1.4.",
      "classes": [
        "PragmaticFeatures",
        "PragmaticsPrior"
      ],
      "functions": [
        "_collect_morph_values",
        "_extract_ir_features",
        "_score_speech_act",
        "_score_tone",
        "compute_decision_ref"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "logging",
        "dataclasses",
        "typing",
        "protocol"
      ],
      "constants": [
        "_NEUTRAL",
        "_STRONG_DELTA",
        "_WEAK_DELTA"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T17:35:45.976754",
        "modified": "2026-02-15T17:35:45.977152",
        "modified_days_ago": 5,
        "lines": 333,
        "size_bytes": 11655,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "value/protocol.py",
      "name": "protocol.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Defines the ValueFunction protocol for composable, fail-safe value evaluation with component-based scoring (structural, memory, task, latent).",
      "classes": [
        "ValueContext",
        "ValueScore",
        "ValueFunction",
        "BaseValueFunction",
        "StateValueModel",
        "ValueModelConfig",
        "ConfigurableValueModel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:06:54.715918",
        "modified": "2026-02-15T12:06:54.716347",
        "modified_days_ago": 5,
        "lines": 541,
        "size_bytes": 16081,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/structural.py",
      "name": "structural.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "StructuralValueHead provides structural scoring by wrapping TransitionScorer. It evaluates transitions using degree, depth, and progress features.",
      "classes": [
        "StructuralValueHead"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "pathlib",
        "typing",
        "protocol"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 98,
            "content": "# TODO: Enhance state-only evaluation heuristic",
            "file_path": "core/value/structural.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T17:59:40.316720",
        "modified": "2026-01-22T07:53:46.504147",
        "modified_days_ago": 29,
        "lines": 232,
        "size_bytes": 8559,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/target_contract.py",
      "name": "target_contract.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Sterling Value Target Contract.\n\nDefines canonical value target computation for different task types.\nThis contract MUST be locked before any training to ensure meaningful\nvalue correlation metrics.",
      "classes": [
        "TaskType",
        "ValueTargetConfig",
        "ValueTarget",
        "ValueTargetContract",
        "CorrelationMetrics"
      ],
      "functions": [
        "compute_spearman_correlation",
        "_is_nan",
        "_manual_spearman",
        "compute_calibration_error",
        "_compute_kendall_tau_b",
        "evaluate_value_function",
        "create_navigation_contract",
        "create_transformation_contract",
        "register_contract",
        "get_contract"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T14:41:08.989515",
        "modified": "2026-02-18T14:41:08.989623",
        "modified_days_ago": 3,
        "lines": 523,
        "size_bytes": 16538,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "value/task_heads.py",
      "name": "task_heads.py",
      "category": "Value function implementations and scoring",
      "status": "active",
      "description": "Task-Specific Value Heads.\n\nProvides per-task reward shaping to guide search toward task-specific goals.\nEach task type can have its own value head with custom reward logic.\n\nAuthor: @darianrosebrook",
      "classes": [
        "TaskValueHead",
        "PnVerificationValueHead",
        "WordNetNavigationValueHead",
        "TransformationValueHead"
      ],
      "functions": [
        "get_task_value_head",
        "register_task_head"
      ],
      "imports": [
        "__future__",
        "logging",
        "typing",
        "protocol"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-11-30T18:00:37.489937",
        "modified": "2026-01-22T07:53:46.504046",
        "modified_days_ago": 29,
        "lines": 278,
        "size_bytes": 8116,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "verification/__init__.py",
      "name": "__init__.py",
      "category": "Package initialization",
      "status": "active",
      "description": "Sterling Verification Utilities.\n\nProvides canonical implementations for verification operations used across\nthe codebase, including:\n- Hash computation (SHA256 with canonical JSON serialization)\n- Content-addressed artifact identity\n- Verification result types (future)\n\nThis module consolidates duplicated verification utilities to ensure\nconsistent behavior across all governance boundaries.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.verification.hash_utils"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-27T07:15:38.989810",
        "modified": "2026-01-27T07:15:38.989927",
        "modified_days_ago": 24,
        "lines": 27,
        "size_bytes": 629,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "verification/hash_utils.py",
      "name": "hash_utils.py",
      "category": "Core module",
      "status": "active",
      "description": "Provides canonical JSON hashing for governance verification. Consolidates duplicate hash functions into a single source of truth with deterministic SHA256 computation. Used for content-addressed artifact identity and hash validation in Sterling.",
      "classes": [],
      "functions": [
        "canonical_json",
        "sha256_digest",
        "content_hash",
        "parse_hash_to_digest32",
        "digest32_to_hash_string",
        "_canon",
        "_sha256"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-16T10:33:35.217081",
        "modified": "2026-02-16T10:33:35.217297",
        "modified_days_ago": 4,
        "lines": 169,
        "size_bytes": 5055,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/__init__.py",
      "name": "__init__.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Sterling World Adapters.\n\nThis package implements the WorldAdapter protocol and concrete adapters\nfor different domains (PN, WordNet, Code Refactoring, Text, Discourse, etc.).\n\nPer Commitment 2: Worlds own input parsing, state construction, and operators.\nTasks own goal predicates and success criteria.",
      "classes": [],
      "functions": [],
      "imports": [
        "core.value.target_contract",
        "base",
        "code_refactoring",
        "discourse",
        "landmarks",
        "lemma_grammar",
        "meta_plan",
        "meta_plan_types",
        "pn",
        "text"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T13:37:41.810470",
        "modified": "2026-02-18T13:37:41.810778",
        "modified_days_ago": 2,
        "lines": 104,
        "size_bytes": 2608,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/base.py",
      "name": "base.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"The Sterling WorldAdapter Protocol defining required interfaces for world implementations. Provides discriminative capabilities, allows world to own input, defines world state, and makes world actions. Does not provide mutual exclusion. ",
      "classes": [
        "WorldCapabilities",
        "ObservationIR",
        "DeltaObservationIR",
        "TestResultIR",
        "GoalSpec",
        "SearchPolicy",
        "WorldAdapter",
        "HypothesisCapability",
        "SterlingOptions",
        "SterlingRequest",
        "DeltaSinkHealthWitness",
        "SterlingDebugInfo",
        "SterlingResponse"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "time",
        "dataclasses",
        "typing",
        "core.canonicalization.semantic",
        "core.value.target_contract"
      ],
      "constants": [
        "DEFAULT_WORLD_CAPABILITIES",
        "WORDNET_WORLD_CAPABILITIES",
        "PN_WORLD_CAPABILITIES"
      ],
      "decorators_used": [
        "dataclass",
        "runtime_checkable"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T00:02:10.896229",
        "modified": "2026-02-15T00:02:10.896383",
        "modified_days_ago": 6,
        "lines": 910,
        "size_bytes": 34590,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/claim_ir.py",
      "name": "claim_ir.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "ClaimWorld v2: JSON-LD-flavored Claim IR over Truth KG.\n\nThis module defines a structured Intermediate Representation for claims\nusing JSON-LD patterns without requiring full RDF tooling. The design:\n\n1. ClaimIR - Normalized claim representation with subject, property, value\n2. FactIR - KG facts in JSON-LD shape for evidence comparison\n3.",
      "classes": [
        "ValueType",
        "TypedValue",
        "Polarity",
        "ClaimIR",
        "FactIR",
        "ComparisonResult",
        "ComparisonOutcome",
        "ComparisonRegistry",
        "Verdict",
        "VerdictResult"
      ],
      "functions": [
        "get_property_iri",
        "get_entity_type_iri",
        "compare_numeric_exact",
        "compare_numeric_range",
        "compare_boolean",
        "compare_string_normalized",
        "compare_entity_id",
        "compare_default",
        "verify_claim",
        "entity_to_jsonld"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "CLAIM_CONTEXT",
        "COMPARISON_REGISTRY"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T08:31:54.706328",
        "modified": "2026-01-22T07:53:46.506593",
        "modified_days_ago": 30,
        "lines": 1082,
        "size_bytes": 36470,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/claim_parser.py",
      "name": "claim_parser.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\n    \"description\": \"Pars\": \"structured\",\n    \"optional\": a\n    \"exactly one\" r eXtive\n    (optional) a\n    claim(s) A\n    rreturn\\m\n    eclass\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    r\"\"\"e stant 1.",
      "classes": [
        "PropertyPattern",
        "EntityMatch",
        "PropertyMatch",
        "ParseResult"
      ],
      "functions": [
        "detect_negation",
        "find_entities_in_claim",
        "infer_property",
        "_convert_value",
        "extract_numeric_value",
        "extract_entity_value",
        "parse_claim",
        "parse_role_claim",
        "parse_employment_claim",
        "parse_claim_text"
      ],
      "imports": [
        "__future__",
        "logging",
        "re",
        "dataclasses",
        "typing",
        "core.worlds.claim_ir"
      ],
      "constants": [
        "NEGATION_PATTERNS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T08:33:22.466017",
        "modified": "2026-01-22T07:53:46.506522",
        "modified_days_ago": 29,
        "lines": 786,
        "size_bytes": 24422,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/claim_verifier.py",
      "name": "claim_verifier.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"Provides unified ClaimIR-based claim verification pipeline: parse \u2192 extract entities \u2192 gather evidence \u2192 verify against KG to produce a Verdict.  \n",
      "classes": [
        "VerificationContext",
        "ClaimVerifier"
      ],
      "functions": [
        "score_evidence_v2",
        "_heuristic_score",
        "generate_explanation",
        "create_claim_verifier"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.worlds.claim_ir",
        "core.worlds.claim_parser"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-04T08:34:16.215491",
        "modified": "2026-01-22T07:53:46.506610",
        "modified_days_ago": 29,
        "lines": 510,
        "size_bytes": 16855,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/claims.py",
      "name": "claims.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Implements the WorldAdapter protocol for claim verification over the TruthKG, optionally bridging to external knowledge sources via ClaimWorldStatePayload. Provides claim and evidence state for ClaimOperatorKind and ClaimKG operators. Used by ClaimWorld to parse claims and evaluate goals.",
      "classes": [
        "ClaimWorldConfig",
        "ClaimWorldStatePayload",
        "ClaimOperatorKind",
        "ClaimKGWorldAdapter"
      ],
      "functions": [
        "create_claim_world"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.kg.schemas",
        "core.kg.types",
        "core.reasoning.state_graph"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-25T01:20:49.526949",
        "modified": "2026-01-25T01:20:49.528411",
        "modified_days_ago": 27,
        "lines": 1171,
        "size_bytes": 43057,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/code_refactoring.py",
      "name": "code_refactoring.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "4. 7. 6 Python\n 5. analysis\n 8.  in Python (pepseudocode. 3. Python\n 4. 8. 3 Python\n 5 9. 10 Python\n 6. analysis\n 7. 11\n 8. 9 Python\n 10. 9. Python\n 11\n 10. 6. Python\n 8. 7. 8. 8 Python\n 9. 7. analysis\n 8. 9. Python\n 10. analysis\n 11. 9. Python\n 12. Python\n 13. 9. 14.",
      "classes": [
        "SymbolInfo",
        "CodeBlock",
        "SymbolTableVisitor",
        "CodeRefactoringWorldAdapter"
      ],
      "functions": [
        "ast_to_syntax_layer",
        "ast_to_semantic_ir",
        "_has_symbol_reference",
        "_has_extractable_block",
        "_has_inlineable_variable",
        "code_to_utterance_state",
        "create_refactoring_world_state"
      ],
      "imports": [
        "__future__",
        "ast",
        "logging",
        "dataclasses",
        "typing",
        "core.labels.pseudocode_adapter",
        "core.operators.registry",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [
        "CODE_REFACTORING_PREDICATES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [
          {
            "line_number": 657,
            "content": "Implement code refactoring prediction verification",
            "file_path": "core/worlds/code_refactoring.py"
          }
        ],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 169,
            "content": "# TODO: Implement proper Python source tokenization",
            "file_path": "core/worlds/code_refactoring.py"
          },
          {
            "line_number": 217,
            "content": "# TODO: Implement proper AST-based syntax structure extraction",
            "file_path": "core/worlds/code_refactoring.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-24T00:17:09.356617",
        "modified": "2026-02-17T10:09:41.574473",
        "modified_days_ago": 3,
        "lines": 910,
        "size_bytes": 31706,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/delta_observation_helpers.py",
      "name": "delta_observation_helpers.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Helper functions for creating DeltaObservationIR from operator transitions.\n\nIntegration point for Phase 1.2: DeltaObservationIR creation from semantic edits.",
      "classes": [],
      "functions": [
        "create_delta_observations_from_edit_delta",
        "create_delta_observation_from_semantic_edit"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T15:51:43.584649",
        "modified": "2026-02-21T15:51:43.584759",
        "modified_days_ago": 0,
        "lines": 137,
        "size_bytes": 5001,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/discourse.py",
      "name": "discourse.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"DiscourseWorld: Intent becomes OperatorSelection. Operon the bridge; maps raw to typed GoalSpec\n    execution: 's' only if the a  Plan\n    execution; Proven, 'any' strategy\n    Refinement. Spec module\n    This: selects GoalRef architecture for the user's task\n    high-level v. validation\n    Should transitive steps\n    verifiable global invariant\n    goals. E etc.",
      "classes": [
        "GoalType",
        "BindingStatus",
        "EntityBinding",
        "SuccessCriteria",
        "GoalSpec",
        "WorldEntry",
        "DiscourseContext",
        "DiscourseWorldAdapter"
      ],
      "functions": [
        "_canon_precond",
        "apply_select_goal_type",
        "apply_bind_entities",
        "apply_set_success_criteria",
        "apply_clarify",
        "apply_elaborate",
        "apply_propose_plan"
      ],
      "imports": [
        "__future__",
        "copy",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.operators.preconditions",
        "core.operators.registry",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [
        "SELECT_GOAL_TYPE",
        "BIND_ENTITIES",
        "SET_SUCCESS_CRITERIA",
        "CLARIFY",
        "ELABORATE",
        "PROPOSE_PLAN",
        "DISCOURSE_WORLD_OPERATORS",
        "DISCOURSE_OPERATOR_SIGNATURES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 701,
            "content": "# TODO: Remove this after all code migrates to discourse_state field",
            "file_path": "core/worlds/discourse.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.414590",
        "modified": "2026-01-26T06:12:48.414754",
        "modified_days_ago": 25,
        "lines": 1298,
        "size_bytes": 45787,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/discourse/__init__.py",
      "name": "__init__.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "DiscourseWorld: Intent as Operator Selection.\n\nModularized discourse package.",
      "classes": [],
      "functions": [],
      "imports": [
        "operators",
        "types",
        "world"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:40:36.013723",
        "modified": "2026-02-15T12:40:36.013962",
        "modified_days_ago": 5,
        "lines": 67,
        "size_bytes": 1407,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/discourse/operators.py",
      "name": "operators.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "provides apply_select_goal_type, apply_bind_entities, apply_set_success_criteria.",
      "classes": [],
      "functions": [
        "_canon_precond",
        "apply_select_goal_type",
        "apply_bind_entities",
        "apply_set_success_criteria",
        "apply_clarify",
        "apply_elaborate",
        "apply_propose_plan",
        "apply_infer_intent",
        "apply_resolve_reference",
        "apply_detect_tone"
      ],
      "imports": [
        "__future__",
        "copy",
        "logging",
        "typing",
        "core.operators.preconditions",
        "core.operators.registry",
        "core.operators.registry_types",
        "core.state_model",
        "types",
        "core.worlds.discourse.types"
      ],
      "constants": [
        "SELECT_GOAL_TYPE",
        "BIND_ENTITIES",
        "SET_SUCCESS_CRITERIA",
        "CLARIFY",
        "ELABORATE",
        "PROPOSE_PLAN",
        "INFER_INTENT",
        "RESOLVE_REFERENCE",
        "DETECT_TONE",
        "DISCOURSE_WORLD_OPERATORS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:40:08.424479",
        "modified": "2026-02-15T12:40:08.424624",
        "modified_days_ago": 6,
        "lines": 635,
        "size_bytes": 19342,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/discourse/types.py",
      "name": "types.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "GoalSpec models domain-agnostic user intentions, requiring all entities to be bound or marked unknown, and validating goal specifications with optional success criteria and confidence scores.",
      "classes": [
        "GoalType",
        "BindingStatus",
        "EntityBinding",
        "SuccessCriteria",
        "GoalSpec",
        "WorldEntry",
        "DiscourseContext"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [
        "VALID_SPEECH_ACTS",
        "VALID_TONES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T12:39:58.305695",
        "modified": "2026-02-15T12:39:58.305780",
        "modified_days_ago": 5,
        "lines": 187,
        "size_bytes": 5960,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/discourse/world.py",
      "name": "world.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "DiscourseWorldAdapter transforms utterances and context into GoalSpecs for discourse-level reasoning, enforcing entity binding and confidence thresholds in plans.",
      "classes": [
        "DiscourseWorldAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "typing",
        "core.state_model",
        "core.worlds.base",
        "operators",
        "types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 131,
            "content": "# TODO: Remove this after all code migrates to discourse_state field",
            "file_path": "core/worlds/discourse/world.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-26T06:12:48.415285",
        "modified": "2026-01-26T06:12:48.415413",
        "modified_days_ago": 25,
        "lines": 694,
        "size_bytes": 27583,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/landmarks.py",
      "name": "landmarks.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"sterling\": \"Inference\", \"exactly only (Abstract) \"Compute\"  (move to  concrete \"interpret\"  \"options\"  (create, interpret as \"sign\"  \"construct\"  \"exemplify\"  \"implement\"  \"analyze\", \"speculate\"  \"generate\"  (prelude) \"invariant\"  \"interpret\"  \"semantics\"  (theor  \"concept\"  \"realize\"  \"model\"  \"semantics\"  (the  \"semantic\"  and \"find\" \"meaning\" \n \"semantic\"  \"implement\"  \"design\"  (policies) \"concept\"  \"model\"  \"sign\"  (interpret  \"spec\"  \"sign\"  \"significance\"  \"semantics\"  \"realize\"  \"model",
      "classes": [
        "LandmarkID",
        "LandmarkPreconditionType",
        "LandmarkEffectType",
        "LandmarkPrecondition",
        "LandmarkEffect",
        "LandmarkSignature",
        "ProvenanceInfo",
        "LandmarkState",
        "LandmarkRealization",
        "LandmarkWorldAdapter",
        "BridgeCapable"
      ],
      "functions": [
        "apply_landmark_select",
        "apply_bridge_entry",
        "apply_bridge_exit"
      ],
      "imports": [
        "__future__",
        "copy",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.operators.registry",
        "core.state_model"
      ],
      "constants": [
        "GENERALIZE_SIG",
        "SPECIALIZE_SIG",
        "DECOMPOSE_SIG",
        "COMPOSE_SIG",
        "RENAME_SIG",
        "DISAMBIGUATE_SIG",
        "VERIFY_SIG",
        "RETRIEVE_SIG",
        "CANONICALIZE_SIG",
        "LANDMARK_SELECT"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 1022,
            "content": "# TODO: [Implement LandmarkState to StateNode projection for cross-domain bridges]",
            "file_path": "core/worlds/landmarks.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-13T10:08:24.907698",
        "modified": "2026-01-23T19:28:54.192617",
        "modified_days_ago": 28,
        "lines": 1120,
        "size_bytes": 36798,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/__init__.py",
      "name": "__init__.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Lemma-grammar domain: semantic bead model, realization engine, and validation gates.\n\nPublic API re-exports for ``core.worlds.lemma_grammar``.",
      "classes": [],
      "functions": [],
      "imports": [
        "gates",
        "kernel",
        "morphology",
        "realization",
        "types",
        "world"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.091619",
        "modified": "2026-02-20T08:48:06.091927",
        "modified_days_ago": 0,
        "lines": 82,
        "size_bytes": 1769,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/gates.py",
      "name": "gates.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"type\": \"module\", \"gates\": [\"stability\"], \"gates\": [\"coverage\"] \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n\" \n",
      "classes": [
        "StabilityWitness",
        "CoverageWitness",
        "LeakageWitness",
        "RefusalWitness",
        "GateResults"
      ],
      "functions": [
        "_step_to_capsule",
        "_plan_to_trace",
        "_ir_to_obligation_ids",
        "check_stability",
        "check_coverage",
        "check_leakage",
        "check_refusal"
      ],
      "imports": [
        "__future__",
        "dataclasses",
        "typing",
        "core.capsules.p01.extensions.obligation_realization",
        "core.capsules.p01.gates",
        "core.capsules.p01.trace_types",
        "realization",
        "types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T20:34:13.634807",
        "modified": "2026-02-18T20:34:13.634945",
        "modified_days_ago": 2,
        "lines": 417,
        "size_bytes": 13217,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/kernel.py",
      "name": "kernel.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "LemmaGrammarKernel provides a minimal deterministic kernel for lemma-grammar realization. It uses the LEMMA_REALIZE_AND_VERIFY operator to process input and complete the episode.",
      "classes": [
        "LemmaGrammarKernel"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "core.kernels.protocol",
        "core.state_model",
        "core.verification.hash_utils"
      ],
      "constants": [
        "OPERATOR_ID"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T12:56:08.287391",
        "modified": "2026-02-18T12:56:08.287545",
        "modified_days_ago": 2,
        "lines": 215,
        "size_bytes": 6978,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/morphology.py",
      "name": "morphology.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Provides morphology normalization for lemma derivation. _simple_lemmatize during extraction; _derive_lemma during witness generation. Rules must be consistent across both functions to prevent drift.",
      "classes": [],
      "functions": [
        "_simple_lemmatize",
        "_derive_lemma"
      ],
      "imports": [
        "__future__"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-19T18:46:49.816521",
        "modified": "2026-02-19T18:46:49.816934",
        "modified_days_ago": 1,
        "lines": 150,
        "size_bytes": 5510,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/realization.py",
      "name": "realization.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"Surface realization implemented as planning; complex operator execution. Each step's output is a state after each plan. Only when all beads used for one token.  #  token type is str, not in is sequence\n #  token and  # a  # 2.  # 1.  # syntax.  # 4.  # 5.  # 3.  # 6.  # 4.  # syntax within 5.  # 2.  # 1.  # 5.  # 3.  # 2\n  # 1.  # 5.  # 4.  # 3.  # 2\n    # 6\n    execution: 5,  # 4, 4.  # 3\n    # 2\n    #",
      "classes": [
        "PreconditionCheck",
        "RealizedSpan",
        "RealizationStep",
        "RenderState",
        "RealizationPlanIR"
      ],
      "functions": [
        "_step_to_dict",
        "_pluralize",
        "_verb_3sg",
        "_copula_for_number",
        "_do_support_for_number",
        "_get_determiner",
        "_infer_number",
        "_check_leakage",
        "_op_select_template",
        "_op_build_subject_np"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "dataclasses",
        "typing",
        "morphology",
        "types"
      ],
      "constants": [
        "_IRREGULAR_PLURALS",
        "_SURFACE_CASING",
        "_IRREGULAR_VERB_3SG",
        "_SUBGOAL_TO_OPERATOR"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T11:34:43.637718",
        "modified": "2026-02-18T11:34:43.638219",
        "modified_days_ago": 2,
        "lines": 1273,
        "size_bytes": 46958,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/types.py",
      "name": "types.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\": \"Loads synset snapshot and computes semantic beads (pos, syntactic  or the be they\n  value: a frozen set(\u201cpos\u201d/required (like \u201cset\u201d/optional, from lemmers synset\nReturn jumps rule 10 tenses, 3 in inference. 4\n        rule postulates, case in\n    to get_lemmas and their\n    semants preon text in\n    your\n    semantic and lexemes form\n    only. deri, e.g as text\n    semantic version\n    only model.",
      "classes": [
        "LemmaAtom",
        "RealizationPolicyIR",
        "LemmaSemanticIR"
      ],
      "functions": [
        "load_synset_snapshot",
        "lookup_synset",
        "load_as_lexicon_snapshot",
        "_normalize_label",
        "_infer_pos",
        "build_lemma_ir"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "pathlib",
        "typing",
        "core.verification.hash_utils",
        "morphology"
      ],
      "constants": [
        "_POS_MAP",
        "_COPULAS",
        "_MODALS",
        "_DETERMINERS",
        "_NEGATION",
        "_AUXILIARIES",
        "_SKIP_PUNCT",
        "_LABEL_ALIASES",
        "POLARITY_MAP",
        "PN_TYPE_MAP"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-20T08:48:06.092035",
        "modified": "2026-02-20T08:48:06.092227",
        "modified_days_ago": 0,
        "lines": 485,
        "size_bytes": 16591,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "worlds/lemma_grammar/world.py",
      "name": "world.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"Deterministic lemma-grammar based realization (``lemmas``) it (``grammars``) a deterministic operator within ``grammars`` to interpret the ``text`` to execute raw operators.  Only ``grammars`` may  ``apply`` with ``deterministic`` results.",
      "classes": [
        "LemmaGrammarConfig",
        "LemmaGrammarWorldAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.linguistics.intake.pipeline",
        "core.linguistics.intake.policy_fingerprint",
        "core.operators.registry_store",
        "core.operators.registry_types"
      ],
      "constants": [
        "LEMMA_REALIZE_AND_VERIFY",
        "LEMMA_GRAMMAR_CAPABILITIES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T13:15:10.489886",
        "modified": "2026-02-18T13:15:10.490238",
        "modified_days_ago": 2,
        "lines": 442,
        "size_bytes": 15578,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/mastermind.py",
      "name": "mastermind.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"MastermindWorldAdapter implements the WorldAdapter protocol for Mastermind (code-breaking) with partial observability. All Mastermind logic delegated to kernel. No changes to base. Capabilities exposed via _registry (optional).",
      "classes": [
        "MastermindWorldConfig",
        "MastermindWorldAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "uuid",
        "dataclasses",
        "typing",
        "core.kernels.mastermind",
        "core.operators.registry_store",
        "core.operators.registry_types",
        "core.worlds.base"
      ],
      "constants": [
        "MASTERMIND_WORLD_CAPABILITIES",
        "MASTERMIND_APPLY_GUESS_SIGNATURE",
        "MASTERMIND_OPERATOR_SIGNATURES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-08T02:30:45.954611",
        "modified": "2026-02-08T02:30:45.954766",
        "modified_days_ago": 12,
        "lines": 281,
        "size_bytes": 9486,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/meta_plan.py",
      "name": "meta_plan.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Implements WorldAdapter protocol for plan-space reasoning in Sterling's meta-control. Maps domains via domain adapters and capability/evidence ledgers. Phase 1 executes linearly with capability-gated domain selection and typed FAIL_CLOSED.",
      "classes": [
        "MetaPlanWorldAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.state_model",
        "core.worlds.base",
        "core.worlds.meta_plan_operators",
        "core.worlds.meta_plan_types"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:41:29.919895",
        "modified": "2026-02-18T17:41:29.920152",
        "modified_days_ago": 2,
        "lines": 177,
        "size_bytes": 5898,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/meta_plan_operators.py",
      "name": "meta_plan_operators.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "MetaPlan operators are registered by C-Category and World-Scope in the operator registry. Pivot 3: Precondition IDs are string references. Pivot 4: EXECUTE_STEP passes only immutable data to domain adapters. Pivot 5: Observations are timestamped and sorted. Pivot 7: FAIL_CLOSED on a step's bundle references verified against ledger entries.",
      "classes": [],
      "functions": [
        "_has_meta_plan_state",
        "_has_plan",
        "_has_ready_step",
        "_step_executing",
        "_domain_selected",
        "_has_domain_observation",
        "_has_postcondition_pass",
        "_is_fail_closed",
        "_has_blocked_or_stale",
        "_has_alternative_domain"
      ],
      "imports": [
        "__future__",
        "copy",
        "hashlib",
        "json",
        "logging",
        "uuid",
        "typing",
        "core.operators.registry_types",
        "core.worlds.base",
        "core.worlds.meta_plan_types"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T19:08:49.369060",
        "modified": "2026-02-18T19:08:49.369241",
        "modified_days_ago": 2,
        "lines": 1513,
        "size_bytes": 55368,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/meta_plan_types.py",
      "name": "meta_plan_types.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"type\": \"PlanGraphV1\", \"steps\": [{\"id\": \"str\", \"precondition\": \"PlanStatus\", \"code\": \"text\", \"evidence\" pattern in text. \"Plan node\", \"pattern\" _context\": {\"plan_id\": \"string\", \"evidence\": [] , \"precondition\": \"PlanGraph node\", \"evidence\" pattern  for _text. \"Observation\" of node class, a \"string\" (key)",
      "classes": [
        "PlanStepStatus",
        "BlockReason",
        "EvidenceType",
        "PlanStepBudget",
        "PlanStepV1",
        "PlanGraphV1",
        "CapabilityClaimSummary",
        "DomainSessionSummary",
        "ActiveCapabilitySnapshot",
        "EvidenceLedgerEntry",
        "EvidenceLedger",
        "MetaPlanWorldState",
        "FailClosedBundle",
        "PlanConstructionError"
      ],
      "functions": [
        "build_plan_steps_from_raw"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "enum",
        "typing"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T17:52:06.022125",
        "modified": "2026-02-18T17:52:06.022279",
        "modified_days_ago": 2,
        "lines": 584,
        "size_bytes": 19679,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/__init__.py",
      "name": "__init__.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Module implementation.",
      "classes": [],
      "functions": [],
      "imports": [],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.974272",
        "modified": "2026-02-21T23:57:28.974272",
        "modified_days_ago": 1,
        "lines": 0,
        "size_bytes": 0,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/effects.py",
      "name": "effects.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Validates state changes for MTA operators. Basic sanity check for effect assertions.",
      "classes": [],
      "functions": [
        "stage_mutated",
        "register_mta_effects"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [
        "MTA_EFFECT_ASSERTIONS"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.974759",
        "modified": "2026-02-21T23:57:28.974850",
        "modified_days_ago": 0,
        "lines": 48,
        "size_bytes": 1485,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/errors.py",
      "name": "errors.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "MTA integration error hierarchy. Separates from portable capsule errors in core.linguistics.mta. MTAError, MTAVocabularyError, and MTAInapplicableError classes for Sterling integration-specific error handling.",
      "classes": [
        "MTAError",
        "MTAVocabularyError",
        "MTAInapplicableError"
      ],
      "functions": [],
      "imports": [
        "__future__"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.974880",
        "modified": "2026-02-21T23:57:28.974959",
        "modified_days_ago": 0,
        "lines": 33,
        "size_bytes": 951,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/kernel.py",
      "name": "kernel.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\": \"must-identified preconditions, pattern\n  for\n  candidate generation for\n  scope IDs. Strict\n  additive: preconditions, never\n  elimination. Fallback\n  is only a  deterministic\n  for  candidate\n  It  (strict) and\n  GCCL  hints.  try  and\n  hints are  for\n  deterministic  semantics\n  (all) is\n  deterministic\n  ordering.",
      "classes": [
        "GoalScopeIdMap",
        "MTAKernel"
      ],
      "functions": [
        "_extract_goal_scope_id_map",
        "_goal_constraints_digest",
        "_canonical_args_json",
        "_try_capsule_op"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "collections",
        "dataclasses",
        "typing",
        "core.contracts.semantic_edits",
        "core.kernels.protocol",
        "core.linguistics.mta.gccl",
        "core.linguistics.mta.hashing"
      ],
      "constants": [
        "_EMPTY_GOAL_MAP"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.974993",
        "modified": "2026-02-21T23:57:28.975111",
        "modified_days_ago": 0,
        "lines": 617,
        "size_bytes": 24153,
        "author": "itative",
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/operator_adapter.py",
      "name": "operator_adapter.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\": \"Wrap MTA capsule operators in execution contract. 6. It provides diagnostic of rejection reasons.  Returns [] on operator failure\n    with side effects. Does not allow(og) as input to operator\n    RejectionCounter side-channel provides\ndiagnostics.  Does not affect search results.  Is state = search() as model\n    (no) Rejection in\n    execution\n    stage:  runs in-check, 1.  allow(only\n    inputs.  record()",
      "classes": [
        "RejectionCounter"
      ],
      "functions": [
        "_resolve_args",
        "make_mta_operator_impl",
        "make_all_mta_operator_impls"
      ],
      "imports": [
        "__future__",
        "json",
        "collections",
        "copy",
        "threading",
        "typing",
        "core.linguistics.mta.hashing",
        "core.linguistics.mta.operators",
        "core.linguistics.mta.replay",
        "core.worlds.mta.signatures"
      ],
      "constants": [
        "REJECTION_COUNTER"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.975174",
        "modified": "2026-02-21T23:57:28.975291",
        "modified_days_ago": 0,
        "lines": 191,
        "size_bytes": 6900,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/preconditions.py",
      "name": "preconditions.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Enforces minimal state gates for MTA operators without argument checks. Legality is enforced in kernel.get_neighbors() and operator adapter backstop.",
      "classes": [],
      "functions": [
        "has_stage_state",
        "has_mta_vocab"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [
        "MTA_PRECONDITION_PREDICATES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.975325",
        "modified": "2026-02-21T23:57:28.975399",
        "modified_days_ago": 0,
        "lines": 30,
        "size_bytes": 912,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/registry.py",
      "name": "registry.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "MTA runs use a strict, closed vocabulary with predeclared tokens. Unknown tokens trigger fail-closed errors. Registry builds a deterministic digest from domain vocabulary.",
      "classes": [
        "MTAVocabularyRegistry"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "hashlib",
        "json",
        "dataclasses",
        "typing",
        "core.worlds.mta.errors"
      ],
      "constants": [
        "_VALID_TOKEN_KINDS"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.975433",
        "modified": "2026-02-21T23:57:28.975559",
        "modified_days_ago": 0,
        "lines": 213,
        "size_bytes": 8025,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/signatures.py",
      "name": "signatures.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Defines signatures for 10 MTA operators (all WORLD scope, arg-free preconditions). MTA_ prefix avoids PN operator collisions.",
      "classes": [],
      "functions": [],
      "imports": [
        "__future__",
        "core.operators.registry_types"
      ],
      "constants": [
        "MTA_OPERATOR_SIGNATURES"
      ],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.975590",
        "modified": "2026-02-21T23:57:28.975698",
        "modified_days_ago": 0,
        "lines": 185,
        "size_bytes": 6724,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/mta/world.py",
      "name": "world.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "MTAWorldAdapter integrates Sterling's semantic stage algebra into WorldAdapter protocol handling. It parses structured input, builds world states, and operator implementations for MTA reasoning.",
      "classes": [
        "MTAWorldAdapter"
      ],
      "functions": [],
      "imports": [
        "__future__",
        "typing",
        "core.worlds.base",
        "core.worlds.mta.kernel",
        "core.worlds.mta.operator_adapter",
        "core.worlds.mta.signatures"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-21T23:57:28.975728",
        "modified": "2026-02-21T23:57:28.975812",
        "modified_days_ago": 0,
        "lines": 104,
        "size_bytes": 3551,
        "author": null,
        "has_main": false
      }
    },
    {
      "path": "worlds/pn.py",
      "name": "pn.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"Placeholder parsing: implements (apply operators from language modeling\n  syntax for direct expansion. 1.0 grammar\n 1.0 (sentence) -> (structs)\n 2.0 semantic checks, context-dependent\n 3.0 semantic methods\n    for each 1.0 (semantics)\n    (semantics, operators\n 4.0 semantic checks\n    (syntactic forms\n    verif 0.0 (semantic\n    and prarules\n    for specific\n    semants\n    (semantic function\n 5.",
      "classes": [
        "PnWorldAdapter"
      ],
      "functions": [
        "pn_ir_to_utterance_state",
        "utterance_state_to_pn_ir"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.pn.linguistics",
        "core.operators.registry",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 119,
            "content": "# TODO: Integrate spaCy or similar NLP parser for PN syntax",
            "file_path": "core/worlds/pn.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-01-16T08:29:40.361589",
        "modified": "2026-02-17T10:09:41.459342",
        "modified_days_ago": 3,
        "lines": 985,
        "size_bytes": 36841,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/pseudocode.py",
      "name": "pseudocode.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"type\": dataclasses for each node, simple Python class for each node; generate signoffspring for each node\n    \"\"\"\"  (python, \"\"\"\"  (\"\" (structured\n    (Python, \"\"  ( syntax (\"\"  structure\n\"\"  (\"\"  ( syntax (\"\"  (simple)\n\"\"  (structural analysis)\n\"\"  \"\"  (syntax)\"\"  (structural)\n  \"\"  ( semantic) and\n\"\"  (semantic) and\n  analysis for \"\"  (semantic) and  structure\n\"\"  ( syntax (common)\n\"\"  analysis\n\"\"  ( syntax (rational) analysis ( syntax  (rational) and effect,  \"\"  (\"\"  (python)\n\"\" ...",
      "classes": [
        "LanguageHint",
        "SymbolInfo",
        "PseudocodeWorldAdapter"
      ],
      "functions": [
        "build_symbol_table",
        "pseudocode_to_syntax_layer",
        "pseudocode_to_semantic_ir",
        "_has_foreach",
        "_has_contiguous_block",
        "_has_inlineable_call",
        "_has_nested_if"
      ],
      "imports": [
        "__future__",
        "ast",
        "logging",
        "dataclasses",
        "enum",
        "typing",
        "core.operators.registry",
        "core.pseudocode.ir",
        "core.pseudocode.lowering.python",
        "core.pseudocode.semantics"
      ],
      "constants": [
        "PSEUDOCODE_PREDICATES"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": [
          {
            "line_number": 677,
            "content": "# TODO: Implement pseudocode operator preconditions",
            "file_path": "core/worlds/pseudocode.py"
          }
        ]
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-02T18:49:25.740249",
        "modified": "2026-01-22T07:53:46.506712",
        "modified_days_ago": 29,
        "lines": 750,
        "size_bytes": 23483,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/rome_kg.py",
      "name": "rome_kg.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "{\"description\":\"Rome as input jones\n    1. (Rome (pep_1 objects\n    \"\"\" (h) \n    class_1. (h) \n    \"\"\" (h) \n    graph methods\n    \"\"\" \n    return hapham_1\n    graph methods\n    \"\"\" \n    (graph methods\n    \"\"\" (optional res_1\n    \"\"\" \n    (optional-oracle states.",
      "classes": [
        "RomeRegime",
        "RomeNode",
        "RomeEdge",
        "RomeKG",
        "RomeKGConfig",
        "RomeKGGenerator"
      ],
      "functions": [
        "sample_start_node",
        "sample_navigation_task"
      ],
      "imports": [
        "__future__",
        "hashlib",
        "random",
        "collections",
        "dataclasses",
        "enum",
        "typing",
        "core.safeguards.semantic_labels"
      ],
      "constants": [
        "DEFAULT_CORRIDOR_CONFIG",
        "DEFAULT_HUB_CONFIG"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T04:36:20.513834",
        "modified": "2026-02-15T04:36:20.514199",
        "modified_days_ago": 5,
        "lines": 775,
        "size_bytes": 24647,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/state_transition.py",
      "name": "state_transition.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Provides serialization utilities for filtering, dumping, and hashing StateNode assumptions for world adapters. Does not include transition logic; each world's semantics must be implemented separately.",
      "classes": [],
      "functions": [
        "filtered_assumptions",
        "debug_dump_assumptions"
      ],
      "imports": [
        "__future__",
        "typing"
      ],
      "constants": [],
      "decorators_used": [],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-18T19:08:49.369290",
        "modified": "2026-02-18T19:08:49.369397",
        "modified_days_ago": 2,
        "lines": 56,
        "size_bytes": 2104,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/text.py",
      "name": "text.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Validates features using the MRC (me) for Validates the model chain for MRC Builds the semantic state using language",
      "classes": [
        "TextWorldAdapter"
      ],
      "functions": [
        "text_ir_to_utterance_state",
        "utterance_state_to_text_ir",
        "text_to_state_node"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "typing",
        "core.operators.registry",
        "core.state_model",
        "core.state_model",
        "core.worlds.base",
        "core.text.ir",
        "core.text.parser"
      ],
      "constants": [],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2026-02-15T17:34:54.873777",
        "modified": "2026-02-15T17:34:54.874060",
        "modified_days_ago": 5,
        "lines": 1156,
        "size_bytes": 40339,
        "author": "@darianrosebrook",
        "has_main": false
      }
    },
    {
      "path": "worlds/wordnet.py",
      "name": "wordnet.py",
      "category": "World adapters (WordNet, Claims, Discourse, Code, etc.)",
      "status": "active",
      "description": "Sterling WordNet World Adapter.\n\nImplements the WorldAdapter protocol for WordNet knowledge graph navigation.\nWraps the existing WordNet KG and provides typed state construction.\n\nPer Commitment 2: This world owns input parsing, state construction, and operators.\nTasks (navigation, similarity) own goal predicates and success criteria.",
      "classes": [
        "WordNetWorldAdapter"
      ],
      "functions": [
        "wordnet_node_to_world_state",
        "create_navigation_world_state"
      ],
      "imports": [
        "__future__",
        "logging",
        "dataclasses",
        "pathlib",
        "typing",
        "core.kg.registry",
        "core.operators.registry",
        "core.state_model",
        "core.worlds.base"
      ],
      "constants": [
        "WORDNET_KG_DEFAULT_PATH",
        "WORDNET_KG_FALLBACK_PATH",
        "WORDNET_KG_SCHEMA_ID",
        "WORDNET_KG_SCHEMA_VERSION"
      ],
      "decorators_used": [
        "dataclass"
      ],
      "todos": {
        "P0-GOV": [],
        "P1-METRIC": [],
        "P2-QUAL": [],
        "P3-UX": [],
        "untagged": []
      },
      "staleness_level": "active",
      "staleness_score": 0.0,
      "staleness_indicators": [],
      "recommendation": "Active development - no action needed",
      "archive_candidate": false,
      "archive_reasons": [],
      "metadata": {
        "created": "2025-12-31T19:51:23.547233",
        "modified": "2026-02-17T10:09:41.571916",
        "modified_days_ago": 4,
        "lines": 898,
        "size_bytes": 32683,
        "author": "@darianrosebrook",
        "has_main": false
      }
    }
  ],
  "categories": {
    "Package initialization": [
      "__init__.py",
      "canonicalization/__init__.py",
      "capsules/__init__.py",
      "capsules/p01/__init__.py",
      "capsules/p01/extensions/__init__.py",
      "capsules/p06/__init__.py",
      "capsules/p22/__init__.py",
      "carrier/__init__.py",
      "carrier/schemas/__init__.py",
      "certification/__init__.py",
      "engine/__init__.py",
      "environment/__init__.py",
      "hashing/__init__.py",
      "lexicon/__init__.py",
      "optimization/__init__.py",
      "oracles/__init__.py",
      "oracles/code/__init__.py",
      "oracles/dialogue/__init__.py",
      "realization/__init__.py",
      "recursion/__init__.py",
      "safeguards/__init__.py",
      "verification/__init__.py"
    ],
    "K6 fence harness, proof runs, and certification testing": [
      "benchmarks/__init__.py",
      "benchmarks/conformance_gate.py",
      "benchmarks/distributional_gate.py",
      "benchmarks/episode_runner.py",
      "benchmarks/escapegame_fixtures.py",
      "benchmarks/evidence_collector.py",
      "benchmarks/evidence_kernel.py",
      "benchmarks/fence/__init__.py",
      "benchmarks/fence/allowed_set.py",
      "benchmarks/fence/baseline_loader.py",
      "benchmarks/fence/bundle_integrity.py",
      "benchmarks/fence/certified_operator_loader.py",
      "benchmarks/fence/cheating.py",
      "benchmarks/fence/efficiency_evidence.py",
      "benchmarks/fence/engine.py",
      "benchmarks/fence/fence_enforcement_suite.py",
      "benchmarks/fence/fence_utils.py",
      "benchmarks/fence/k6_executor.py",
      "benchmarks/fence/k6_performance.py",
      "benchmarks/fence/k6_runner.py",
      "benchmarks/fence/k6_safety_checks.py",
      "benchmarks/fence/k6_types.py",
      "benchmarks/fence/operator_selection.py",
      "benchmarks/fence/operator_synthesizer.py",
      "benchmarks/fence/policy_loader.py",
      "benchmarks/fence/proof_bundle.py",
      "benchmarks/fence/proof_report_generator.py",
      "benchmarks/fence/scenario.py",
      "benchmarks/fence/scenario_gate.py",
      "benchmarks/fence/scenario_qualification.py",
      "benchmarks/fence/selection_recorder.py",
      "benchmarks/fence/shadow_influence.py",
      "benchmarks/fence/test_certificate_creator.py",
      "benchmarks/fence/test_operator_for_config_c.py",
      "benchmarks/fence/trace_extractor.py",
      "benchmarks/fence/trace_validator.py",
      "benchmarks/harness_config.py",
      "benchmarks/pn_balanced_episodes.py",
      "benchmarks/policy_protocol.py",
      "benchmarks/robustness_gate.py",
      "benchmarks/rome_demo.py",
      "benchmarks/stochastic_witness.py"
    ],
    "Core module": [
      "canonicalization/errors.py",
      "canonicalization/hashes.py",
      "canonicalization/json.py",
      "canonicalization/semantic.py",
      "canonicalization/versioned_hash.py",
      "canonicalization/witness.py",
      "capsules/capsule_spec.py",
      "capsules/p01/extensions/obligation_realization.py",
      "capsules/p01/gates.py",
      "capsules/p01/spec.py",
      "capsules/p01/trace_types.py",
      "capsules/p01_spec.py",
      "capsules/p06/gates.py",
      "capsules/p06/search.py",
      "capsules/p06/trace_types.py",
      "capsules/p06_spec.py",
      "capsules/p22/adapters.py",
      "capsules/p22/canonical_json.py",
      "capsules/p22/capsule_spec.py",
      "capsules/p22/errors.py",
      "capsules/p22/operators_p22_intent.py",
      "capsules/p22/operators_p22a.py",
      "capsules/p22/operators_p22c.py",
      "capsules/p22/register_p22.py",
      "capsules/p22/types.py",
      "capsules/p25_lo_spec.py",
      "carrier/artifact_writer.py",
      "carrier/bytestate.py",
      "carrier/bytetrace.py",
      "carrier/code32.py",
      "carrier/collector.py",
      "carrier/compiler.py",
      "carrier/operator_codebook.py",
      "carrier/packed_frontier.py",
      "carrier/partitioner.py",
      "carrier/schemas/escapegame_schema.py",
      "carrier/schemas/mastermind_schema.py",
      "carrier/schemas/rome_schema.py",
      "carrier/schemas/wordnet_schema.py",
      "carrier/step_event.py",
      "carrier/telemetry.py",
      "certification/discriminative_episode_set.py",
      "diagnostics/goal_clause_coverage.py",
      "engine/context.py",
      "engine/core.py",
      "engine/registry.py",
      "engine/run_result.py",
      "environment/api.py",
      "environment/budget_spec.py",
      "environment/handles.py",
      "environment/query_spec.py",
      "environment/slice.py",
      "exceptions.py",
      "external_ref.py",
      "features.py",
      "features_grouped.py",
      "hashing/contracts.py",
      "id_registry.py",
      "ir_extraction.py",
      "ir_serialization.py",
      "lexicon/ref.py",
      "lexicon/results.py",
      "lexicon/snapshot.py",
      "logging_config.py",
      "operator_masking.py",
      "optimization/applicability_index.py",
      "optimization/cache.py",
      "optimization/hashing.py",
      "optimization/quantization.py",
      "oracles/code/integration.py",
      "oracles/code/legality.py",
      "oracles/code/mask.py",
      "oracles/code/oracle.py",
      "oracles/code/reranker.py",
      "oracles/common.py",
      "oracles/dataset_manifest.py",
      "oracles/decision_audit.py",
      "oracles/dialogue/features.py",
      "oracles/dialogue/integration.py",
      "oracles/dialogue/legality.py",
      "oracles/dialogue/mask.py",
      "oracles/dialogue/oracle.py",
      "oracles/dialogue/reranker.py",
      "oracles/legality_common.py",
      "oracles/provenance.py",
      "profiling.py",
      "realization/spec.py",
      "recursion/adapters.py",
      "recursion/budget.py",
      "recursion/enums.py",
      "recursion/hashing.py",
      "recursion/rc2_walk.py",
      "recursion/rc4_closure.py",
      "recursion/rc9_resolve.py",
      "recursion/store.py",
      "recursion/witness.py",
      "safeguards/certifying_boundary.py",
      "safeguards/invariance_tests.py",
      "safeguards/model_gateway.py",
      "safeguards/observation_schema.py",
      "safeguards/oracle_separation.py",
      "safeguards/placeholder_audit.py",
      "safeguards/semantic_labels.py",
      "safeguards/text_ir_invariance.py",
      "safeguards/world_quarantine.py",
      "search_health.py",
      "simple_kg.py",
      "state_model.py",
      "tasks.py",
      "verification/hash_utils.py"
    ],
    "Semantic contracts and invariants": [
      "contracts/__init__.py",
      "contracts/artifact_identity.py",
      "contracts/goal_signature.py",
      "contracts/governance_status.py",
      "contracts/invariant_fuzzer.py",
      "contracts/invariants.py",
      "contracts/operator_application.py",
      "contracts/schema_registry.py",
      "contracts/semantic_edits.py",
      "contracts/trace_bundle.py"
    ],
    "Dialogue and discourse processing": [
      "discourse/__init__.py",
      "discourse/dialogue.py",
      "discourse/intent_satisfaction.py",
      "discourse/operators.py",
      "discourse/phase_model.py",
      "discourse/state.py",
      "discourse/tasks.py"
    ],
    "Domain specifications and configuration": [
      "domains/__init__.py",
      "domains/action_surface.py",
      "domains/capability_claim_registry.py",
      "domains/capability_descriptor.py",
      "domains/capsule_spec.py",
      "domains/conformance_suite.py",
      "domains/cpg_gate.py",
      "domains/cpg_results.py",
      "domains/domain_handshake.py",
      "domains/domain_registry.py",
      "domains/domain_spec_v1.py",
      "domains/language_io_domain.py",
      "domains/p22/__init__.py",
      "domains/p22/capability_descriptors_v1.py",
      "domains/p22/primitive_spec_p22.py",
      "domains/primitive_registry.py",
      "domains/primitive_spec.py",
      "domains/promotion_proposal.py",
      "domains/registry_manifest.py"
    ],
    "Run intents, fail-closed gates, and audit infrastructure": [
      "governance/__init__.py",
      "governance/adapter_strict_guard.py",
      "governance/canonical_hash.py",
      "governance/execution_policy.py",
      "governance/failure_witness.py",
      "governance/gate_verdict.py",
      "governance/governance_context.py",
      "governance/legacy_deprecation.py",
      "governance/replay/__init__.py",
      "governance/replay/artifact_resolver.py",
      "governance/replay/structural_verifier.py",
      "governance/replay/verification_result.py",
      "governance/run_intent.py"
    ],
    "Operator learning, promotion pipeline, and hypothesis lifecycle": [
      "induction/__init__.py",
      "induction/abc_comparison.py",
      "induction/aging_policy.py",
      "induction/artifact_closure.py",
      "induction/artifact_store.py",
      "induction/baseline_mode.py",
      "induction/baseline_runner.py",
      "induction/batch_induction_helpers.py",
      "induction/certificate_builder.py",
      "induction/certificate_verifier.py",
      "induction/certificates.py",
      "induction/closure_allowlist.py",
      "induction/counting_prior_store.py",
      "induction/decision_policy.py",
      "induction/delta_clustering.py",
      "induction/delta_pack.py",
      "induction/derivation_run_manifest.py",
      "induction/determinism_witness.py",
      "induction/dialogue_rollout_scenario.py",
      "induction/e2e_certification_pipeline.py",
      "induction/episode_attestation.py",
      "induction/episode_commitment.py",
      "induction/episode_induction_input.py",
      "induction/episode_loader_helpers.py",
      "induction/episode_loader_induction.py",
      "induction/episode_manifest.py",
      "induction/episode_set.py",
      "induction/episode_split.py",
      "induction/evidence_weighting.py",
      "induction/file_artifact_store.py",
      "induction/fixture_manifest.py",
      "induction/gates/__init__.py",
      "induction/gates/efficiency_delta_gate.py",
      "induction/generalization_bar.py",
      "induction/goal_outcome_schema.py",
      "induction/golden_corpus_provider.py",
      "induction/golden_fixture_descriptor.py",
      "induction/hashing.py",
      "induction/heldout_manifest.py",
      "induction/hypothesis.py",
      "induction/hypothesis_build_failure.py",
      "induction/hypothesis_policy_translator.py",
      "induction/hypothesis_program.py",
      "induction/hypothesis_proposer.py",
      "induction/hypothesis_refiner.py",
      "induction/hypothesis_scoring.py",
      "induction/hypothesis_selection.py",
      "induction/hypothesis_state.py",
      "induction/induction_readiness_tripwires.py",
      "induction/induction_session.py",
      "induction/invariance_checker.py",
      "induction/k1_evaluation_ir.py",
      "induction/k1_metrics.py",
      "induction/k1_substrate_extractor.py",
      "induction/k1_test_substrate.py",
      "induction/lifecycle_controller.py",
      "induction/minimal_test_adapter.py",
      "induction/ms_artifact_store.py",
      "induction/nontriviality_gates.py",
      "induction/operator_sketch.py",
      "induction/operator_synthesizer.py",
      "induction/orchestrator.py",
      "induction/outcome_witness.py",
      "induction/overlay_registry.py",
      "induction/pn_rollout_scenario.py",
      "induction/pn_semantic_metrics.py",
      "induction/policy_ir.py",
      "induction/policy_scope.py",
      "induction/policy_snapshot.py",
      "induction/policy_to_prior.py",
      "induction/policy_weights_artifact.py",
      "induction/prediction_spec_registry.py",
      "induction/prediction_specs/__init__.py",
      "induction/prediction_specs/pn_operator_pattern.py",
      "induction/prediction_specs/wordnet_operator_pattern.py",
      "induction/prior_artifact_envelope.py",
      "induction/prior_derivation.py",
      "induction/prior_index.py",
      "induction/prior_influence_gate.py",
      "induction/prior_ir.py",
      "induction/prior_key_types.py",
      "induction/prior_store.py",
      "induction/prior_store_errors.py",
      "induction/prior_training_loop.py",
      "induction/prior_verifier.py",
      "induction/program_canonicalization.py",
      "induction/promotion_blocker.py",
      "induction/promotion_decision.py",
      "induction/promotion_gate.py",
      "induction/promotion_lane.py",
      "induction/promotion_lane_events.py",
      "induction/proposer/__init__.py",
      "induction/proposer/base.py",
      "induction/proposer/budget.py",
      "induction/proposer/manager.py",
      "induction/proposer/strategies/delta_generalization.py",
      "induction/proposer/strategies/entity_relation.py",
      "induction/proposer/strategies/operator_induction.py",
      "induction/proposer/strategies/operator_sequence.py",
      "induction/proposer/strategies/semantic_delta.py",
      "induction/reason_emitter.py",
      "induction/sandbox_report.py",
      "induction/sandbox_run_manifest.py",
      "induction/sandbox_runner.py",
      "induction/sandbox_store.py",
      "induction/scenario_suite.py",
      "induction/scoped_k1_comparison.py",
      "induction/scorecard_computation.py",
      "induction/semantic_delta_observation_bridge.py",
      "induction/session_scoring.py",
      "induction/signature_separation.py",
      "induction/sketch_compiler.py",
      "induction/stage_k_report.py",
      "induction/state_snapshot.py",
      "induction/synthesis_config.py",
      "induction/synthesis_replay_check.py",
      "induction/tc2_validator.py",
      "induction/tier_gate_reason.py",
      "induction/validation_fixtures.py",
      "induction/wordnet_rollout_scenario.py"
    ],
    "Intent classification and prediction": [
      "intent/__init__.py",
      "intent/classifier.py",
      "intent/model.py",
      "intent/predictor.py",
      "intent/refinement.py",
      "intent/types.py",
      "intent/value_head.py"
    ],
    "Intermediate representations (semantic, syntax, delta)": [
      "ir/__init__.py",
      "ir/cube_delta_ops.py",
      "ir/escape_delta_ops.py",
      "ir/semantic_delta_apply.py",
      "ir/semantic_delta_ir.py"
    ],
    "Domain-specific reasoning kernels": [
      "kernels/__init__.py",
      "kernels/discourse.py",
      "kernels/generic.py",
      "kernels/gridworld.py",
      "kernels/kv_store.py",
      "kernels/mastermind.py",
      "kernels/pn.py",
      "kernels/poisoned_curriculum.py",
      "kernels/protocol.py",
      "kernels/wordnet.py"
    ],
    "Knowledge graph integration and registry": [
      "kg/__init__.py",
      "kg/exceptions.py",
      "kg/registry.py",
      "kg/schemas.py",
      "kg/types.py"
    ],
    "Label spaces and adapters": [
      "labels/__init__.py",
      "labels/claim_adapter.py",
      "labels/jsonld_integration.py",
      "labels/landmarks.py",
      "labels/pseudocode_adapter.py",
      "labels/registry.py",
      "labels/text_adapter.py",
      "labels/types.py",
      "labels/wordnet_mapping.py"
    ],
    "Linguistic processing operators": [
      "linguistics/__init__.py",
      "linguistics/contracts.py",
      "linguistics/expand_by_digest_v1.py",
      "linguistics/holes_policy.py",
      "linguistics/intake/__init__.py",
      "linguistics/intake/pipeline.py",
      "linguistics/intake/policy_fingerprint.py",
      "linguistics/io_envelope_v1.py",
      "linguistics/ir_v0/__init__.py",
      "linguistics/ir_v0/budget.py",
      "linguistics/ir_v0/container.py",
      "linguistics/ir_v0/context_ref.py",
      "linguistics/ir_v0/episode_trace.py",
      "linguistics/ir_v0/frontier.py",
      "linguistics/ir_v0/meaning_state.py",
      "linguistics/ir_v0/myelin_sheath.py",
      "linguistics/ir_v0/patch_v0.py",
      "linguistics/ir_v0/pin_set.py",
      "linguistics/ir_v0/retention.py",
      "linguistics/ir_v0/types.py",
      "linguistics/ir_v0/witness_v0.py",
      "linguistics/mta/__init__.py",
      "linguistics/mta/canonical.py",
      "linguistics/mta/edit_log.py",
      "linguistics/mta/gccl.py",
      "linguistics/mta/hashing.py",
      "linguistics/mta/operators.py",
      "linguistics/mta/replay.py",
      "linguistics/mta/stage_state.py",
      "linguistics/mta/verifier.py",
      "linguistics/operators.py",
      "linguistics/operators/__init__.py",
      "linguistics/operators/base.py",
      "linguistics/operators/registry.py",
      "linguistics/operators/v0/__init__.py",
      "linguistics/operators/v0/apply_sheath.py",
      "linguistics/operators/v0/attach_modality.py",
      "linguistics/operators/v0/attach_negation.py",
      "linguistics/operators/v0/compact_to_summary.py",
      "linguistics/operators/v0/evict_ws.py",
      "linguistics/operators/v0/make_entity_ref.py",
      "linguistics/operators/v0/make_mention.py",
      "linguistics/operators/v0/make_predicate.py",
      "linguistics/operators/v0/make_proposition.py",
      "linguistics/operators/v0/promote_coref_merge.py",
      "linguistics/operators/v0/promote_discourse_link.py",
      "linguistics/operators/v0/promote_to_sheath.py",
      "linguistics/operators/v0/propose_coref.py",
      "linguistics/operators/v0/propose_discourse_link.py",
      "linguistics/operators/v0/rehydrate_shadow.py",
      "linguistics/operators/v0/scope_attach_common.py",
      "linguistics/operators/v0/verify_and_promote.py",
      "linguistics/parser_trust.py",
      "linguistics/reducer_result_v1.py",
      "linguistics/reducers/__init__.py",
      "linguistics/reducers/intent_reducer_v1.py",
      "linguistics/resolve_intent_steps.py",
      "linguistics/world_snapshot_v1.py"
    ],
    "Memory and concept storage systems": [
      "memory/__init__.py",
      "memory/abstraction_expansion.py",
      "memory/abstractions.py",
      "memory/anchors.py",
      "memory/canonical.py",
      "memory/certificate_builder.py",
      "memory/certification.py",
      "memory/claim.py",
      "memory/concept_resolver.py",
      "memory/concept_store.py",
      "memory/concepts.py",
      "memory/conflict.py",
      "memory/expansion_policy.py",
      "memory/failure.py",
      "memory/handover.py",
      "memory/index_canonical.py",
      "memory/landmark_extractor.py",
      "memory/landmark_gate.py",
      "memory/landmark_node.py",
      "memory/landmark_registry.py",
      "memory/manifest_builder.py",
      "memory/meta_schemas.py",
      "memory/packet.py",
      "memory/packet_query.py",
      "memory/policy.py",
      "memory/projection.py",
      "memory/reasoner_integration.py",
      "memory/registry.py",
      "memory/registry_logic.py",
      "memory/registry_store.py",
      "memory/registry_types.py",
      "memory/report_builder.py",
      "memory/schema.py",
      "memory/schema_base.py",
      "memory/semantic_coverage.py",
      "memory/text_claim_schemas.py",
      "memory/text_claims.py",
      "memory/text_negative_controls.py",
      "memory/text_packet_consumer.py",
      "memory/text_projection_report.py",
      "memory/tool_loops.py",
      "memory/verifier.py",
      "memory/verifier_engine.py",
      "memory/verifier_io.py",
      "memory/verifier_types.py"
    ],
    "Operator registry, signatures, and certified loader": [
      "operators/__init__.py",
      "operators/bundle.py",
      "operators/bundle_schemas.py",
      "operators/canonicalization.py",
      "operators/certified_bundle.py",
      "operators/certified_loader.py",
      "operators/certified_store.py",
      "operators/contract.py",
      "operators/effects.py",
      "operators/episode_chain.py",
      "operators/errors.py",
      "operators/evidence_contract.py",
      "operators/execution_attestation.py",
      "operators/execution_context.py",
      "operators/fence.py",
      "operators/gate.py",
      "operators/governance_runtime.py",
      "operators/inventory.py",
      "operators/operator_ir_v1.py",
      "operators/operator_ir_verifier.py",
      "operators/pn/__init__.py",
      "operators/pn/linguistics.py",
      "operators/pn/operators.py",
      "operators/preconditions.py",
      "operators/promoted_operator.py",
      "operators/promotion_policy.py",
      "operators/promotion_service.py",
      "operators/promotion_token.py",
      "operators/registry.py",
      "operators/registry_profiles.py",
      "operators/registry_protocol.py",
      "operators/registry_resolve.py",
      "operators/registry_store.py",
      "operators/registry_types.py",
      "operators/registry_view.py",
      "operators/scope_allowlist.py",
      "operators/shadow_store.py",
      "operators/text_semantic_ops.py",
      "operators/universe.py"
    ],
    "Predicate nominal processing": [
      "pn/__init__.py",
      "pn/ir_builder.py",
      "pn/surface_generator.py"
    ],
    "TD12/MS certificates, proof bundles, and replay verification": [
      "proofs/__init__.py",
      "proofs/ablation_results.py",
      "proofs/adjudicable_state.py",
      "proofs/artifact_hashing.py",
      "proofs/batch_hasher.py",
      "proofs/benchmark_artifacts.py",
      "proofs/byte_replay_verification.py",
      "proofs/capsule_spec_ea.py",
      "proofs/certificate.py",
      "proofs/certification_blocker.py",
      "proofs/cold_start_verifier.py",
      "proofs/commitment_hash.py",
      "proofs/determinism.py",
      "proofs/equivalence_adjudication.py",
      "proofs/equivalence_adjudicator.py",
      "proofs/equivalence_gates.py",
      "proofs/equivalence_witness.py",
      "proofs/eval_witness.py",
      "proofs/evidence_item_ir.py",
      "proofs/evidence_schema_registry.py",
      "proofs/fixture_ir.py",
      "proofs/h2_evidence_bundle.py",
      "proofs/h2_evidence_bundle_generator.py",
      "proofs/handover_gates.py",
      "proofs/induction/__init__.py",
      "proofs/induction/builders.py",
      "proofs/induction/capsule_spec_di.py",
      "proofs/induction/domain_spec_ir.py",
      "proofs/induction/evidence_stream.py",
      "proofs/induction/exceptions.py",
      "proofs/induction/failures.py",
      "proofs/induction/induction_report.py",
      "proofs/induction/policies.py",
      "proofs/induction/probes.py",
      "proofs/induction/rule_ir.py",
      "proofs/k6_e3_fence.py",
      "proofs/key_parsing.py",
      "proofs/p22/__init__.py",
      "proofs/p22/capsule_spec_p22.py",
      "proofs/p22/evidence_types_v0.py",
      "proofs/p22/verification_types_v1.py",
      "proofs/pinned_env.py",
      "proofs/pre_certificate_ref.py",
      "proofs/provenance_chain.py",
      "proofs/provenance_closure_projection.py",
      "proofs/provenance_verifier.py",
      "proofs/refinement.py",
      "proofs/replay_verification.py",
      "proofs/run_manifest.py",
      "proofs/sampling_policy.py",
      "proofs/schema_validation.py",
      "proofs/shared/__init__.py",
      "proofs/shared/canonical_json.py",
      "proofs/shared/claim_surface.py",
      "proofs/shared/digesting.py",
      "proofs/shared/failures.py",
      "proofs/shared/identifiers.py",
      "proofs/shared/manifest.py",
      "proofs/shared/transfer_domain_descriptor.py",
      "proofs/shared/transfer_verdict.py",
      "proofs/signing.py",
      "proofs/stage_k_projection.py",
      "proofs/stage_l_transfer_claim.py",
      "proofs/step_witness.py",
      "proofs/synthesis/__init__.py",
      "proofs/synthesis/builders.py",
      "proofs/synthesis/capsule_spec_ps.py",
      "proofs/synthesis/exceptions.py",
      "proofs/synthesis/failures.py",
      "proofs/synthesis/operator_candidate.py",
      "proofs/synthesis/policies.py",
      "proofs/synthesis/program_ir.py",
      "proofs/synthesis/synthesis_report.py",
      "proofs/synthesis/synthesis_task.py",
      "proofs/synthesis/witnesses.py",
      "proofs/td12_certify.py",
      "proofs/td12_dossier_snapshot.py",
      "proofs/td12_ms_certificate.py",
      "proofs/td12_ms_integration.py",
      "proofs/td12_policy.py",
      "proofs/td12_verify.py",
      "proofs/td7/__init__.py",
      "proofs/td7/necessity.py",
      "proofs/verification_bundle.py"
    ],
    "Pseudocode IR and processing": [
      "pseudocode/__init__.py",
      "pseudocode/ir.py",
      "pseudocode/lowering/__init__.py",
      "pseudocode/lowering/python.py",
      "pseudocode/operators.py",
      "pseudocode/semantics.py",
      "pseudocode/tagger.py"
    ],
    "Search, state graphs, instrumentation, and failure taxonomy": [
      "reasoning/__init__.py",
      "reasoning/_apply_impl.py",
      "reasoning/_transactional_apply.py",
      "reasoning/backtracking.py",
      "reasoning/benchmarks.py",
      "reasoning/confidence.py",
      "reasoning/dataset_builder.py",
      "reasoning/deterministic_replay.py",
      "reasoning/episode_loader.py",
      "reasoning/episode_logger.py",
      "reasoning/episode_profile.py",
      "reasoning/episode_report.py",
      "reasoning/episode_select.py",
      "reasoning/failure_taxonomy.py",
      "reasoning/graph_emitter.py",
      "reasoning/instrumented/__init__.py",
      "reasoning/instrumented/core.py",
      "reasoning/instrumented/diagnostics.py",
      "reasoning/instrumented/governance.py",
      "reasoning/instrumented/influence_seam.py",
      "reasoning/instrumented/parallel_expansion.py",
      "reasoning/instrumented/policy.py",
      "reasoning/instrumented/types.py",
      "reasoning/instrumented/utils.py",
      "reasoning/instrumented/witness_sink.py",
      "reasoning/instrumented_search.py",
      "reasoning/intent_prior.py",
      "reasoning/landmark_influence.py",
      "reasoning/learning.py",
      "reasoning/loop/__init__.py",
      "reasoning/loop/components.py",
      "reasoning/loop/frontier_snapshot.py",
      "reasoning/loop/kg_interface.py",
      "reasoning/loop/main.py",
      "reasoning/loop/node_key_hash.py",
      "reasoning/loop/score_quantizer.py",
      "reasoning/loop/search_strategies.py",
      "reasoning/loop/shadow_frontier_adapter.py",
      "reasoning/loop/snapshot_verifier.py",
      "reasoning/loop/state.py",
      "reasoning/loop/tasks.py",
      "reasoning/loop/types.py",
      "reasoning/models/intent_aware_scorer_v2.py",
      "reasoning/models/transition_scorer.py",
      "reasoning/mutation_pipeline.py",
      "reasoning/parallel_executor.py",
      "reasoning/planner.py",
      "reasoning/pn_task.py",
      "reasoning/prior_scope.py",
      "reasoning/resource_envelope.py",
      "reasoning/rules.py",
      "reasoning/search.py",
      "reasoning/self_correction.py",
      "reasoning/semantic_delta_enforcement.py",
      "reasoning/stage_l_controls.py",
      "reasoning/staged_search.py",
      "reasoning/state_graph.py",
      "reasoning/step_instrumentation.py",
      "reasoning/step_record.py",
      "reasoning/telemetry.py",
      "reasoning/trace_audit.py",
      "reasoning/transactional_apply.py",
      "reasoning/value_features.py",
      "reasoning/verifier.py"
    ],
    "Linguistic reconstruction": [
      "reconstruction/__init__.py",
      "reconstruction/linguistic_reconstruction.py"
    ],
    "Task definitions and verification": [
      "tasks/__init__.py",
      "tasks/claims.py",
      "tasks/dialogue_rollout.py",
      "tasks/lemma_grammar_realization.py",
      "tasks/meta_plan.py",
      "tasks/pn_verification.py",
      "tasks/wordnet_navigation.py"
    ],
    "Temporal Difference learning infrastructure": [
      "td/__init__.py",
      "td/action_space.py",
      "td/candidate_q.py",
      "td/candidate_scorer.py",
      "td/env.py",
      "td/hierarchical_policy.py",
      "td/model_extensions.py",
      "td/preflight.py",
      "td/rollouts.py",
      "td/targets.py"
    ],
    "Text IR and parsing": [
      "text/__init__.py",
      "text/hard_ir.py",
      "text/intake_ir.py",
      "text/ir.py",
      "text/parser.py",
      "text/pipeline.py",
      "text/realizer.py",
      "text/semantics.py",
      "text/text_to_search.py",
      "text/trace_narrator.py"
    ],
    "Utility functions": [
      "util/__init__.py",
      "util/dataset_schema.py",
      "util/pathing.py"
    ],
    "Value function implementations and scoring": [
      "value/__init__.py",
      "value/adapters.py",
      "value/dialogue_scorer.py",
      "value/feature_classification.py",
      "value/featurizers/__init__.py",
      "value/featurizers/core.py",
      "value/featurizers/kernel_augment.py",
      "value/grouped_head.py",
      "value/hybrid.py",
      "value/landmark_embeddings.py",
      "value/latent/__init__.py",
      "value/latent/ablation_modes.py",
      "value/latent/archive/latent_value_model.py",
      "value/latent/ir_bottleneck_encoder.py",
      "value/latent/ir_latent_v1.py",
      "value/latent/latent_value_model_v2.py",
      "value/latent/latent_value_model_v3.py",
      "value/latent/protocol.py",
      "value/latent/serialization.py",
      "value/latent/sterling_encoder.py",
      "value/latent/student_head.py",
      "value/latent/teacher_head.py",
      "value/latent/training_dataset.py",
      "value/latent/training_dataset_v2.py",
      "value/latent/value_head.py",
      "value/mdl.py",
      "value/memory.py",
      "value/operator_features.py",
      "value/pragmatics_prior.py",
      "value/protocol.py",
      "value/structural.py",
      "value/target_contract.py",
      "value/task_heads.py"
    ],
    "World adapters (WordNet, Claims, Discourse, Code, etc.)": [
      "worlds/__init__.py",
      "worlds/base.py",
      "worlds/claim_ir.py",
      "worlds/claim_parser.py",
      "worlds/claim_verifier.py",
      "worlds/claims.py",
      "worlds/code_refactoring.py",
      "worlds/delta_observation_helpers.py",
      "worlds/discourse.py",
      "worlds/discourse/__init__.py",
      "worlds/discourse/operators.py",
      "worlds/discourse/types.py",
      "worlds/discourse/world.py",
      "worlds/landmarks.py",
      "worlds/lemma_grammar/__init__.py",
      "worlds/lemma_grammar/gates.py",
      "worlds/lemma_grammar/kernel.py",
      "worlds/lemma_grammar/morphology.py",
      "worlds/lemma_grammar/realization.py",
      "worlds/lemma_grammar/types.py",
      "worlds/lemma_grammar/world.py",
      "worlds/mastermind.py",
      "worlds/meta_plan.py",
      "worlds/meta_plan_operators.py",
      "worlds/meta_plan_types.py",
      "worlds/mta/__init__.py",
      "worlds/mta/effects.py",
      "worlds/mta/errors.py",
      "worlds/mta/kernel.py",
      "worlds/mta/operator_adapter.py",
      "worlds/mta/preconditions.py",
      "worlds/mta/registry.py",
      "worlds/mta/signatures.py",
      "worlds/mta/world.py",
      "worlds/pn.py",
      "worlds/pseudocode.py",
      "worlds/rome_kg.py",
      "worlds/state_transition.py",
      "worlds/text.py",
      "worlds/wordnet.py"
    ]
  },
  "statistics": {
    "by_status": {
      "active": 763,
      "legacy_v7": 19,
      "stable": 1,
      "archived": 1
    },
    "by_category": {
      "Package initialization": 22,
      "K6 fence harness, proof runs, and certification testing": 42,
      "Core module": 110,
      "Semantic contracts and invariants": 10,
      "Dialogue and discourse processing": 7,
      "Domain specifications and configuration": 19,
      "Run intents, fail-closed gates, and audit infrastructure": 13,
      "Operator learning, promotion pipeline, and hypothesis lifecycle": 120,
      "Intent classification and prediction": 7,
      "Intermediate representations (semantic, syntax, delta)": 5,
      "Domain-specific reasoning kernels": 10,
      "Knowledge graph integration and registry": 5,
      "Label spaces and adapters": 9,
      "Linguistic processing operators": 58,
      "Memory and concept storage systems": 45,
      "Operator registry, signatures, and certified loader": 39,
      "Predicate nominal processing": 3,
      "TD12/MS certificates, proof bundles, and replay verification": 84,
      "Pseudocode IR and processing": 7,
      "Search, state graphs, instrumentation, and failure taxonomy": 64,
      "Linguistic reconstruction": 2,
      "Task definitions and verification": 7,
      "Temporal Difference learning infrastructure": 10,
      "Text IR and parsing": 10,
      "Utility functions": 3,
      "Value function implementations and scoring": 33,
      "World adapters (WordNet, Claims, Discourse, Code, etc.)": 40
    },
    "total_lines": 322787,
    "total_classes": 2163,
    "total_functions": 2116,
    "todos_by_priority": {
      "P0-GOV": 0,
      "P1-METRIC": 3,
      "P2-QUAL": 1,
      "P3-UX": 0,
      "untagged": 37
    },
    "total_todos": 41
  }
}