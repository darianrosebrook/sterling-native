id: SEARCH-CORE-001
type: feature
title: "Search Core: Frontier, SearchNodeV1, SearchGraphV1, ValueScorer, best-first search with deterministic audit trail"
status: in_progress
risk_tier: 2
mode: development
created_at: "2026-02-25T23:00:00.000Z"
updated_at: "2026-02-25T23:00:00.000Z"
blast_radius:
  modules:
    - search
    - harness/runner
    - harness/bundle
    - tests
  data_migration: false
operational_rollback_slo: 5m
scope:
  in:
    - search/*
    - harness/
    - tests/lock/
    - benchmarks/
    - Cargo.toml
    - .github/workflows/
    - tools/
  out:
    - kernel/
    - docs/
    - ml/
    - reference/v1_impl/
    - .caws/
threats:
  - "Search crate accidentally depending on harness (breaks one-way dependency invariant)"
  - "HashMap iteration order in frontier or visited set breaking determinism"
  - "Float scores leaking into Cert-mode ordering"
  - "Silent pruning or rejection without graph recording (hidden router)"
  - "World enumerate_candidates using stale or split-brain registry"
  - "Dead-end tagging claiming semantic impossibility when expansion was budget-limited"
invariants:
  - "INV-SC-01: Given identical (root_state, policy, scorer), search produces identical SearchGraphV1 bytes"
  - "INV-SC-02: Worlds MUST enumerate only candidates whose op_code exists in the runner-supplied RegistryV1; illegal candidates terminate with WorldContractViolation"
  - "INV-SC-03: Every frontier pop and every candidate decision is recorded as ExpandEventV1 + CandidateRecordV1; no silent pruning"
  - "INV-SC-04: Every candidate score carries deterministic provenance (ScoreSourceV1); learned bias is recorded, not hidden"
  - "INV-SC-05: state_fingerprint is computed from the policy-declared dedup key (DedupKeyV1) and recorded in metadata"
  - "INV-SC-06: Frontier selection order matches recorded expansion_order in the graph; no hidden decision pathway"
  - "INV-SC-07: Dead-end is tagged Exhaustive only if expansion completed without caps; BudgetLimited otherwise"
  - "INV-SC-08: Candidate enumeration uses the runner-supplied RegistryV1 snapshot only; no split-brain registry reads"
  - "INV-SC-09: node_summaries emitted in strict node_id ascending order"
  - "INV-SC-10: DedupKeyV1::FullState and PruneVisitedPolicyV1::ReleaseVisited are hard errors in M1"
  - "sterling_search depends on sterling_kernel only; it does NOT depend on sterling_harness"
  - "Neural/learned scoring is advisory only: cannot create actions, bypass legality, or suppress candidates"
  - "INV-SC-M33-01: SearchHealthMetricsV1 is a pure function of SearchGraphV1 (expansions + node_summaries only); no runtime state, no metadata counters"
  - "INV-SC-M33-02: Health metrics are DIAGNOSTIC; must not participate in any binding digest; verification must not fail due to metrics content"
  - "INV-SC-M33-03: Health metrics serialization is deterministic across platforms; no HashMap iteration; histogram arrays sorted by key ascending"
acceptance:
  # --- M1: Search Core ---
  - id: SC1-M1-SEARCH-DETERMINISM-INPROC
    given: "a RomeMiniSearch world and UniformScorer"
    when: "search() is called N>=10 times in the same process"
    then: "produces identical SearchGraphV1 canonical JSON bytes every time"
  - id: SC1-M1-SEARCH-DETERMINISM-CROSSPROC
    given: "the search_fixture binary"
    when: "spawned under 4 environment variants (cwd, locale, noise, baseline)"
    then: "all output lines are identical across variants"
  - id: SC1-M1-GRAPH-IN-BUNDLE
    given: "a run_search(RomeMiniSearch) call"
    when: "the bundle is inspected"
    then: "bundle contains search_graph.json marked normative; verify_bundle() passes"
  - id: SC1-M1-GRAPH-METADATA-BINDING
    given: "a search_graph.json from run_search()"
    when: "metadata fields are inspected"
    then: "world_id, schema_descriptor, registry_digest, policy_snapshot_digest, search_policy_digest, and root_state_fingerprint match corresponding bundle artifacts"
  - id: SC1-M1-GRAPH-COMPLETENESS
    given: "a search run with N expansions"
    when: "SearchGraphV1 is inspected"
    then: "every frontier pop appears as ExpandEventV1; every generated candidate appears as CandidateRecordV1 with outcome"
  - id: SC1-M1-LOOP-DETECTION
    given: "a world whose candidate actions create a cycle"
    when: "search() is called"
    then: "terminates without infinite expansion; duplicate states recorded as DuplicateSuppressed in graph"
  - id: SC1-M1-DEAD-END-SEMANTICS
    given: "a world with states that have no valid successors"
    when: "search() expands such a node"
    then: "node tagged DeadEndReasonV1::Exhaustive; cap-limited exhaustion tagged BudgetLimited"
  - id: SC1-M1-BUDGET-EXPANSION-OVERFLOW
    given: "a search policy with max_expansions=1 and >1 reachable state"
    when: "search() is called"
    then: "termination_reason is ExpansionBudgetExceeded; graph is complete up to cutoff"
  - id: SC1-M1-CANDIDATE-LEGALITY
    given: "a world that enumerates a candidate with op_code not in the registry"
    when: "search() processes that candidate"
    then: "recorded as CandidateOutcomeV1::IllegalOperator; run terminates with WorldContractViolation"
  - id: SC1-M1-SCORE-PROVENANCE
    given: "a search run with both UniformScorer and a custom non-uniform scorer"
    when: "SearchGraphV1 CandidateRecordV1 entries are inspected"
    then: "all carry ScoreSourceV1; non-uniform scorer changes deterministic candidate order vs uniform"
  - id: SC1-M1-FRONTIER-PRUNING
    given: "a search policy with max_frontier_size < total reachable states"
    when: "frontier exceeds max"
    then: "pruned to max by total key; pruned node_ids and prune_visited_policy recorded in notes"
  - id: SC1-M1-GOAL-PATH-RECONSTRUCTION
    given: "a search run that reaches a goal"
    when: "the goal node path is reconstructed via parent_id pointers"
    then: "path from root to goal is complete and all steps correspond to Applied edges in the graph"
  - id: SC1-M1-GOV-LINT-MULTISPEC
    given: "the lint_acceptance_ids.py tool"
    when: "run on the workspace"
    then: "scans all .caws/specs/*.yaml and validates references for both SPINE-001 and SEARCH-CORE-001"
  - id: SC1-M1-RESERVED-POLICY-HARDERROR
    given: "a SearchPolicyV1 selecting DedupKeyV1::FullState or PruneVisitedPolicyV1::ReleaseVisited"
    when: "search() is called"
    then: "fails deterministically with explicit SearchError, no silent fallback"
  # --- M2: Search Hardening ---
  - id: SC1-M2-SCORER-PANIC-PRESERVES-GRAPH
    given: "a scorer that panics in score_candidates()"
    when: "search() catches the panic via catch_unwind"
    then: "returns Ok(SearchResult) with InternalPanic{ScoreCandidates} and partial graph"
  - id: SC1-M2-ENUMERATE-PANIC-PRESERVES-GRAPH
    given: "a world that panics in enumerate_candidates()"
    when: "search() catches the panic"
    then: "returns Ok with InternalPanic{EnumerateCandidates} and partial expansion event"
  - id: SC1-M2-IS-GOAL-PANIC-PRESERVES-GRAPH
    given: "a world that panics in is_goal() on root or expansion"
    when: "search() catches the panic"
    then: "returns Ok with InternalPanic{IsGoalRoot|IsGoalExpansion} and partial graph"
  - id: SC1-M2-SCORER-CONTRACT-VIOLATION-PRESERVES-GRAPH
    given: "a scorer returning wrong arity"
    when: "search() detects the mismatch"
    then: "returns Ok with ScorerContractViolation{expected,actual} and partial graph"
  - id: SC1-M2-IS-GOAL-REACHED-HELPER
    given: "SearchResult from a goal-found or non-goal search"
    when: "is_goal_reached() is called"
    then: "returns true only for GoalReached termination"
  - id: SC1-M2-PREFLIGHT-UNSUPPORTED-MODE-ERR-NO-GRAPH
    given: "a reserved policy option (FullState dedup)"
    when: "search() is called"
    then: "returns Err(UnsupportedPolicyMode) with no SearchGraphV1"
  - id: SC1-M2-TERMINATION-DETAILS-DETERMINISTIC
    given: "identical inputs producing a panic termination"
    when: "search() is called twice"
    then: "SearchGraphV1 canonical JSON bytes are identical"
  - id: SC1-M2-SEARCH-GRAPH-DIGEST-MANDATORY
    given: "a search bundle with search_graph_digest removed from report"
    when: "verify_bundle() is called"
    then: "returns SearchGraphDigestMissing error"
  - id: SC1-M2-MODE-COHERENCE-SEARCH-NO-GRAPH
    given: "mode=search in report but no search_graph.json artifact"
    when: "verify_bundle() is called"
    then: "returns SearchGraphArtifactMissing error"
  - id: SC1-M2-MODE-COHERENCE-GRAPH-NO-SEARCH
    given: "search_graph.json present but mode=linear in report"
    when: "verify_bundle() is called"
    then: "returns ModeSearchExpected error"
  - id: SC1-M2-METADATA-BINDING-POLICY-DIGEST
    given: "search_graph.json with wrong policy_snapshot_digest"
    when: "verify_bundle() is called"
    then: "returns MetadataBindingPolicyMismatch error"
  - id: SC1-M2-METADATA-BINDING-WORLD-ID
    given: "search_graph.json with wrong world_id vs report"
    when: "verify_bundle() is called"
    then: "returns MetadataBindingWorldIdMismatch error"
  - id: SC1-M2-RUN-SEARCH-GENERIC-SINGLE-WORLD
    given: "run_search generic signature"
    when: "called with a single RomeMiniSearch world"
    then: "compiles, runs, and produces valid bundle with 5 artifacts"
  - id: SC1-M2-CANDIDATE-DOMAIN-SEPARATION
    given: "identical input bytes"
    when: "hashed with DOMAIN_SEARCH_CANDIDATE vs DOMAIN_SEARCH_NODE"
    then: "produce different ContentHash values"
  - id: SC1-M2-CANDIDATE-CONSTRUCTOR-DETERMINISTIC
    given: "identical op_code and op_args"
    when: "CandidateActionV1::new() called twice"
    then: "produces identical CandidateActionV1 with matching canonical_hash"
  - id: SC1-M2-PANIC-PROFILE-UNWIND-ENFORCED
    given: "workspace compiled with dev or release profile"
    when: "std::panic::catch_unwind is called around a panic!()"
    then: "the panic is caught (not aborted)"
  - id: SC1-M2-WORLD-CONTRACT-VIOLATION-RETURNS-OK
    given: "a world enumerating an illegal candidate"
    when: "search() processes it"
    then: "returns Ok with WorldContractViolation termination and partial graph (not Err)"
  # --- M3.0: Search Bundle Persistence ---
  - id: SC1-M3.0-SEARCH-DIR-ROUNDTRIP
    given: "a search bundle from run_search(RomeMiniSearch)"
    when: "write_bundle_dir → read_bundle_dir round-trip"
    then: "loaded bundle has identical digest, manifest, digest_basis, and all 5 artifacts (content, content_hash, normative)"
  - id: SC1-M3.0-SEARCH-DIR-VERIFY
    given: "a cleanly persisted search bundle directory"
    when: "verify_bundle_dir() is called"
    then: "passes without error"
  - id: SC1-M3.0-SEARCH-LOADED-VERIFY
    given: "a search bundle loaded from disk via read_bundle_dir()"
    when: "verify_bundle() is called directly"
    then: "passes including search-specific checks (graph digest binding, mode coherence, metadata bindings)"
  - id: SC1-M3.0-SEARCH-GRAPH-CANONICAL-STABLE
    given: "search_graph.json from a search bundle"
    when: "persisted and reloaded"
    then: "bytes are identical before write and after read"
  - id: SC1-M3.0-SEARCH-TAMPER-GRAPH-BYTES
    given: "a persisted search bundle with search_graph.json tampered (1 byte flip)"
    when: "read_bundle_dir() is called"
    then: "fails with ContentHashMismatch for search_graph.json"
  - id: SC1-M3.0-SEARCH-TAMPER-REPORT-BYTES
    given: "a persisted search bundle with verification_report.json tampered (1 byte flip)"
    when: "read_bundle_dir() is called"
    then: "fails with ContentHashMismatch for verification_report.json"
  - id: SC1-M3.0-SEARCH-DIGEST-BINDING-MISMATCH
    given: "a bundle with modified search_graph.json content but stale search_graph_digest in report"
    when: "persisted, loaded, and verify_bundle() called"
    then: "fails with SearchGraphDigestMismatch (not parse or hash error)"
  - id: SC1-M3.0-SEARCH-MISSING-GRAPH-FILE
    given: "a persisted search bundle with search_graph.json deleted from disk"
    when: "read_bundle_dir() is called"
    then: "fails with MissingArtifact for search_graph.json"
  - id: SC1-M3.0-SEARCH-MISSING-GRAPH-DIGEST-FIELD
    given: "a bundle with search_graph_digest removed from verification_report.json"
    when: "persisted, loaded, and verify_bundle() called"
    then: "fails with SearchGraphDigestMissing"
  - id: SC1-M3.0-SEARCH-NO-PATH-LEAKAGE
    given: "a search bundle persisted to a temp directory"
    when: "normative surfaces are inspected"
    then: "no absolute path fragments found in manifest, digest_basis, or normative artifact content"
  # --- M3.1: Slot Lattice World (Second Search Topology) ---
  - id: SC1-M3.1-TRUNCATION-REACHABLE
    given: "regime_truncation (N=8, V=4, cap=5)"
    when: "search is run with the regime's policy"
    then: "first expansion has candidates_truncated == true and candidate count equals cap"
  - id: SC1-M3.1-DUPLICATES-REACHABLE
    given: "regime_duplicates (N=4, V=2, goal=Never)"
    when: "search explores until budget/frontier exhaustion"
    then: "total_duplicates_suppressed >= 1 and at least one DuplicateSuppressed outcome in graph"
  - id: SC1-M3.1-EXHAUSTIVE-DEAD-END-REACHABLE
    given: "regime_exhaustive_dead_end (N=4, V=3, trap=Slot0Eq(2))"
    when: "search encounters a trapped state"
    then: "total_dead_ends_exhaustive > 0 and at least one Exhaustive dead-end reason in expansions"
  - id: SC1-M3.1-BUDGET-TERMINATION
    given: "regime_budget_limited (N=6, V=3, max_expansions=3)"
    when: "search is run"
    then: "termination_reason == ExpansionBudgetExceeded and total_expansions == max_expansions"
  - id: SC1-M3.1-FRONTIER-PRESSURE
    given: "regime_frontier_pressure (N=6, V=3, max_frontier_size=8)"
    when: "search is run"
    then: "frontier_high_water >= 8 and FrontierPruned notes present in expansions"
  - id: SC1-M3.1-DETERMINISM-N10
    given: "regime_duplicates world with identical policy and scorer"
    when: "search() is called 10 times in the same process"
    then: "produces identical SearchGraphV1 canonical JSON bytes every time"
  - id: SC1-M3.1-BUNDLE-VERIFY
    given: "run_search(SlotLatticeSearch) for exhaustive dead-end regime"
    when: "verify_bundle() is called"
    then: "passes without error"
  - id: SC1-M3.1-BUNDLE-PERSISTENCE
    given: "a slot lattice search bundle"
    when: "write_bundle_dir → read_bundle_dir → verify_bundle round-trip"
    then: "all artifacts survive with identical content"
  - id: SC1-M3.1-WORLD-ID-BINDS-CONFIG
    given: "regime_truncation world"
    when: "world_id() is inspected"
    then: "equals 'slot_lattice:v1:n8:v4:trap_none:goal_all_nonzero' and matches graph metadata"
  - id: SC1-M3.1-SCHEMA-DESCRIPTOR-STABLE
    given: "all five regime constructors"
    when: "schema_descriptor() is called on each"
    then: "all return identical (id, version, hash) with real sha256 hash (not placeholder)"
  - id: SC1-M3.1-ENUMERATION-DETERMINISTIC
    given: "a SlotLatticeSearch world and fresh state"
    when: "enumerate_candidates() is called twice"
    then: "returns identical candidates in identical order"
  # --- M3.3: Search Health Metrics ---
  - id: SC1-M3.3-METRICS-PURE
    given: "a fixed SearchGraphV1 fixture"
    when: "compute_health_metrics() is called twice"
    then: "produces identical SearchHealthMetricsV1 values (struct equality)"
  - id: SC1-M3.3-METRICS-GOLDEN
    given: "regime_duplicates SearchGraphV1 fixture"
    when: "compute_health_metrics() serialized to canonical JSON"
    then: "bytes equal golden snapshot committed in the test"
  - id: SC1-M3.3-HISTOGRAMS-COVERAGE
    given: "any SearchGraphV1"
    when: "sum(depth_histogram_pairs values) and sum(candidate_count_histogram_pairs values) are computed"
    then: "depth sum equals node_summaries.len(); candidate_count sum equals expansions.len()"
  - id: SC1-M3.3-OUTCOME-EXHAUSTIVE
    given: "a SearchGraphV1 fixture containing all CandidateOutcomeV1 variants"
    when: "compute_health_metrics() is called"
    then: "every outcome counter is non-zero and all counters sum to total_candidates"
  - id: SC1-M3.3-NONBINDING
    given: "a valid bundle produced by run_search()"
    when: "verification_report.json health_metrics bytes are modified"
    then: "verify_bundle() still passes (metrics are DIAGNOSTIC, not binding)"
acceptance_criteria: []
non_functional:
  perf:
    search_1000_nodes_p95_ms: 500
  security:
    - "search crate has zero harness dependencies"
    - "no HashMap iteration in ordering-sensitive paths"
contracts:
  - type: architecture
    path: .claude/plans/snappy-booping-mccarthy.md
    description: "SEARCH-CORE-001 M1 implementation plan with type definitions, invariants, and execution order"
  - type: architecture
    path: .claude/plans/scalable-petting-sloth.md
    description: "SEARCH-CORE-001 M2 hardening plan: evidence preservation, symmetric verification, generic wiring, canonicalization"
out_of_contract:
  - "Evidence preservation guarantees exclude process-level abort classes: OOM abort, explicit std::process::abort(), external SIGKILL, panic=abort profile override"
  - "catch_unwind depends on panic=unwind; workspace Cargo.toml pins this for dev and release profiles"
  - "UnsupportedPolicyMode pre-flight refusal returns Err(SearchError) with no SearchGraphV1; no search steps were taken so no graph evidence is produced"
  - "codebook_hash in search verification report is diagnostic (not verified by verify_bundle); present for observability, does not participate in integrity proofs"
  - "Search worlds may return empty program from WorldHarnessV1::program(); codebook_hash for search bundles is derived from an empty operator set and remains DIAGNOSTIC — it does not affect search ordering, verification, or evidence integrity"
milestones:
  - id: M1
    title: "Search Core: frontier, graph, scorer, best-first loop"
    status: complete
    evidence:
      total_tests: 281
      new_tests: 39
      acceptance_ids_anchored: 14
      commits:
        - "ac7b482 feat(search): add sterling_search crate with core search types, frontier, graph, and search loop [SEARCH-CORE-001]"
        - "2402cd7 feat(harness): integrate search into runner and bundle pipeline [SEARCH-CORE-001]"
        - "65392ac test(lock): add SEARCH-CORE-001 lock tests and cross-proc fixture [SEARCH-CORE-001]"
      crates_added:
        - "sterling_search (depends on sterling_kernel only)"
      files_created:
        - "search/Cargo.toml"
        - "search/src/lib.rs"
        - "search/src/node.rs"
        - "search/src/frontier.rs"
        - "search/src/scorer.rs"
        - "search/src/graph.rs"
        - "search/src/policy.rs"
        - "search/src/search.rs"
        - "search/src/contract.rs"
        - "search/src/error.rs"
        - "harness/src/worlds/rome_mini_search.rs"
        - "tests/lock/tests/sc1_search_determinism.rs"
        - "tests/lock/tests/sc1_crossproc.rs"
        - "tests/lock/src/bin/search_fixture.rs"
    deliverables:
      - "sterling_search crate (depends on sterling_kernel only)"
      - "SearchNodeV1, CandidateActionV1 core types with deterministic ordering"
      - "CandidateScoreV1 + ScoreSourceV1 provenance types"
      - "ValueScorer trait + UniformScorer default"
      - "SearchWorldV1 trait (extends WorldHarnessV1)"
      - "BestFirstFrontier with BTreeSet-based visited set and dead-end tracking"
      - "search() entry point with budget enforcement and termination reasons"
      - "SearchGraphV1 expansion-event log with canonical JSON serialization"
      - "SearchPolicyV1 with DedupKeyV1 and PruneVisitedPolicyV1"
      - "Reserved policy options (FullState, ReleaseVisited) fail as hard errors"
      - "RomeMiniSearch test world with deterministic candidate enumeration"
      - "run_search() harness integration with search_graph.json bundle artifact"
      - "Verification extended with search graph digest + metadata binding"
      - "Lock tests: determinism (in-proc N=10), cross-proc (4 variants), graph completeness"
      - "Edge-case tests: loop detection, dead-end semantics, budget overflow, legality, pruning, provenance"
      - "Multi-spec acceptance lint (tools/lint_acceptance_ids.py)"
  - id: M2
    title: "Search Hardening: evidence preservation, symmetric verification, generic wiring, canonicalization"
    status: complete
    evidence:
      total_tests: 299
      new_tests: 18
      acceptance_ids_anchored: 17
      commits:
        - "67522e4 feat(search): centralize CandidateAction canonicalization with domain separation [SEARCH-CORE-001]"
        - "61eaa20 feat(search): evidence preservation — always return SearchGraphV1 [SEARCH-CORE-001]"
        - "2fe17ff chore(build): pin panic=unwind in workspace profiles [SEARCH-CORE-001]"
        - "0f4083a feat(harness): generic run_search with world_id coherence check [SEARCH-CORE-001]"
        - "f9be262 feat(harness): symmetric bundle verification with closed bindings [SEARCH-CORE-001]"
        - "68a3bc7 test(lock): add SEARCH-CORE-001 M2 hardening lock tests [SEARCH-CORE-001]"
      files_created:
        - "tests/lock/tests/sc1_m2_hardening.rs"
      files_modified:
        - "search/src/node.rs"
        - "search/src/error.rs"
        - "search/src/graph.rs"
        - "search/src/search.rs"
        - "search/src/scorer.rs"
        - "harness/src/bundle.rs"
        - "harness/src/runner.rs"
        - "harness/src/worlds/rome_mini_search.rs"
        - "tests/lock/tests/sc1_search_determinism.rs"
        - "tests/lock/src/bin/search_fixture.rs"
        - "Cargo.toml"
    deliverables:
      - "Evidence preservation: search() always returns Ok(SearchResult) with SearchGraphV1 for all runtime terminations"
      - "catch_unwind on world.enumerate_candidates(), world.is_goal(), scorer.score_candidates()"
      - "TerminationReasonV1 new variants: ScorerContractViolation, InternalPanic, FrontierInvariantViolation"
      - "PanicStageV1 enum: EnumerateCandidates, ScoreCandidates, IsGoalRoot, IsGoalExpansion"
      - "SearchError reduced to UnsupportedPolicyMode only (pre-flight refusal)"
      - "WorldContractViolation now returns Ok with partial graph instead of Err"
      - "Generic run_search<W: SearchWorldV1 + WorldHarnessV1> (no split-brain)"
      - "World ID coherence check at run_search entry"
      - "DOMAIN_SEARCH_CANDIDATE domain separation from DOMAIN_SEARCH_NODE"
      - "CandidateActionV1::new() constructor with pub(crate) canonical_hash"
      - "Mandatory search_graph_digest in bundle verification"
      - "Mode↔artifact coherence: bidirectional enforcement"
      - "MetadataBindings cross-verification: policy_snapshot_digest and world_id"
      - "Workspace panic=unwind pinned in dev and release profiles"
  - id: M2.1
    title: "M2 post-review fixes: candidate identity, frontier stage, panic guard, binding convention"
    status: complete
    scope: "7 items from post-implementation review of M2 hardening"
    evidence:
      total_tests: 301
      new_tests: 2
      acceptance_ids_anchored: 17
      commits:
        - "e4e1ecf fix(search): preserve candidate identity on scorer failure paths [SEARCH-CORE-001]"
        - "b79c060 feat(search): add FrontierInvariantStageV1 to FrontierInvariantViolation [SEARCH-CORE-001]"
        - "aea1ef5 test(lock): add no-panic-macros guard for search core loop [SEARCH-CORE-001]"
        - "2d51563 refactor(lock): move rebuild_with_modified_graph to shared test lib [SEARCH-CORE-001]"
        - "9cf9729 docs(harness): binding_hex convention, diagnostic field marking, governance [SEARCH-CORE-001]"
      files_created:
        - "tests/lock/src/bundle_test_helpers.rs"
      files_modified:
        - "search/src/scorer.rs"
        - "search/src/graph.rs"
        - "search/src/search.rs"
        - "harness/src/bundle.rs"
        - "harness/src/runner.rs"
        - "tests/lock/src/lib.rs"
        - "tests/lock/tests/sc1_m2_hardening.rs"
    deliverables:
      - "ScoreSourceV1::Unavailable variant for unscored candidates (scorer panic or contract violation)"
      - "CandidateOutcomeV1::NotEvaluated variant for candidates enumerated but not evaluated"
      - "Scorer failure paths preserve post-sort/post-cap candidate identity with NotEvaluated + Unavailable"
      - "FrontierInvariantStageV1 typed stage enum on FrontierInvariantViolation"
      - "no_panic_macros_in_core_loop lock test with brace-depth cfg(test) skipper"
      - "rebuild_with_modified_graph shared test primitive in lock_tests::bundle_test_helpers"
      - "binding_hex() convention scoped to graph-metadata binding comparisons"
      - "BINDING/DIAGNOSTIC field-level comments in verification report construction"
      - "out_of_contract: UnsupportedPolicyMode pre-flight refusal produces no SearchGraphV1"
      - "out_of_contract: codebook_hash is diagnostic (not verified by verify_bundle)"
  - id: M3.0
    title: "Search bundle persistence round-trip: artifact closure for search evidence"
    status: complete
    scope: "Lock tests proving write/read/verify round-trip for search bundles; no production code changes"
    evidence:
      total_tests: 311
      new_tests: 10
      acceptance_ids_anchored: 10
      commits:
        - "3e53543 test(lock): add SEARCH-CORE-001 M3.0 search bundle persistence lock tests [SEARCH-CORE-001]"
      files_created:
        - "tests/lock/tests/sc1_m3_persistence.rs"
    deliverables:
      - "Round-trip idempotence: run_search → write_bundle_dir → read_bundle_dir preserves all 5 artifacts, digests, and derived projections"
      - "Offline verification: verify_bundle_dir() passes on cleanly persisted search directory"
      - "Loaded bundle re-verification: loaded search bundle passes verify_bundle() including graph digest binding, mode coherence, metadata bindings"
      - "Canonical stability: search_graph.json bytes identical before write and after read"
      - "Falsifier: tampered graph bytes → ContentHashMismatch at read boundary"
      - "Falsifier: tampered report bytes → ContentHashMismatch at read boundary"
      - "Falsifier: valid-but-wrong graph content → SearchGraphDigestMismatch (semantic binding failure)"
      - "Falsifier: missing search_graph.json file → MissingArtifact"
      - "Falsifier: missing search_graph_digest field → SearchGraphDigestMissing"
      - "Hygiene: no path leakage in normative surfaces of persisted search bundles"
  - id: M3.1
    title: "Slot Lattice World: second search topology with parameterized stress regimes"
    status: complete
    scope: "New search world with configurable stress axes; no changes to kernel, search loop, bundle, or runner"
    evidence:
      total_tests: 327
      new_tests: 16
      acceptance_ids_anchored: 11
      commits:
        - "de4b4ed feat(worlds): add SlotLatticeSearch world with regime constructors [SEARCH-CORE-001]"
        - "ed42017 test(lock): add SEARCH-CORE-001 M3.1 slot lattice lock tests [SEARCH-CORE-001]"
      files_created:
        - "harness/src/worlds/slot_lattice_search.rs"
        - "harness/src/worlds/slot_lattice_regimes.rs"
        - "tests/lock/tests/sc1_m3_1_slot_lattice.rs"
      files_modified:
        - "harness/src/worlds/mod.rs"
    deliverables:
      - "SlotLatticeSearch: parameterized search world with N active slots × V values, configurable traps and goal profiles"
      - "TrapRule and GoalProfile enums for deterministic stress axis control"
      - "Fixed MAX_SLOTS=10 compiled layout with active_slots semantic control"
      - "Stable world_id encoding: slot_lattice:v1:n{N}:v{V}:trap_{rule}:goal_{profile}"
      - "Real schema descriptor hash via canonical_hash(DOMAIN_HARNESS_FIXTURE, canonical_json(basis))"
      - "Five canonical regime constructors returning matched (world, policy, expectations) triples"
      - "RegimeExpectations struct encoding minimum observable thresholds per stress axis"
      - "Explicit policy construction in all regimes (no defaults drift)"
      - "regime_truncation: N=8 V=4 cap=5 exercises candidate truncation"
      - "regime_duplicates: N=4 V=2 goal=Never exercises duplicate suppression under combinatorial pressure"
      - "regime_exhaustive_dead_end: trap=Slot0Eq(2) exercises exhaustive dead ends from trap states"
      - "regime_budget_limited: max_expansions=3 exercises budget termination"
      - "regime_frontier_pressure: max_frontier_size=8 exercises frontier pruning"
      - "11 lock tests proving all stress axes are reachable with threshold assertions"
      - "Bundle integrity: verify_bundle and write/read/verify round-trip for slot lattice bundles"
      - "Determinism: 10 identical runs produce identical SearchGraphV1 canonical JSON bytes"
  - id: M3.2
    title: "Table Scorer as Auditable Bundle Artifact"
    status: complete
    scope: "Non-uniform scorer as normative in-bundle artifact with fail-closed provenance checks"
    # Post-closeout hardening: replaced unconditional ScorerArtifactUnused with
    # conditional ScorerEvidenceMissing (allows root-goal and scorer-failure shapes),
    # added scorer key validation, renamed cross-proc misnomer.
    evidence:
      total_tests: 347
      new_tests: 20
      acceptance_ids_anchored: 14
      commits:
        - "fa0c64b feat(scorer): add TableScorer, ScorerArtifactV1, scorer_digest metadata bindings [SEARCH-CORE-001]"
        - "c4428d6 feat(bundle): verify scorer digest and candidate score-source coherence [SEARCH-CORE-001]"
        - "3c38ad8 test(lock): add M3.2 scorer lock tests with concrete reorder and advisory proofs [SEARCH-CORE-001]"
        - "26bf610 fix(bundle): make scorer evidence invariant conditional on expansions and termination reason [SEARCH-CORE-001]"
        - "713baea test(lock): add root-goal/failure-shape no-model-digest coverage and rename invocation determinism test [SEARCH-CORE-001]"
      files_created:
        - "tests/lock/tests/sc1_m3_2_table_scorer.rs"
      files_modified:
        - "search/src/scorer.rs"
        - "search/src/graph.rs"
        - "search/src/search.rs"
        - "harness/src/runner.rs"
        - "harness/src/bundle.rs"
        - "tests/lock/tests/sc1_m3_1_slot_lattice.rs"
        - "tests/lock/tests/sc1_search_determinism.rs"
        - "tests/lock/tests/sc1_m2_hardening.rs"
        - "tests/lock/tests/sc1_m3_persistence.rs"
        - "tests/lock/src/bin/search_fixture.rs"
    acceptance_criteria:
      - id: AC-M3.2-01
        test: table_scorer_reorders_candidates_concretely
        description: "Boosted candidate (bonus=100) becomes first post-score candidate in first expansion"
      - id: AC-M3.2-02
        test: table_scorer_deterministic_n10
        description: "10 runs with same scorer artifact produce identical search_graph.json bytes"
      - id: AC-M3.2-03
        test: advisory_only_candidate_set_preserved
        description: "Uniform vs table scorer produce identical first-expansion candidate sets (order may differ)"
      - id: AC-M3.2-04
        test: scorer_artifact_in_bundle
        description: "scorer.json present in bundle, normative, bytes match input artifact, 6 total artifacts"
      - id: AC-M3.2-05
        test: scorer_digest_in_report
        description: "verification_report.json has scorer_digest matching scorer.json content_hash"
      - id: AC-M3.2-06
        test: scorer_digest_in_graph_metadata
        description: "search_graph.json metadata has scorer_digest matching scorer.json content_hash hex"
      - id: AC-M3.2-07
        test: verify_bundle_passes_with_scorer
        description: "verify_bundle() succeeds on valid 6-artifact scorer bundle"
      - id: AC-M3.2-08
        test: scorer_tamper_detected
        description: "Tampered scorer.json triggers ScorerDigestMismatch on verification"
      - id: AC-M3.2-09
        test: score_source_digest_mismatch_detected
        description: "Candidate ModelDigest mismatch vs bound digest triggers CandidateScoreSourceScorerMismatch"
      - id: AC-M3.2-10
        test: uniform_scorer_no_scorer_artifact
        description: "Uniform scorer bundle has 5 artifacts, no scorer.json, passes verification"
      - id: AC-M3.2-11
        test: bundle_persistence_roundtrip_with_scorer
        description: "write/read/verify round-trip preserves all 6 scorer bundle artifacts identically"
      - id: AC-M3.2-12
        test: scorer_outputs_deterministic_across_invocations
        description: "Independent in-process pipeline invocations produce identical bundle digests and scorer artifacts"
      - id: AC-M3.2-13
        test: table_scorer_root_goal_bundle_verifiable
        description: "scorer.json with zero expansions (root-is-goal) verifies without requiring ModelDigest candidates"
      - id: AC-M3.2-14
        test: table_scorer_failure_shape_bundle_verifiable
        description: "scorer.json with scorer-failure termination and Unavailable sources verifies (M2 evidence preservation)"
    deliverables:
      - "TableScorer: BTreeMap<String, i64> scorer with injected digest, canonical JSON serialization"
      - "ScorerArtifactV1: atomic canonical bytes + content_hash + hex_digest for bundle inclusion"
      - "ScorerInputV1 enum: Uniform | Table{scorer, artifact} preventing invalid states"
      - "build_table_scorer_input() helper: single-call serialize + hash + wire, validates keys as sha256 ContentHash"
      - "scorer.json as 6th normative artifact with schema envelope (scorer.v1, kind=table, entries=sorted)"
      - "scorer_digest in SearchGraphMetadata and MetadataBindings (None for Uniform, Some for Table)"
      - "scorer_digest in verification_report.json (conditional on Table mode)"
      - "ScoreSourceV1::ModelDigest(ContentHash) provenance tag on table-scored candidates"
      - "Fail-closed coherence: report ↔ scorer artifact ↔ graph metadata ↔ candidate ModelDigest all bound"
      - "Conditional scorer evidence: ScorerEvidenceMissing replaces ScorerArtifactUnused (allows root-goal and scorer-failure shapes)"
      - "Advisory-only invariant: scorer reorders but cannot add/remove candidates"
      - "Back-compat: Uniform runs remain 5-artifact bundles with no scorer fields"
  - id: M3.3
    title: "Search Health Metrics: deterministic diagnostics derived from SearchGraphV1"
    status: not_started
    scope: >-
      New SearchHealthMetricsV1 struct computed purely from SearchGraphV1;
      placed in verification report as DIAGNOSTIC (non-binding); no changes
      to search loop, frontier, scorer, bundle verification, or digest computation.
    design_decisions:
      - "Histograms use array-of-pairs [[key, value], ...] sorted by key ascending, not JSON object keys (avoids lexicographic '10' < '2' papercut)"
      - "Health metrics live under diagnostics.health_metrics in verification report (namespace prevents future binding creep)"
      - "compute_health_metrics() is a pure function of &SearchGraphV1 — reads expansions + node_summaries only, never metadata counters"
      - "Cross-check against metadata counters is a test assertion, not a standing invariant (divergence is a bug, not a governance violation)"
      - "frontier_high_water is excluded from health metrics (runtime counter, not graph-derivable)"
    touch_points:
      - path: search/src/graph.rs
        change: "SearchHealthMetricsV1 struct + compute_health_metrics() impl"
      - path: harness/src/bundle.rs
        change: "Include health metrics under diagnostics.health_metrics in verification report JSON (DIAGNOSTIC)"
      - path: tests/lock/tests/sc1_m3_3_health_metrics.rs
        change: "Golden snapshot, determinism, histogram invariants, outcome exhaustiveness, non-binding proof"
