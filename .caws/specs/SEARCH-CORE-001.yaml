id: SEARCH-CORE-001
type: feature
title: "Search Core: Frontier, SearchNodeV1, SearchGraphV1, ValueScorer, best-first search with deterministic audit trail"
status: in_progress
risk_tier: 2
mode: development
created_at: "2026-02-25T23:00:00.000Z"
updated_at: "2026-02-25T23:00:00.000Z"
blast_radius:
  modules:
    - search
    - harness/runner
    - harness/bundle
    - tests
  data_migration: false
operational_rollback_slo: 5m
scope:
  in:
    - search/*
    - harness/
    - tests/lock/
    - .github/workflows/
    - tools/
  out:
    - kernel/
    - docs/
    - ml/
    - reference/v1_impl/
    - .caws/
threats:
  - "Search crate accidentally depending on harness (breaks one-way dependency invariant)"
  - "HashMap iteration order in frontier or visited set breaking determinism"
  - "Float scores leaking into Cert-mode ordering"
  - "Silent pruning or rejection without graph recording (hidden router)"
  - "World enumerate_candidates using stale or split-brain registry"
  - "Dead-end tagging claiming semantic impossibility when expansion was budget-limited"
invariants:
  - "INV-SC-01: Given identical (root_state, policy, scorer), search produces identical SearchGraphV1 bytes"
  - "INV-SC-02: Worlds MUST enumerate only candidates whose op_code exists in the runner-supplied RegistryV1; illegal candidates terminate with WorldContractViolation"
  - "INV-SC-03: Every frontier pop and every candidate decision is recorded as ExpandEventV1 + CandidateRecordV1; no silent pruning"
  - "INV-SC-04: Every candidate score carries deterministic provenance (ScoreSourceV1); learned bias is recorded, not hidden"
  - "INV-SC-05: state_fingerprint is computed from the policy-declared dedup key (DedupKeyV1) and recorded in metadata"
  - "INV-SC-06: Frontier selection order matches recorded expansion_order in the graph; no hidden decision pathway"
  - "INV-SC-07: Dead-end is tagged Exhaustive only if expansion completed without caps; BudgetLimited otherwise"
  - "INV-SC-08: Candidate enumeration uses the runner-supplied RegistryV1 snapshot only; no split-brain registry reads"
  - "INV-SC-09: node_summaries emitted in strict node_id ascending order"
  - "INV-SC-10: DedupKeyV1::FullState and PruneVisitedPolicyV1::ReleaseVisited are hard errors in M1"
  - "sterling_search depends on sterling_kernel only; it does NOT depend on sterling_harness"
  - "Neural/learned scoring is advisory only: cannot create actions, bypass legality, or suppress candidates"
acceptance:
  # --- M1: Search Core ---
  - id: SC1-M1-SEARCH-DETERMINISM-INPROC
    given: "a RomeMiniSearch world and UniformScorer"
    when: "search() is called N>=10 times in the same process"
    then: "produces identical SearchGraphV1 canonical JSON bytes every time"
  - id: SC1-M1-SEARCH-DETERMINISM-CROSSPROC
    given: "the search_fixture binary"
    when: "spawned under 4 environment variants (cwd, locale, noise, baseline)"
    then: "all output lines are identical across variants"
  - id: SC1-M1-GRAPH-IN-BUNDLE
    given: "a run_search(RomeMiniSearch) call"
    when: "the bundle is inspected"
    then: "bundle contains search_graph.json marked normative; verify_bundle() passes"
  - id: SC1-M1-GRAPH-METADATA-BINDING
    given: "a search_graph.json from run_search()"
    when: "metadata fields are inspected"
    then: "world_id, schema_descriptor, registry_digest, policy_snapshot_digest, search_policy_digest, and root_state_fingerprint match corresponding bundle artifacts"
  - id: SC1-M1-GRAPH-COMPLETENESS
    given: "a search run with N expansions"
    when: "SearchGraphV1 is inspected"
    then: "every frontier pop appears as ExpandEventV1; every generated candidate appears as CandidateRecordV1 with outcome"
  - id: SC1-M1-LOOP-DETECTION
    given: "a world whose candidate actions create a cycle"
    when: "search() is called"
    then: "terminates without infinite expansion; duplicate states recorded as DuplicateSuppressed in graph"
  - id: SC1-M1-DEAD-END-SEMANTICS
    given: "a world with states that have no valid successors"
    when: "search() expands such a node"
    then: "node tagged DeadEndReasonV1::Exhaustive; cap-limited exhaustion tagged BudgetLimited"
  - id: SC1-M1-BUDGET-EXPANSION-OVERFLOW
    given: "a search policy with max_expansions=1 and >1 reachable state"
    when: "search() is called"
    then: "termination_reason is ExpansionBudgetExceeded; graph is complete up to cutoff"
  - id: SC1-M1-CANDIDATE-LEGALITY
    given: "a world that enumerates a candidate with op_code not in the registry"
    when: "search() processes that candidate"
    then: "recorded as CandidateOutcomeV1::IllegalOperator; run terminates with WorldContractViolation"
  - id: SC1-M1-SCORE-PROVENANCE
    given: "a search run with both UniformScorer and a custom non-uniform scorer"
    when: "SearchGraphV1 CandidateRecordV1 entries are inspected"
    then: "all carry ScoreSourceV1; non-uniform scorer changes deterministic candidate order vs uniform"
  - id: SC1-M1-FRONTIER-PRUNING
    given: "a search policy with max_frontier_size < total reachable states"
    when: "frontier exceeds max"
    then: "pruned to max by total key; pruned node_ids and prune_visited_policy recorded in notes"
  - id: SC1-M1-GOAL-PATH-RECONSTRUCTION
    given: "a search run that reaches a goal"
    when: "the goal node path is reconstructed via parent_id pointers"
    then: "path from root to goal is complete and all steps correspond to Applied edges in the graph"
  - id: SC1-M1-GOV-LINT-MULTISPEC
    given: "the lint_acceptance_ids.py tool"
    when: "run on the workspace"
    then: "scans all .caws/specs/*.yaml and validates references for both SPINE-001 and SEARCH-CORE-001"
  - id: SC1-M1-RESERVED-POLICY-HARDERROR
    given: "a SearchPolicyV1 selecting DedupKeyV1::FullState or PruneVisitedPolicyV1::ReleaseVisited"
    when: "search() is called"
    then: "fails deterministically with explicit SearchError, no silent fallback"
  # --- M2: Search Hardening ---
  - id: SC1-M2-SCORER-PANIC-PRESERVES-GRAPH
    given: "a scorer that panics in score_candidates()"
    when: "search() catches the panic via catch_unwind"
    then: "returns Ok(SearchResult) with InternalPanic{ScoreCandidates} and partial graph"
  - id: SC1-M2-ENUMERATE-PANIC-PRESERVES-GRAPH
    given: "a world that panics in enumerate_candidates()"
    when: "search() catches the panic"
    then: "returns Ok with InternalPanic{EnumerateCandidates} and partial expansion event"
  - id: SC1-M2-IS-GOAL-PANIC-PRESERVES-GRAPH
    given: "a world that panics in is_goal() on root or expansion"
    when: "search() catches the panic"
    then: "returns Ok with InternalPanic{IsGoalRoot|IsGoalExpansion} and partial graph"
  - id: SC1-M2-SCORER-CONTRACT-VIOLATION-PRESERVES-GRAPH
    given: "a scorer returning wrong arity"
    when: "search() detects the mismatch"
    then: "returns Ok with ScorerContractViolation{expected,actual} and partial graph"
  - id: SC1-M2-IS-GOAL-REACHED-HELPER
    given: "SearchResult from a goal-found or non-goal search"
    when: "is_goal_reached() is called"
    then: "returns true only for GoalReached termination"
  - id: SC1-M2-PREFLIGHT-UNSUPPORTED-MODE-ERR-NO-GRAPH
    given: "a reserved policy option (FullState dedup)"
    when: "search() is called"
    then: "returns Err(UnsupportedPolicyMode) with no SearchGraphV1"
  - id: SC1-M2-TERMINATION-DETAILS-DETERMINISTIC
    given: "identical inputs producing a panic termination"
    when: "search() is called twice"
    then: "SearchGraphV1 canonical JSON bytes are identical"
  - id: SC1-M2-SEARCH-GRAPH-DIGEST-MANDATORY
    given: "a search bundle with search_graph_digest removed from report"
    when: "verify_bundle() is called"
    then: "returns SearchGraphDigestMissing error"
  - id: SC1-M2-MODE-COHERENCE-SEARCH-NO-GRAPH
    given: "mode=search in report but no search_graph.json artifact"
    when: "verify_bundle() is called"
    then: "returns SearchGraphArtifactMissing error"
  - id: SC1-M2-MODE-COHERENCE-GRAPH-NO-SEARCH
    given: "search_graph.json present but mode=linear in report"
    when: "verify_bundle() is called"
    then: "returns ModeSearchExpected error"
  - id: SC1-M2-METADATA-BINDING-POLICY-DIGEST
    given: "search_graph.json with wrong policy_snapshot_digest"
    when: "verify_bundle() is called"
    then: "returns MetadataBindingPolicyMismatch error"
  - id: SC1-M2-METADATA-BINDING-WORLD-ID
    given: "search_graph.json with wrong world_id vs report"
    when: "verify_bundle() is called"
    then: "returns MetadataBindingWorldIdMismatch error"
  - id: SC1-M2-RUN-SEARCH-GENERIC-SINGLE-WORLD
    given: "run_search generic signature"
    when: "called with a single RomeMiniSearch world"
    then: "compiles, runs, and produces valid bundle with 5 artifacts"
  - id: SC1-M2-CANDIDATE-DOMAIN-SEPARATION
    given: "identical input bytes"
    when: "hashed with DOMAIN_SEARCH_CANDIDATE vs DOMAIN_SEARCH_NODE"
    then: "produce different ContentHash values"
  - id: SC1-M2-CANDIDATE-CONSTRUCTOR-DETERMINISTIC
    given: "identical op_code and op_args"
    when: "CandidateActionV1::new() called twice"
    then: "produces identical CandidateActionV1 with matching canonical_hash"
  - id: SC1-M2-PANIC-PROFILE-UNWIND-ENFORCED
    given: "workspace compiled with dev or release profile"
    when: "std::panic::catch_unwind is called around a panic!()"
    then: "the panic is caught (not aborted)"
  - id: SC1-M2-WORLD-CONTRACT-VIOLATION-RETURNS-OK
    given: "a world enumerating an illegal candidate"
    when: "search() processes it"
    then: "returns Ok with WorldContractViolation termination and partial graph (not Err)"
acceptance_criteria: []
non_functional:
  perf:
    search_1000_nodes_p95_ms: 500
  security:
    - "search crate has zero harness dependencies"
    - "no HashMap iteration in ordering-sensitive paths"
contracts:
  - type: architecture
    path: .claude/plans/snappy-booping-mccarthy.md
    description: "SEARCH-CORE-001 M1 implementation plan with type definitions, invariants, and execution order"
  - type: architecture
    path: .claude/plans/scalable-petting-sloth.md
    description: "SEARCH-CORE-001 M2 hardening plan: evidence preservation, symmetric verification, generic wiring, canonicalization"
out_of_contract:
  - "Evidence preservation guarantees exclude process-level abort classes: OOM abort, explicit std::process::abort(), external SIGKILL, panic=abort profile override"
  - "catch_unwind depends on panic=unwind; workspace Cargo.toml pins this for dev and release profiles"
milestones:
  - id: M1
    title: "Search Core: frontier, graph, scorer, best-first loop"
    status: complete
    evidence:
      total_tests: 281
      new_tests: 39
      acceptance_ids_anchored: 14
      commits:
        - "ac7b482 feat(search): add sterling_search crate with core search types, frontier, graph, and search loop [SEARCH-CORE-001]"
        - "2402cd7 feat(harness): integrate search into runner and bundle pipeline [SEARCH-CORE-001]"
        - "65392ac test(lock): add SEARCH-CORE-001 lock tests and cross-proc fixture [SEARCH-CORE-001]"
      crates_added:
        - "sterling_search (depends on sterling_kernel only)"
      files_created:
        - "search/Cargo.toml"
        - "search/src/lib.rs"
        - "search/src/node.rs"
        - "search/src/frontier.rs"
        - "search/src/scorer.rs"
        - "search/src/graph.rs"
        - "search/src/policy.rs"
        - "search/src/search.rs"
        - "search/src/contract.rs"
        - "search/src/error.rs"
        - "harness/src/worlds/rome_mini_search.rs"
        - "tests/lock/tests/sc1_search_determinism.rs"
        - "tests/lock/tests/sc1_crossproc.rs"
        - "tests/lock/src/bin/search_fixture.rs"
    deliverables:
      - "sterling_search crate (depends on sterling_kernel only)"
      - "SearchNodeV1, CandidateActionV1 core types with deterministic ordering"
      - "CandidateScoreV1 + ScoreSourceV1 provenance types"
      - "ValueScorer trait + UniformScorer default"
      - "SearchWorldV1 trait (extends WorldHarnessV1)"
      - "BestFirstFrontier with BTreeSet-based visited set and dead-end tracking"
      - "search() entry point with budget enforcement and termination reasons"
      - "SearchGraphV1 expansion-event log with canonical JSON serialization"
      - "SearchPolicyV1 with DedupKeyV1 and PruneVisitedPolicyV1"
      - "Reserved policy options (FullState, ReleaseVisited) fail as hard errors"
      - "RomeMiniSearch test world with deterministic candidate enumeration"
      - "run_search() harness integration with search_graph.json bundle artifact"
      - "Verification extended with search graph digest + metadata binding"
      - "Lock tests: determinism (in-proc N=10), cross-proc (4 variants), graph completeness"
      - "Edge-case tests: loop detection, dead-end semantics, budget overflow, legality, pruning, provenance"
      - "Multi-spec acceptance lint (tools/lint_acceptance_ids.py)"
  - id: M2
    title: "Search Hardening: evidence preservation, symmetric verification, generic wiring, canonicalization"
    status: complete
    evidence:
      total_tests: 299
      new_tests: 18
      acceptance_ids_anchored: 17
      commits:
        - "67522e4 feat(search): centralize CandidateAction canonicalization with domain separation [SEARCH-CORE-001]"
        - "61eaa20 feat(search): evidence preservation — always return SearchGraphV1 [SEARCH-CORE-001]"
        - "2fe17ff chore(build): pin panic=unwind in workspace profiles [SEARCH-CORE-001]"
        - "0f4083a feat(harness): generic run_search with world_id coherence check [SEARCH-CORE-001]"
        - "f9be262 feat(harness): symmetric bundle verification with closed bindings [SEARCH-CORE-001]"
        - "68a3bc7 test(lock): add SEARCH-CORE-001 M2 hardening lock tests [SEARCH-CORE-001]"
      files_created:
        - "tests/lock/tests/sc1_m2_hardening.rs"
      files_modified:
        - "search/src/node.rs"
        - "search/src/error.rs"
        - "search/src/graph.rs"
        - "search/src/search.rs"
        - "search/src/scorer.rs"
        - "harness/src/bundle.rs"
        - "harness/src/runner.rs"
        - "harness/src/worlds/rome_mini_search.rs"
        - "tests/lock/tests/sc1_search_determinism.rs"
        - "tests/lock/src/bin/search_fixture.rs"
        - "Cargo.toml"
    deliverables:
      - "Evidence preservation: search() always returns Ok(SearchResult) with SearchGraphV1 for all runtime terminations"
      - "catch_unwind on world.enumerate_candidates(), world.is_goal(), scorer.score_candidates()"
      - "TerminationReasonV1 new variants: ScorerContractViolation, InternalPanic, FrontierInvariantViolation"
      - "PanicStageV1 enum: EnumerateCandidates, ScoreCandidates, IsGoalRoot, IsGoalExpansion"
      - "SearchError reduced to UnsupportedPolicyMode only (pre-flight refusal)"
      - "WorldContractViolation now returns Ok with partial graph instead of Err"
      - "Generic run_search<W: SearchWorldV1 + WorldHarnessV1> (no split-brain)"
      - "World ID coherence check at run_search entry"
      - "DOMAIN_SEARCH_CANDIDATE domain separation from DOMAIN_SEARCH_NODE"
      - "CandidateActionV1::new() constructor with pub(crate) canonical_hash"
      - "Mandatory search_graph_digest in bundle verification"
      - "Mode↔artifact coherence: bidirectional enforcement"
      - "MetadataBindings cross-verification: policy_snapshot_digest and world_id"
      - "Workspace panic=unwind pinned in dev and release profiles"
