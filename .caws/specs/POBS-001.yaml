id: POBS-001
type: feature
title: 'Partial Observability World + Winning-Path Witness'
status: closed
risk_tier: 2
mode: development
created_at: '2026-03-01T00:00:00.000Z'
updated_at: '2026-03-01T00:00:00.000Z'
blast_radius:
  modules:
    - kernel/operators
    - harness/worlds
    - harness/bundle
    - harness/runner
    - harness/witness
    - search/search
    - tests/lock
  data_migration: false
operational_rollback_slo: 15m

purpose: >
  Introduce an epistemic truth regime — hidden truth + observable-only via
  environment-provided feedback + mechanically-checkable belief monotonicity —
  and the generic winning-path replay witness that proves correspondence for
  downstream derived artifacts.

  Phase 1b forces two things simultaneously:
  (1) A world where the agent's accessible state never contains the truth
  directly, each guess elicits environment feedback that monotonically shrinks
  an implicit belief set, and declaring a solution requires epistemic
  justification. This is the simplest world where coherence does not imply
  correspondence.
  (2) A reusable Cert-only winning-path replay primitive that generalizes
  beyond this world. The replay walks the goal path, re-applies operators from
  compiled root state, verifies fingerprints at each step, and checks
  world-specific invariants (belief monotonicity, feedback correctness) on
  intermediate states.

  TOOLSCRIPT-001 established the downstream binding convention: derived
  artifacts bind via digest basis (normative artifact) + report convenience
  field + Cert equivalence render. Phase 1b reuses that convention for the
  epistemic transcript and adds replay as a second correspondence proof
  (stronger than render-only equivalence because it re-executes operators and
  checks intermediate states).

depends_on:
  - "TOOLSCRIPT-001: evidence_obligations surface, downstream binding convention, derived artifact pattern."
  - "CREPLAY-001: compilation replay gives verified root state for winning-path replay input."
  - "BIND-001: corridor binding conventions (upstream 3-point vs downstream report-only)."

non_goals:
  - "No stochastic evidence (seed/witness binding) — that's Phase 1c."
  - "No induction or memory systems."
  - "No changes to compile() semantics or CompilationResultV1."
  - "No large belief spaces — a 9-64 candidate space is sufficient to prove the regime."
  - "No multi-tool or tool-safety interactions — this world does not use STAGE/COMMIT/ROLLBACK."
  - "No changes to existing worlds — backward compatibility required."
  - "No partial observability over stochastic outcomes — deterministic feedback only."
  - "No changes to SearchGraphV1 schema version — additive fields only (ADR 0008)."
  - "No kernel-embedded world semantics — kernel bounds write surfaces only, never computes truth-dependent values."

design:
  # ---------------------------------------------------------------------------
  # Authority boundary: kernel vs world vs verifier
  # ---------------------------------------------------------------------------
  authority_boundary: >
    The kernel MUST NOT compute truth-dependent values. Kernel operators are
    bounded-write primitives: they write specified values to specified slots.
    The kernel validates the write surface (diff counts, layer constraints,
    Hole→Provisional transitions). It never reads truth to determine what
    to write.

    The world/harness computes truth-dependent values (probe feedback) and
    emits them as candidate actions. The world has harness privilege: it can
    read the full ByteState (including truth layer 0) to compute correct
    feedback. But the kernel dispatch handler for the operator just performs
    the write — it doesn't know or care whether the value is correct.

    The verifier proves correspondence: winning-path replay re-executes the
    operator sequence from compiled root state, independently recomputes
    expected feedback from (truth, guess), and verifies the written value
    matches. This is where semantic correctness is certified.

    Division:
    - Kernel: "these writes are structurally legal" (surface bounds)
    - World: "these are the correct values to write" (truth-dependent computation)
    - Verifier: "these values are provably correct" (replay certification)

  # ---------------------------------------------------------------------------
  # World design: Mastermind-style hidden-truth + guess/feedback + declare
  # ---------------------------------------------------------------------------
  world_model: >
    A Mastermind-style toy world with a small hidden code and deterministic
    feedback. The harness knows the truth; the search agent can only observe
    it through environment-provided feedback in response to guesses.

    ByteState layout (2 layers):
    - Layer 0 (truth): hidden code. Written at compile time via the payload.
      All slots start Provisional (not Hole) so no operator can write to them
      (Provisional→Provisional is EffectContractViolation). No operator
      targets layer 0. The truth is readable by the harness for computing
      feedback, and by the verifier during replay, but no operator exposes
      it to the agent's workspace.
    - Layer 1 (workspace): partitioned into:
      (a) guess slots — K slots per probe, recording what the agent guessed
          (written by OP_GUESS)
      (b) feedback slots — 1 slot per probe, recording the environment's
          response (written by OP_FEEDBACK)
      (c) solved_marker slot — set by OP_DECLARE when solution declared

    Probe cycle (two-step):
    1. Agent turn: enumerate_candidates emits OP_GUESS candidates. Agent
       chooses a guess. OP_GUESS writes the guess values to the next
       available guess slots on layer 1.
    2. Environment turn: enumerate_candidates detects that a guess was written
       but feedback is absent for that probe index. It emits a single
       OP_FEEDBACK candidate with the correct feedback computed from
       (truth, guess). OP_FEEDBACK writes the feedback to the corresponding
       feedback slot.
    3. Repeat until belief uniquely determines truth, then OP_DECLARE.

    The interleaving is a state machine: the world checks which probe index
    has a guess but no feedback, and emits the appropriate operator type.
    The kernel sees only bounded writes; it does not know about "turns."

  truth_encoding: >
    The hidden code is a sequence of K positions, each drawn from V possible
    values. Encoded as K slots on layer 0, each containing a concept Code32
    from domain 3 (e.g., code:c0..code:c(V-1)). The candidate space is V^K.

    Minimal configuration: K=2 positions, V=3 values → 9 candidates. This is
    enough to exercise nontrivial monotonic elimination (probes reduce from 9
    toward 1) without bloating ByteState.

    Scaling configuration: K=3, V=4 → 64 candidates. Available for stress
    tests but not required for correctness.

  belief_representation: >
    Belief is fully implicit: NOT stored in ByteState. The combination of
    accumulated (guess, feedback) pairs on layer 1 determines which candidates
    are consistent with all observations. The actual belief set and its
    cardinality are reconstructable from the probe history, which is exactly
    what winning-path replay does.

    No belief_size slot in ByteState. Belief evolution (cardinality at each
    step) appears only in the epistemic transcript, computed during replay
    from intermediate states.

    This keeps ByteState minimal and avoids the codebook problem of encoding
    arbitrary integers as Code32 symbols. Monotonicity is verified by the
    replay invariant checker operating on the reconstructed belief sets,
    not on state slots.

  workspace_layout: >
    Layer 1 slot allocation for K=2, max P probes:

    Slots 0..K-1:           guess slots for probe 0 (K=2: slots 0,1)
    Slot K:                 feedback slot for probe 0 (K=2: slot 2)
    Slots K+1..2K:          guess slots for probe 1 (K=2: slots 3,4)
    Slot 2K+1:              feedback slot for probe 1 (K=2: slot 5)
    ...
    Slot P*(K+1)..P*(K+1)+K-1: guess slots for probe P-1
    Slot P*(K+1)+K-1:       feedback slot for probe P-1
    Last slot:              solved_marker

    Each probe occupies K+1 slots (K guess + 1 feedback). With K=2, V=3,
    and max P=4 probes (sufficient to solve any 2-position, 3-value code),
    layer 1 needs 4*(2+1)+1 = 13 slots. Total ByteState: 2 layers × 13 slots
    = 26 Code32 entries = 130 bytes identity + 26 bytes status.

    For K=2, V=3: worst case is 4 probes to uniquely determine 9 candidates.
    This is conservative — many truth values can be determined in 2-3 probes.

  probe_feedback: >
    Feedback is deterministic: given a guess (K values) and the truth (K values),
    exact_matches = count of positions where guess[i] == truth[i].

    Mastermind Bulls-only variant: only exact positional matches count.
    No "cows" (right value, wrong position). This keeps feedback as a single
    integer (0..K) encoded as a Code32 (domain 3, kind 2, local_id = count).

    The world computes feedback in enumerate_candidates when generating the
    OP_FEEDBACK candidate. The kernel dispatch handler for OP_FEEDBACK just
    writes the value — it does not compute it. The verifier independently
    recomputes the expected feedback during replay and verifies it matches
    what was written.

  # ---------------------------------------------------------------------------
  # Operators
  # ---------------------------------------------------------------------------
  new_operators:
    OP_GUESS:
      code: "Code32::new(1, 2, 1) — domain 1 (operators), kind 2 (epistemic), local_id 1"
      args: >
        K guess values as Code32 (4 bytes each) = 4*K bytes.
        For K=2: 8 bytes (2 arg slots).
      effect: >
        Writes K slots on layer 1: the guess values for the current probe
        index. All K slots must be Hole → Provisional (write-once).
      effect_kind: "WritesGuess"
      semantics: >
        Agent submits a guess. This is an agent action — it does not produce
        feedback. The world will respond with OP_FEEDBACK on the next
        expansion cycle.

    OP_FEEDBACK:
      code: "Code32::new(1, 2, 2) — domain 1 (operators), kind 2 (epistemic), local_id 2"
      args: >
        1 feedback value as Code32 (4 bytes). The exact_match count encoded
        as domain 3, kind 2, local_id = count.
      effect: >
        Writes 1 slot on layer 1: the feedback slot for the current probe
        index. Slot must be Hole → Provisional (write-once).
      effect_kind: "WritesFeedback"
      semantics: >
        Environment provides feedback in response to the most recent guess.
        The feedback value is computed by the world/harness (which has truth
        access) and emitted as a candidate action. The kernel does not compute
        feedback — it just writes the value. Semantic correctness is verified
        by winning-path replay.

    OP_DECLARE:
      code: "Code32::new(1, 2, 3) — domain 1, kind 2, local_id 3"
      args: >
        K values as Code32 (4 bytes each) — the declared solution.
        Same format as OP_GUESS args.
      effect: >
        Writes 1 slot on layer 1: solved_marker slot.
        Value is a SOLVED concept (domain 3, kind 3, local_id 0).
        Slot must be Hole → Provisional (write-once, so only one declaration
        per episode).
      effect_kind: "DeclaresSolution"
      semantics: >
        Declares a solution. The goal is defined on solved_marker being set
        AND the declared solution matching truth. Whether the declaration is
        correct is checked by is_goal() (which reads layer 0) and verified
        independently by winning-path replay.

  new_effect_kinds:
    validation_constraints: >
      Each EffectKind validates using ONLY pre-state bytes, post-state bytes,
      operator args, and schema-known slot locations. No world context, no
      truth access, no semantic interpretation. The kernel bounds write
      surfaces; it does not compute truth-dependent values.

    WritesGuess: >
      Validates: exactly K identity diffs and K status diffs, all on layer 1,
      all in the guess slot region for the current probe index. All transitions
      must be Hole→Provisional. No writes to layer 0. K is determined from
      arg length (arg_byte_count / 4).

    WritesFeedback: >
      Validates: exactly 1 identity diff and 1 status diff on layer 1, in the
      feedback slot region. Transition must be Hole→Provisional. No writes to
      layer 0. The kernel does NOT validate the feedback value against truth —
      that is the verifier's job.

    DeclaresSolution: >
      Validates: exactly 1 identity diff and 1 status diff on layer 1. The
      diff must be on the solved_marker slot. Hole→Provisional. No writes to
      layer 0. The kernel does NOT validate whether the declared solution
      matches truth — that is the verifier's job.

  # ---------------------------------------------------------------------------
  # Winning-path replay (reusable primitive)
  # ---------------------------------------------------------------------------
  witness_architecture: >
    The winning-path replay is the key new verifier capability. It generalizes
    beyond this world — any future world can opt into it via evidence obligations.

    Replay is Cert-only, gated by evidence_obligations containing
    "winning_path_replay_v1". The replay facility lives in harness/ (verifier
    side), not search/ (recording side).

    Inputs (all from bundle, no out-of-band access):
    - Compiled root ByteState (from CREPLAY-001 — compilation replay already
      gives a verified root state in Cert)
    - SearchTape (to reconstruct goal path edges: parent_id chain + applied
      candidate op_code/op_args)
    - OperatorRegistryV1 (already verified by Steps 16-17)
    - World-specific invariant checker (trait callback)

    Procedure:
    1. Extract goal_node_id from tape termination record (GoalReached).
       If no goal reached, skip replay (Ok).
    2. Reconstruct goal path node chain via NodeCreation parent_id, walking
       backwards from goal to root. Reverse to get root→goal order.
    3. For each edge (path[i] → path[i+1]):
       a. Find the Expansion record where node_id == path[i].
       b. Within that expansion's candidates, find the unique candidate with
          outcome Applied { to_node: path[i+1] }.
       c. If 0 matching candidates: fail with ReplayEdgeMissing.
       d. If >1 matching candidates: fail with ReplayEdgeAmbiguous.
       e. Extract (op_code, op_args) from the unique matching candidate.
    4. Starting from compiled root ByteState, for each edge in order:
       a. Save pre_state = current_state.clone().
       b. Call kernel apply(current_state, op_code, op_args, registry).
       c. If apply fails: fail with ReplayApplyFailed.
       d. Compute state fingerprint of the resulting state.
       e. Compare to the tape's NodeCreation state_fingerprint for path[i+1].
          Mismatch → ReplayFingerprintMismatch.
       f. Invoke invariant checker: check(step_index, &pre_state, &current_state,
          op_code, &op_args). Checker returns Ok or a typed violation.
    5. After all steps, verify the final state fingerprint matches the goal
       node's fingerprint.

    Edge uniqueness contract: for each parent→child pair on the winning path,
    there must be exactly one Applied candidate in the parent's expansion that
    produced the child. This is a structural property of the search algorithm
    (each node is created exactly once). The replay fails with typed errors
    for 0 or >1 matches, which catches tape corruption or algorithm bugs.

  # ---------------------------------------------------------------------------
  # Invariant checker for this world
  # ---------------------------------------------------------------------------
  invariant_checker: >
    The partial observability world provides a ReplayInvariantChecker that
    verifies the following at each step on the winning path:

    1. No writes to layer 0 (truth). Comparison: pre_state.identity_bytes()
       and post_state.identity_bytes() must be identical for layer 0 slots.
       This is belt-and-suspenders with kernel effect validation.

    2. Feedback correctness (OP_FEEDBACK steps only): read the guess values
       from the current state (written by the preceding OP_GUESS), read the
       truth from layer 0 of the current state, compute expected feedback
       (exact_match count), and verify the written feedback slot matches.
       This is the semantic check the kernel cannot do.

    3. Belief monotonicity: after each OP_FEEDBACK step, reconstruct the
       belief set (all codes consistent with all guesses + feedback so far)
       and verify cardinality is ≤ the previous cardinality. At least one
       OP_FEEDBACK must strictly decrease cardinality (no degenerate fixtures).

    4. Declare correctness (OP_DECLARE steps only): read the declared solution
       from op_args, read truth from layer 0, verify they match.

    The checker accumulates the belief set cardinality history for the
    epistemic transcript.

  # ---------------------------------------------------------------------------
  # Derived artifact: epistemic transcript
  # ---------------------------------------------------------------------------
  epistemic_transcript_artifact:
    name: "epistemic_transcript.json"
    kind: "required derived artifact (downstream, same convention as tool_transcript.json)"
    schema: >
      Canonical JSON object:
      - "schema_version": "epistemic_transcript.v1"
      - "world_id": string
      - "code_length": integer (K)
      - "value_count": integer (V)
      - "candidate_space_size": integer (V^K)
      - "entries": array of transcript entries, each with:
        - "step_index": integer (position in winning-path edge sequence)
        - "operator": string ("GUESS", "FEEDBACK", or "DECLARE")
        - "op_code": [d, k, lo, hi]
        - "args": structured (operator-specific)
        - "outcome": "applied"
        - For GUESS: "guess": [c0, c1, ...] (the K values)
        - For FEEDBACK: "exact_matches": integer, "belief_size_before": integer,
          "belief_size_after": integer
        - For DECLARE: "declared_solution": [c0, c1, ...], "correct": boolean
      - "entry_count": integer
      - "final_belief_size": integer
      - "solved": boolean
      - "probe_count": integer (number of completed guess+feedback pairs)

    rendering: >
      The transcript is rendered as a replay visitor. The invariant checker
      accumulates transcript entries as it processes each step. After replay
      completes, the accumulated entries are serialized as canonical JSON.

      Inputs (pure function of bundle contents, no out-of-band access):
      - Compiled root state (truth is in layer 0)
      - Op sequence from tape (goal path edges)
      - Operator registry
      - World parameters K, V (from fixture.json or world_id parsing)

      The transcript renderer IS the invariant checker (or wraps it). It
      receives intermediate states from the replay, computes belief evolution,
      and accumulates entries. This is not a separate tape scan.

    binding_convention: >
      Downstream binding (same as tool_transcript.json):
      - Normative artifact in digest basis (Steps 4-6)
      - Report convenience field: epistemic_transcript_digest (sha256:hex)
      - NOT in graph metadata or tape header (downstream of tape)
      - Cert: equivalence render via replay (stronger than render-only)
      - Base: required-if-present digest binding

  # ---------------------------------------------------------------------------
  # Evidence obligations
  # ---------------------------------------------------------------------------
  evidence_obligations: >
    The partial observability world declares two obligations:
    - "epistemic_transcript_v1": derived artifact with Cert equivalence
    - "winning_path_replay_v1": Cert-only verifier gate (replay must succeed)

    These are independent obligations. A future world could declare replay
    without a transcript, or transcript without replay (if render-only
    equivalence is sufficient, as with tool_transcript).

    The obligations surface (FixtureDimensions.evidence_obligations) is
    reused from TOOLSCRIPT-001. No schema changes needed.

  # ---------------------------------------------------------------------------
  # Architectural division
  # ---------------------------------------------------------------------------
  validation_philosophy: >
    Kernel's job: bound the write surface. OP_GUESS writes K slots on layer 1.
    OP_FEEDBACK writes 1 slot on layer 1. OP_DECLARE writes 1 slot on layer 1.
    No operator writes to layer 0. The kernel enforces this via EffectKind
    validation (diff counting, layer checks, Hole→Provisional). Cheap,
    O(layer_count * slot_count) per apply.

    Kernel MUST NOT: read truth from layer 0 to compute values. The dispatch
    handlers for OP_GUESS, OP_FEEDBACK, and OP_DECLARE are bounded-write
    primitives. They write the values specified in op_args to the slots
    specified by the operator's layout. They do not consult other layers
    or compute truth-dependent feedback.

    World's job: compute correct values. enumerate_candidates() reads the
    full ByteState (harness privilege, including truth on layer 0) and emits
    candidates with the correct feedback values. The world is trusted to
    produce correct candidates during search execution.

    Verifier's job: prove the world was honest. Winning-path replay
    independently recomputes expected feedback from (truth, guess) at each
    step and verifies the written values match. This is where semantic
    correctness is certified — not by kernel dispatch, not by trusting
    the world, but by replay from the authoritative trace.

  backward_compatibility: >
    Existing worlds have evidence_obligations: [] (default). They do not
    produce epistemic_transcript.json. They do not opt into winning-path
    replay. verify_bundle() new steps are skipped when obligations are absent.
    No regressions.

scope:
  in:
    - kernel/src/operators/apply.rs
    - kernel/src/operators/operator_registry.rs
    - harness/src/worlds/
    - harness/src/bundle.rs
    - harness/src/runner.rs
    - harness/src/witness.rs
    - harness/src/transcript.rs
    - harness/src/contract.rs
    - search/src/search.rs
    - tests/lock/
    - .caws/specs/
  out:
    - kernel/src/carrier/compile.rs
    - kernel/src/carrier/bytestate.rs
    - kernel/src/carrier/bytetrace.rs
    - kernel/src/carrier/trace_writer.rs
    - kernel/src/carrier/trace_reader.rs
    - kernel/src/proof/replay.rs
    - benchmarks/
    - docs/

change_budget:
  max_files: 30
  max_loc: 2500

invariants:
  - >-
    INV-POBS-01: No operator writes to layer 0 (truth layer). Layer 0 slots
    are Provisional after compilation; any attempt to write triggers
    EffectContractViolation (Provisional→Provisional). Verified by kernel
    effect validation AND by winning-path replay invariant checker.
  - >-
    INV-POBS-02: Belief cardinality (computed from probe history, not stored
    in state) is non-increasing step-to-step across the winning path. At
    least one OP_FEEDBACK step must strictly decrease it. Verified by
    winning-path replay invariant checker.
  - >-
    INV-POBS-03: OP_FEEDBACK value is semantically correct: the exact_match
    count matches the independently recomputed count from (guess, truth).
    Verified by winning-path replay, NOT by kernel effect validation.
    The kernel does not read truth.
  - >-
    INV-POBS-04: OP_DECLARE solution matches truth (layer 0). Verified by
    winning-path replay and by harness is_goal().
  - >-
    INV-POBS-05: Winning-path replay reproduces exact state fingerprints
    for every goal-path node. Compiled root state → sequential apply →
    fingerprint match at each step.
  - >-
    INV-POBS-06: Each edge on the winning path has exactly one Applied
    candidate in the parent's expansion that produced the child node. 0 or
    >1 matches are typed replay errors. No ambiguous edges.
  - >-
    INV-POBS-07: epistemic_transcript.json bytes equal independently rendered
    transcript bytes (Cert equivalence, downstream binding convention).
    Transcript is rendered via replay visitor, not independent tape scan.
  - >-
    INV-POBS-08: Existing worlds with evidence_obligations: [] continue to
    build and verify without changes. No regressions.
  - >-
    INV-POBS-09: Winning-path replay is a reusable primitive gated by
    "winning_path_replay_v1" obligation. It is not world-specific (the world
    provides an invariant checker callback, but the replay machinery is
    generic).
  - >-
    INV-POBS-10: Kernel dispatch handlers for OP_GUESS, OP_FEEDBACK, and
    OP_DECLARE do not read layer 0 truth. They are bounded-write primitives
    that write values from op_args to slots determined by operator layout.
    Truth-dependent computation is world-side (enumerate_candidates) and
    verifier-side (replay).

errors:
  - id: POBS-ERR-REPLAY-FINGERPRINT
    variant: "ReplayFingerprintMismatch { step_index: usize, expected: String, actual: String }"
    description: >-
      Winning-path replay: the state fingerprint after applying op at step_index
      does not match the tape's NodeCreation fingerprint for the child node.

  - id: POBS-ERR-REPLAY-APPLY-FAILED
    variant: "ReplayApplyFailed { step_index: usize, detail: String }"
    description: >-
      Winning-path replay: kernel apply() failed when re-executing an operator
      on the winning path.

  - id: POBS-ERR-REPLAY-EDGE-MISSING
    variant: "ReplayEdgeMissing { parent_node: u64, child_node: u64 }"
    description: >-
      Winning-path replay: no Applied candidate in the parent's expansion
      produces the expected child node. Tape corruption or algorithm bug.

  - id: POBS-ERR-REPLAY-EDGE-AMBIGUOUS
    variant: "ReplayEdgeAmbiguous { parent_node: u64, child_node: u64, count: usize }"
    description: >-
      Winning-path replay: more than one Applied candidate in the parent's
      expansion produces the same child node. Structural invariant violation.

  - id: POBS-ERR-BELIEF-MONOTONICITY
    variant: "BeliefMonotonicityViolation { step_index: usize, before: usize, after: usize }"
    description: >-
      Winning-path replay invariant: belief cardinality increased after a
      feedback step. Computed from reconstructed belief set, not from state.

  - id: POBS-ERR-FEEDBACK-INCORRECT
    variant: "FeedbackIncorrect { step_index: usize, expected_matches: usize, actual_matches: usize }"
    description: >-
      Winning-path replay invariant: OP_FEEDBACK value does not match
      independently recomputed feedback from (guess, truth).

  - id: POBS-ERR-DECLARE-MISMATCH
    variant: "DeclareSolutionMismatch { step_index: usize, declared: String, truth: String }"
    description: >-
      Winning-path replay invariant: OP_DECLARE solution does not match truth.

  - id: POBS-ERR-TRUTH-WRITE
    variant: "TruthLayerWriteAttempt { step_index: usize, detail: String }"
    description: >-
      Winning-path replay invariant: an operator modified layer 0 bytes.
      Belt-and-suspenders with kernel EffectKind validation.

  - id: POBS-ERR-TRANSCRIPT-MISSING
    variant: "EpistemicTranscriptMissing"
    description: >-
      Cert: evidence_obligations includes "epistemic_transcript_v1" but
      epistemic_transcript.json is absent from the bundle.

  - id: POBS-ERR-TRANSCRIPT-EQUIVALENCE
    variant: "EpistemicTranscriptEquivalenceMismatch { expected_hash: String, rendered_hash: String }"
    description: >-
      Cert: independently rendered epistemic transcript does not byte-match
      the shipped artifact.

  - id: POBS-ERR-NO-STRICT-DECREASE
    variant: "NoStrictBeliefDecrease"
    description: >-
      Cert replay invariant: no OP_FEEDBACK step in the winning path strictly
      decreased belief cardinality. Catches degenerate fixtures.

acceptance:
  - id: POBS-001-KERNEL-OPS
    description: >-
      OP_GUESS, OP_FEEDBACK, OP_DECLARE exist in kernel with distinct Code32
      IDs (domain 1, kind 2), EffectKind variants (WritesGuess, WritesFeedback,
      DeclaresSolution), dispatch handlers, and effect validation. All go
      through three-phase apply() check. No dispatch handler reads layer 0
      or computes truth-dependent values.
    status: met

  - id: POBS-001-EFFECT-KINDS
    description: >-
      WritesGuess validates exactly K identity diffs + K status diffs on
      layer 1 only (K from arg length). WritesFeedback validates exactly 1
      diff on layer 1. DeclaresSolution validates exactly 1 diff on layer 1.
      Negative tests: write to layer 0, wrong diff count, wrong slot region.
    status: met

  - id: POBS-001-WORLD
    description: >-
      Partial observability world (Mastermind-style) with K=2, V=3 (9
      candidates). Two-step probe cycle: OP_GUESS (agent) then OP_FEEDBACK
      (environment). OP_DECLARE when belief uniquely determines truth.
      evidence_obligations includes "epistemic_transcript_v1" and
      "winning_path_replay_v1".
    status: met

  - id: POBS-001-TRUTH-HIDDEN
    description: >-
      No operator targets layer 0. Layer 0 slots are Provisional after
      compilation. Kernel rejects any write (EffectContractViolation).
      No dispatch handler reads layer 0. World computes truth-dependent
      feedback in enumerate_candidates (harness privilege), not kernel.
    status: met

  - id: POBS-001-TWO-STEP-PROBE
    description: >-
      Probe is two-step: OP_GUESS writes guess to workspace, then OP_FEEDBACK
      writes environment-computed feedback. The world's enumerate_candidates
      implements the state machine: detects which probe index has guess but
      no feedback and emits the appropriate operator. Kernel sees only
      bounded writes.
    status: met

  - id: POBS-001-BELIEF-MONOTONICITY
    description: >-
      Belief cardinality (reconstructed from probe history, not stored in
      state) is non-increasing across the winning path. At least one
      OP_FEEDBACK strictly decreases it. Verified by replay invariant
      checker.
    status: met

  - id: POBS-001-FEEDBACK-CORRECTNESS
    description: >-
      OP_FEEDBACK value is semantically correct: exact_match count matches
      independently recomputed count from (guess, truth). Verified by
      replay, not kernel. Kernel does not read truth.
    status: met

  - id: POBS-001-DECLARE-CORRECTNESS
    description: >-
      OP_DECLARE solution matches truth. Verified by replay and is_goal().
    status: met

  - id: POBS-001-REPLAY-GENERIC
    description: >-
      Winning-path replay is a generic facility in harness/src/witness.rs.
      Accepts a ReplayInvariantChecker trait. Any world can opt in via
      "winning_path_replay_v1" obligation. Not world-specific.
    status: met

  - id: POBS-001-REPLAY-FINGERPRINTS
    description: >-
      Replay reproduces exact state fingerprints at every step on the winning
      path. Compiled root state → sequential apply → fingerprint match.
    status: met

  - id: POBS-001-REPLAY-EDGE-UNIQUENESS
    description: >-
      For each parent→child pair on the winning path, exactly one Applied
      candidate in the parent's expansion produced the child. 0 matches →
      ReplayEdgeMissing. >1 matches → ReplayEdgeAmbiguous.
    status: met

  - id: POBS-001-TRANSCRIPT
    description: >-
      epistemic_transcript.json rendered via replay visitor (not independent
      tape scan). Downstream binding: normative artifact + report digest +
      Cert equivalence. NOT in graph metadata or tape header. Belief
      evolution appears in transcript only (not in ByteState).
    status: met

  - id: POBS-001-BACKWARD-COMPAT
    description: >-
      Non-epistemic worlds unaffected. evidence_obligations defaults to empty.
      New verification steps skipped. No regressions.
    status: met

  - id: POBS-001-LOCK-TESTS
    description: >-
      Lock tests: two-step probe cycle works, belief decreases, declare
      matches truth, replay succeeds (Cert), forged transcript fails Cert,
      illegal truth write rejected, feedback incorrectness detected by
      replay, belief monotonicity violation detected, edge ambiguity
      detected, backward compat.
    status: met

milestones:
  - id: M0
    title: "Spec finalization + schema layout"
    status: complete
    deliverables:
      - "POBS-001.yaml: finalized spec with authority boundary, two-step probe, implicit belief"
      - "ByteState layout: 2 layers, K truth slots (Provisional), P*(K+1)+1 workspace slots"
      - "Evidence obligations: epistemic_transcript_v1, winning_path_replay_v1"
    notes:
      - "K=2, V=3 as default configuration (9 candidates)"
      - "Layer 0 (truth): K=2 slots, Provisional after compile"
      - "Layer 1 (workspace): guess + feedback slots per probe + solved_marker"
      - "No belief_size in state — belief is implicit, computed during replay"

  - id: M1
    title: "Kernel operators: OP_GUESS, OP_FEEDBACK, OP_DECLARE"
    status: complete
    deliverables:
      - "kernel/src/operators/apply.rs: OP_GUESS, OP_FEEDBACK, OP_DECLARE constants + dispatch + handlers"
      - "kernel/src/operators/apply.rs: guess_args(), feedback_args(), declare_args() builders"
      - "kernel/src/operators/operator_registry.rs: WritesGuess, WritesFeedback, DeclaresSolution EffectKind"
      - "kernel_operator_registry() includes 7 operators (SET_SLOT, STAGE, COMMIT, ROLLBACK, GUESS, FEEDBACK, DECLARE)"
      - "Unit tests: effect validation, arg parsing, negative tests (wrong layer, wrong diff count)"
    notes:
      - "Dispatch handlers are bounded-write primitives — they do NOT read layer 0"
      - "OP_GUESS handler: writes K values from args to guess slots on layer 1"
      - "OP_FEEDBACK handler: writes 1 value from args to feedback slot on layer 1"
      - "OP_DECLARE handler: writes SOLVED marker to solved_marker slot on layer 1"
      - "All validation: diff counting + layer constraints + Hole→Provisional"
      - "Kernel never computes truth-dependent values"

  - id: M2
    title: "Partial observability world"
    status: complete
    deliverables:
      - "harness/src/worlds/partial_obs.rs: world struct + WorldHarnessV1 + SearchWorldV1"
      - "harness/src/worlds/mod.rs: pub mod partial_obs"
      - "Concept registry entries: code:c0..c2, feedback:0..2, solved:yes, operator codes"
      - "enumerate_candidates: two-step state machine (guess turn vs feedback turn)"
      - "is_goal: solved_marker set AND declared solution matches truth"
      - "Unit tests: compile, enumerate, is_goal, evidence_obligations, probe cycle"
    notes:
      - "World computes feedback in enumerate_candidates (harness privilege, reads layer 0)"
      - "Kernel dispatch does NOT compute feedback — world provides correct values as candidates"
      - "enumerate_candidates state machine: check which probe index has guess but no feedback"
      - "OP_DECLARE only emitted when belief uniquely determines truth"
      - "evidence_obligations: ['epistemic_transcript_v1', 'winning_path_replay_v1']"

  - id: M3
    title: "Winning-path replay facility"
    status: complete
    deliverables:
      - "harness/src/witness.rs (new): replay_winning_path() generic function"
      - "ReplayInvariantChecker trait: check(step, pre, post, op_code, op_args) -> Result<()>"
      - "Goal path extraction from tape (reuse reconstruct_path pattern)"
      - "Edge extraction: unique Applied candidate per parent→child pair"
      - "Fingerprint verification at each step"
      - "harness/src/bundle.rs: new verification step gated by winning_path_replay_v1"
      - "Integration with CREPLAY-001: uses compiled root state as replay input"
    notes:
      - "Replay lives in harness/ (verifier), not search/ (recorder)"
      - "Generic over worlds — invariant checker is a trait callback"
      - "Replay re-executes apply() — needs kernel operators + registry"
      - "Fingerprint = canonical_hash(StateFingerprint, state.combined_bytes())"
      - "Edge uniqueness enforced: 0 → ReplayEdgeMissing, >1 → ReplayEdgeAmbiguous"
      - "Step numbering: new Step 20 (after Step 19 tool transcript)"

  - id: M4
    title: "Epistemic transcript + invariant checker + corridor binding"
    status: complete
    deliverables:
      - "Invariant checker for partial obs world (implements ReplayInvariantChecker)"
      - "Transcript rendered as replay visitor output"
      - "harness/src/runner.rs: render transcript via replay, include in bundle"
      - "harness/src/bundle.rs: verification step for transcript equivalence"
      - "Report field: epistemic_transcript_digest (downstream, report-only)"
    notes:
      - "Invariant checker verifies: no truth writes, feedback correctness, belief monotonicity, declare correctness"
      - "Checker accumulates transcript entries + belief cardinality history"
      - "After replay, accumulated entries → canonical JSON = transcript artifact"
      - "Downstream binding convention: normative artifact + report field + Cert equivalence"
      - "NOT in graph metadata or tape header (dependency cycle prevention)"
      - "Transcript inputs: compiled root state + tape edges + registry + K,V. No out-of-band access"

  - id: M5
    title: "Lock tests"
    status: complete
    deliverables:
      - "tests/lock/src/bin/partial_obs_golden_generator.rs: golden fixture generator"
      - "tests/lock/fixtures/partial_obs_solve/: golden solve-path fixtures"
      - "tests/lock/tests/partial_obs.rs: lock tests"
    notes:
      - "Two-step probe cycle: OP_GUESS then OP_FEEDBACK in sequence"
      - "Belief cardinality strictly decreases at least once"
      - "Declare matches truth (is_goal passes)"
      - "Replay succeeds (Cert, fingerprints match at each step)"
      - "Forged transcript fails Cert (equivalence mismatch)"
      - "Feedback incorrectness detected by replay (synthetic: tamper feedback value)"
      - "Belief monotonicity violation detected (synthetic: inject increasing cardinality)"
      - "Edge uniqueness: ambiguous edge detected (synthetic)"
      - "Truth layer write rejected by kernel (effect validation)"
      - "Backward compat: RomeMiniSearch + ToolKvStore bundles still verify"
      - "Search determinism: partial obs world produces deterministic results"

evidence:
  commits:
    - "af04126: feat(kernel): add OP_GUESS, OP_FEEDBACK, OP_DECLARE operators [POBS-001 M1]"
    - "b492e9b: feat(harness): partial observability world [POBS-001 M2]"
    - "79834c8: feat(harness): winning-path replay witness [POBS-001 M3]"
    - "3065973: feat(harness): epistemic transcript + invariant checker + corridor binding [POBS-001 M4]"
    - "f9b58c8: test(lock): partial observability lock tests [POBS-001 M5]"
  total_tests: 685
  lock_tests:
    - "tests/lock/tests/partial_obs.rs: 16 tests (Base/Cert verification, transcript integrity, belief monotonicity, determinism, forged transcript negative, backward compat)"

non_functional:
  a11y: []
  perf:
    note: >-
      Winning-path replay adds one pass of apply() per winning-path edge
      for Cert verification. Path length is bounded by search depth limit.
      Non-replay worlds are unaffected. Replay cost is O(path_length *
      apply_cost), which for small worlds (path ≤ ~10 edges) is negligible.
  security:
    note: >-
      Truth layer is kernel-protected (write-once, Provisional after compile).
      Kernel dispatch handlers never read truth — no semantic leak channel.
      Replay independently verifies feedback correctness and belief monotonicity.
      Downstream binding convention prevents dependency cycle attacks.

contracts:
  - id: CTR-POBS-01
    type: kernel_api
    description: >-
      apply() dispatches OP_GUESS, OP_FEEDBACK, OP_DECLARE through three-phase
      check. WritesGuess validates K diffs on layer 1; WritesFeedback validates
      1 diff on layer 1; DeclaresSolution validates 1 diff on layer 1. No
      dispatch handler reads layer 0 or computes truth-dependent values.
    parties: [kernel/operators/apply, kernel/operators/operator_registry]

  - id: CTR-POBS-02
    type: witness_replay
    description: >-
      replay_winning_path(tape, root_state, registry, checker) re-executes
      the winning path from compiled root state. Verifies fingerprints at
      each step. Enforces edge uniqueness (exactly one Applied candidate per
      parent→child). Invokes checker for world-specific invariants. Generic
      facility, not world-specific.
    parties: [harness/witness, harness/bundle]

  - id: CTR-POBS-03
    type: derived_artifact
    description: >-
      epistemic_transcript.json rendered via replay visitor. Downstream
      binding: normative artifact + report digest + Cert equivalence.
      Cert equivalence uses replay-based rendering (stronger than tape-only
      rendering because it verifies intermediate states and feedback
      correctness simultaneously).
    parties: [harness/witness, harness/bundle, harness/runner]

  - id: CTR-POBS-04
    type: backward_compat
    description: >-
      Worlds with evidence_obligations: [] unaffected. Replay and transcript
      steps skipped. No regressions.
    parties: [harness/bundle, harness/runner]
