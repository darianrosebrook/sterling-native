id: STOCH-001
type: feature
title: 'Stochastic World: Precommitted RNG Witness + Distributional Evaluation'
status: draft
risk_tier: 2
mode: development
created_at: '2026-03-01T00:00:00.000Z'
updated_at: '2026-03-01T00:00:00.000Z'
blast_radius:
  modules:
    - kernel/operators
    - kernel/proof/hash_domain
    - kernel/carrier/bytetrace  # witness_store_digest activation
    - harness/worlds
    - harness/bundle
    - harness/runner
    - harness/witness
    - search/search
    - search/tape_render
    - tests/lock
  data_migration: false
operational_rollback_slo: 15m

purpose: >
  Introduce a stochastic truth-regime world that forces "certification binds to
  evidence, not environment" — the hardest evidence model. The agent moves on a
  grid where transitions slip with probability p: the intended direction succeeds
  with probability (1-p), and each of the other directions gets probability p/3.
  The key design constraint: replay must be able to independently verify every
  transition outcome without access to the original runtime environment.

  Option 1 (precommitted RNG witness stream) is chosen over Option 2 (seed +
  deterministic PRNG) because it makes the randomness surface explicitly auditable
  — the witness stream IS the evidence, not a derived computation from a seed.
  This aligns with the "no hidden semantics" principle: the verifier can check
  each outcome against the witness without needing to know which PRNG algorithm
  was used or reimplementing it identically.

  This is the third truth-regime world (after TOOLSCRIPT-001 tool safety and
  POBS-001 epistemic). It validates that the three-way authority division
  (ADR 0009) scales to stochastic domains and that the derived-artifact corridor
  pattern is reusable across all truth regimes.

depends_on:
  - "TOOLSCRIPT-001: Established derived-artifact corridor pattern (obligation → render → equivalence)."
  - "POBS-001: Established winning-path replay witness and ReplayInvariantChecker trait."
  - "ADR 0009: Truth-regime authority division (kernel/world/verifier)."
  - "ADR 0008: Additive field extension for new binding fields."
  - "ByteTraceFooterV1.witness_store_digest: Already in wire format, currently always None."

non_goals:
  - "No changes to compile() semantics or CompilationResultV1."
  - "No changes to SearchGraphV1 or SearchTapeV1 schema versions — new fields are additive (ADR 0008)."
  - "No epistemic + stochastic combination world — single truth regime per world."
  - "No continuous action spaces — discrete grid directions only."
  - "No learned policies — uniform or table scorer only."
  - "No multi-agent stochastic games — single agent."
  - "No online learning or reward shaping — fixed transition probabilities."

design:
  architectural_posture: >
    This spec exercises the stochastic evidence boundary: can replay prove that
    recorded transition outcomes match what the authoritative randomness source
    produced? The answer is yes if and only if the randomness source is committed
    before search and shipped with the bundle. The precommitted witness stream
    achieves this without requiring PRNG algorithm identity between producer and
    verifier.

    The three-way authority division (ADR 0009) governs:
    - Kernel: OP_INTENT and OP_OUTCOME operators with WritesIntent / WritesOutcome
      EffectKind variants. Each enforces exactly 1 slot write. Does NOT validate
      whether the outcome matches the witness — that is the verifier's job.
    - World: At resolve steps, produces exactly one OP_OUTCOME candidate determined
      by the witness entry. Witness index derived from state (outcome slot count),
      not from a mutable cursor. No RNG calls inside enumerate_candidates().
    - Verifier: During replay, re-reads witness entries and checks that OP_INTENT
      and OP_OUTCOME args match. Checks structural properties only — no
      distributional/probabilistic enforcement.

  # ---------------------------------------------------------------------------
  # Witness Stream Design (Option 1: Precommitted RNG Tape)
  # ---------------------------------------------------------------------------
  witness_stream: >
    The witness stream is an ordered sequence of transition outcomes, one per
    agent move. Each entry contains:
      { step: u64, intended_direction: Code32, actual_direction: Code32, slip: bool }

    The stream is generated before search begins (or lazily during search from a
    seed, but the FULL stream is committed before bundling). The stream is
    serialized as canonical JSON and hashed. The hash is committed in two places:
    (1) ByteTraceFooterV1.witness_store_digest (upstream, baked into trace hash),
    (2) stochastic_witness.json normative artifact in the bundle (downstream,
    bound via report digest + Cert equivalence render).

    Why precommitted and not recomputed-from-seed:
    - The verifier never needs to know the PRNG algorithm or seed.
    - The witness IS the evidence — tamper = hash mismatch, omit = obligation fail.
    - Future portability: if the PRNG implementation changes, old bundles remain
      verifiable because the witness stream was committed, not the algorithm.

    Implementation note: the world MAY internally use a seed + PRNG to generate
    the witness stream. But the committed artifact is the stream, not the seed.
    The seed is an implementation detail, not an evidence surface.

  # ---------------------------------------------------------------------------
  # Grid World Design
  # ---------------------------------------------------------------------------
  grid_world: >
    The world is a 2D grid (N×N) with a start position and goal position.
    The agent chooses a cardinal direction (UP, DOWN, LEFT, RIGHT) each step.
    With probability (1-p), the move succeeds. With probability p, the agent
    slips to a uniformly random other direction. Walls are absorbing (move into
    wall = stay in place).

    State layout:
    - Layer 0: goal position (Provisional at compile time, write-protected)
    - Layer 1: intent/outcome history + completion marker
      - Slot 2*i: intent_i (intended direction, written by OP_INTENT)
      - Slot 2*i+1: outcome_i (realized direction, written by OP_OUTCOME)
      - Slot MAX_STEPS*2: completion marker (solved marker or step-budget marker)

    Goal predicate: position computed from start + cumulative outcomes == goal.
    Position is implicit — not stored in state, reconstructed from outcome slots.

    Default regime: 5×5 grid, start=(0,0), goal=(4,4), slip_probability=0.2,
    max_steps=50. This is small enough for exhaustive search but large enough
    that slip effects are observable in the witness stream.

  # ---------------------------------------------------------------------------
  # Operator Design
  # ---------------------------------------------------------------------------
  operators: >
    Two-phase "act then resolve" design, mirroring the POBS GUESS/FEEDBACK
    cadence. The agent's action does not require truth; the environment's
    outcome is applied as a constrained single-legal transition.

    OP_INTENT = Code32::new(1, 3, 1) — agent writes intended direction
      EffectKind: WritesIntent
      Args: intent_args(layer: u32, slot: u32, intended_direction: Code32)
      Byte count: 12 (3 × 4 bytes)
      Kernel enforcement: exactly 1 identity diff + 1 status diff (Hole→Provisional)
      Semantic: writes the intended direction to the next intent slot on layer 1.
      The kernel enforces the write surface; it does not know which direction
      is "correct" or what will happen as a result.

    OP_OUTCOME = Code32::new(1, 3, 2) — environment writes realized outcome
      EffectKind: WritesOutcome
      Args: outcome_args(layer: u32, slot: u32, actual_direction: Code32)
      Byte count: 12 (3 × 4 bytes)
      Kernel enforcement: exactly 1 identity diff + 1 status diff (Hole→Provisional)
      Semantic: writes the realized direction (from witness stream) to the next
      outcome slot on layer 1. enumerate_candidates() produces exactly one legal
      candidate at each resolve step, determined by the witness entry.

    Position is implicit — computed from start position + cumulative outcome
    history during is_goal() and replay. No write-once exception needed.
    All writes are Hole→Provisional, consistent with every other world.

    Intent/outcome slots alternate on layer 1:
      Slot 0: intent_0, Slot 1: outcome_0, Slot 2: intent_1, Slot 3: outcome_1, ...
      Slot MAX_STEPS*2: completion marker (solved or budget-exhausted).

  # ---------------------------------------------------------------------------
  # Evidence Obligations
  # ---------------------------------------------------------------------------
  evidence_obligations: >
    The stochastic world declares two evidence obligations:
    - "stochastic_witness_v1": witness stream artifact must be present and
      digest-bound in the verification report.
    - "winning_path_replay_v1": winning-path replay with StochasticInvariantChecker.

    The runner renders stochastic_witness.json from the tape + original witness
    stream. The verifier checks:
    Step 22: stochastic_witness.json digest binding (report field + artifact hash).
    Step 23: Cert-only equivalence render (re-render from tape, compare bytes).
    Step 24: Cert-only replay invariant check (verify each OP_MOVE against witness).

    Belt-and-suspenders: if tape contains OP_INTENT or OP_OUTCOME applied
    candidates but evidence_obligations doesn't declare "stochastic_witness_v1",
    Cert fails with ObligationMismatch. Uses check_obligation_belt_and_suspenders().

  # ---------------------------------------------------------------------------
  # Stochastic Witness Artifact Schema
  # ---------------------------------------------------------------------------
  artifact_schema: >
    stochastic_witness.json canonical JSON:
    {
      "schema_version": "stochastic_witness.v1",
      "world_id": "stochastic_grid:v1:...",
      "grid_size": 5,
      "slip_probability": 0.2,
      "start_position": [0, 0],
      "goal_position": [4, 4],
      "entry_count": N,
      "entries": [
        {
          "step": 0,
          "intended_direction": "UP",
          "actual_direction": "RIGHT",
          "slip": true
        },
        ...
      ],
      "slip_count": M,
      "solved": true,
      "total_steps": N
    }

    The artifact is normative — included in the bundle digest basis.
    The report binds via "stochastic_witness_digest": "<hash>".

  # ---------------------------------------------------------------------------
  # Invariant Checker
  # ---------------------------------------------------------------------------
  invariant_checker: >
    StochasticInvariantChecker implements ReplayInvariantChecker.
    Constructor takes the witness stream entries.

    On each step pair:
    1. OP_INTENT: verify intended_direction in op_args matches witness entry.
    2. OP_OUTCOME: verify actual_direction in op_args matches witness entry.
       Verify implied position update is consistent with grid geometry
       (wall absorption, direction encoding).
    3. Track slip count (intended != actual).

    After all steps: verify total slip count matches witness aggregate.

  # ---------------------------------------------------------------------------
  # ByteTrace witness_store_digest Activation
  # ---------------------------------------------------------------------------
  witness_binding: >
    The witness stream hash is committed in ByteTraceFooterV1.witness_store_digest.
    This is the upstream binding — it is baked into the trace payload hash, which
    flows into fixture_digest → graph metadata → tape header → report (the full
    upstream corridor). Currently always None; the stochastic world is the first
    to populate it.

    The runner computes:
      witness_hash = canonical_hash(DOMAIN_WITNESS_STORE, witness_stream_bytes)
    and sets footer.witness_store_digest = Some(witness_hash).

    Verification (Cert): the verifier checks that the
    ByteTrace.footer.witness_store_digest matches the hash of the witness stream
    reconstructed from the tape. This is an upstream binding check (analogous to
    fixture_digest in graph metadata).

  # ---------------------------------------------------------------------------
  # Footgun Guards
  # ---------------------------------------------------------------------------
  footgun_guards: >
    FG-1: Stateful witness consumption inside the world object.
      Symptom: determinism failures that disappear when expansion budget or
      frontier order changes.
      Guard: witness index = count of outcome slots written in state (read from
      slot status). Witness stream stored as immutable Vec<WitnessEntry>.
      No mutable cursor, no RNG calls, no interior mutability (no Cell/RefCell
      for witness state). enumerate_candidates(&self, state, _) takes &self,
      enforced by the SearchWorldV1 trait signature.

    FG-2: Resolve phase offers multiple outcomes.
      Symptom: search success depends on scorer choice rather than committed
      randomness. The scorer/search becomes the de facto randomness chooser.
      Guard: at resolve phase, enumerate_candidates() returns exactly one
      OP_OUTCOME candidate. Lock test: assert candidates.len() == 1 at every
      resolve step on the winning path.

    FG-3: Off-by-one mapping between intent/outcome and witness step.
      Symptom: invariant checker fails only on longer traces, or verifies
      intent[i] against witness[i-1].
      Guard: witness step = move index = outcome count. In code:
      i = outcomes_written_so_far (count of Provisional odd-indexed slots).
      Intent slot = 2*i, outcome slot = 2*i+1. Lock test with >5 moves
      exercising the full mapping.

    FG-4: Cyclic dependency between witness digest and tape-derived rendering.
      Symptom: witness digest accidentally computed from something that depends
      on the tape or search results.
      Guard: witness stream bytes + hash computed BEFORE search begins. Witness
      bytes are an INPUT to search (via the world's enumerate_candidates), not
      an OUTPUT. ByteTraceFooterV1.witness_store_digest set from pre-computed
      hash. Matches ADR 0009: world computes, verifier proves.

    FG-5: Conflating witness validity with witness plausibility.
      Symptom: Cert rejects valid committed witness streams because they
      "don't look random enough."
      Guard: Cert checks are structural only (slip_count == count(slip=true),
      directions are valid, entries are ordered). No probabilistic enforcement.
      Plausibility tests (if desired) belong in governance artifacts or
      scorer-health metrics, not Cert gates.

    FG-6: Obligation enforcement only when artifact exists.
      Symptom: "strip obligation + drop artifact" becomes a bypass.
      Guard: belt-and-suspenders via check_obligation_belt_and_suspenders()
      runs before early return. Already implemented and proven in tool/epistemic
      regimes.

  # ---------------------------------------------------------------------------
  # Red-Team Mini-Matrix
  # ---------------------------------------------------------------------------
  red_team_matrix: >
    Four targeted tampering scenarios covering 90% of stochastic-specific
    failure modes. Each should be a lock test (negative control):

    RT-1: Mutate one witness entry's actual_direction.
      Expected: Cert fails — either WitnessTransitionMismatch (replay invariant)
      or equivalence mismatch (re-rendered witness != shipped artifact).
      Tests: replay correctness + witness binding integrity.

    RT-2: Keep witness bytes but mutate one OP_OUTCOME op_args in the tape
      to a different direction.
      Expected: Cert fails — replay applies the mutated op_args, producing
      a state fingerprint mismatch (ReplayFingerprintMismatch) or an
      invariant checker error (WitnessTransitionMismatch).
      Tests: replay catches op_args/witness divergence.

    RT-3: Drop stochastic_witness.json while leaving stochastic ops in tape.
      Expected: Cert fails — belt-and-suspenders detects applied OP_INTENT/
      OP_OUTCOME without stochastic_witness_v1 obligation (ObligationMismatch),
      OR obligation-gated artifact-missing check fires.
      Tests: silent omission defense.

    RT-4: Make enumerate_candidates() use a mutable internal cursor instead
      of state-derived witness index. Show determinism breaks.
      Expected: determinism test (N=10 identical digests) FAILS because
      different exploration orders consume witness entries differently.
      Tests: world purity under branching (AC12).
      Note: this is a design-time test — the implementation must not have
      a mutable cursor. If it does, RT-4 catches it. The &self constraint
      from SearchWorldV1 provides compile-time enforcement.

scope:
  in:
    - "kernel/src/operators/apply.rs"
    - "kernel/src/operators/operator_registry.rs"
    - "kernel/src/proof/hash_domain.rs"
    - "kernel/src/carrier/bytetrace.rs"       # witness_store_digest population
    - "harness/src/worlds/stochastic_grid.rs"  # new file
    - "harness/src/worlds/mod.rs"
    - "harness/src/contract.rs"
    - "harness/src/bundle.rs"
    - "harness/src/runner.rs"
    - "harness/src/witness.rs"
    - "harness/src/transcript.rs"
    - "search/src/tape_render.rs"
    - "tests/lock/tests/stochastic.rs"         # new file
    - "tests/lock/Cargo.toml"
  out:
    - "kernel/src/carrier/compile.rs"           # compilation boundary stays locked
    - "kernel/src/carrier/bytestate.rs"         # state structure unchanged
    - "search/src/search.rs"                    # search algorithm unchanged
    - "benchmarks/"

change_budget:
  max_files: 16
  max_loc: 1200

milestones:
  - id: M0
    title: "Pre-step: obligation gating refactor"
    status: complete
    description: >
      Extract read_evidence_obligations() and check_obligation_belt_and_suspenders()
      helpers in bundle.rs. Eliminates 3x duplication and establishes the reusable
      facility for STOCH-001's third obligation-gated derived artifact.
    acceptance:
      - "read_evidence_obligations() used by all three verification functions"
      - "check_obligation_belt_and_suspenders() used by tool and epistemic checks"
      - "688 tests pass, clippy clean"
    evidence:
      - "6a32679: refactor(harness): extract obligation gating helpers in bundle.rs"

  - id: M1
    title: "Kernel: OP_INTENT + OP_OUTCOME operators"
    status: pending
    description: >
      Add OP_INTENT and OP_OUTCOME operator constants, arg builders, dispatch
      handlers, and EffectKind::WritesIntent / EffectKind::WritesOutcome with
      post-apply validation. Add DOMAIN_WITNESS_STORE to HashDomain enum.
      Two-phase design mirrors POBS GUESS/FEEDBACK cadence.
    acceptance:
      - "OP_INTENT applies successfully with correct arg layout (1 diff)"
      - "OP_OUTCOME applies successfully with correct arg layout (1 diff)"
      - "EffectKind::WritesIntent and WritesOutcome validate correct diff count"
      - "Wrong diff count rejected for both operators"
      - "DOMAIN_WITNESS_STORE hash domain exists"

  - id: M2
    title: "World: StochasticGrid implementation"
    status: pending
    description: >
      Implement StochasticGrid world with WorldHarnessV1 + SearchWorldV1 traits.
      Witness stream generation (from seed internally, committed as stream).
      Grid world with configurable size, start, goal, slip probability.
      enumerate_candidates() derives witness index from state (outcome slot
      count), not from a mutable cursor. At resolve steps, exactly one
      OP_OUTCOME candidate. SearchWorldV1 trait enforces &self (no interior
      mutability for witness consumption).
    acceptance:
      - "StochasticGrid implements WorldHarnessV1 and SearchWorldV1"
      - "world_id() returns consistent value across both traits"
      - "evidence_obligations includes stochastic_witness_v1 and winning_path_replay_v1"
      - "enumerate_candidates() at intent phase returns OP_INTENT candidates for each valid direction"
      - "enumerate_candidates() at resolve phase returns exactly 1 OP_OUTCOME candidate (AC14)"
      - "Witness index derived from state — count of Provisional odd-indexed layer-1 slots (AC12)"
      - "No mutable cursor, no RNG calls, no Cell/RefCell in StochasticGrid (FG-1)"
      - "is_goal() computes position from start + cumulative outcomes, checks == goal"
      - "Witness stream is deterministic from constructor parameters"

  - id: M3
    title: "Runner: witness_store_digest + stochastic_witness.json rendering"
    status: pending
    description: >
      Extend run_search() with Phase 4d block for stochastic witness rendering.
      Populate ByteTraceFooterV1.witness_store_digest.
      Add stochastic_witness_digest binding in verification report.
    acceptance:
      - "witness_store_digest populated in ByteTrace footer"
      - "stochastic_witness.json artifact present in bundle"
      - "stochastic_witness_digest bound in verification report"
      - "Artifact count correct (standard 8 + stochastic_witness = 9, or 10 with table scorer)"

  - id: M4
    title: "Verifier: stochastic witness verification + replay invariant checker"
    status: pending
    description: >
      Add verify_stochastic_witness() to bundle.rs (Steps 22-24).
      Implement StochasticInvariantChecker for ReplayInvariantChecker.
      Add belt-and-suspenders via check_obligation_belt_and_suspenders()
      with tape predicate for OP_INTENT/OP_OUTCOME.
      Cert equivalence: re-render witness from tape, compare bytes.
      Cross-binding triangle: ByteTrace footer + report digest + artifact.
      Structural-only checks: no probabilistic enforcement (AC16).
      Phase-sequence validation on winning path only (AC17).
    acceptance:
      - "Base verification passes for stochastic bundle"
      - "Cert verification passes for stochastic bundle"
      - "Forged witness fails Cert equivalence (RT-1)"
      - "Mutated OP_OUTCOME op_args fails replay (RT-2)"
      - "Stripped obligations fail Cert belt-and-suspenders (RT-3)"
      - "StochasticInvariantChecker catches mismatched transition outcomes"
      - "Cross-binding triangle verified: footer + report + artifact (AC15)"
      - "Verifier checks structural facts only, no probabilistic expectations (AC16)"
      - "Phase-sequence violations caught on winning path with typed error (AC17)"
      - "Witness index mapping: OP_OUTCOME[i] ↔ witness_stream[i] (AC13)"

  - id: M5
    title: "Lock tests"
    status: pending
    description: >
      Comprehensive lock tests covering: bundle generation + Base/Cert verification,
      witness artifact presence and structural integrity, replay with invariant
      checker, determinism (N=10), backward compatibility, belt-and-suspenders,
      plus red-team mini-matrix (RT-1 through RT-4) and stochastic-specific
      acceptance criteria (AC12-AC17).
    acceptance:
      - "All stochastic lock tests pass"
      - "Existing lock tests unchanged and passing"
      - "Backward compatibility: non-stochastic worlds unaffected"
      - "RT-1: mutated witness entry actual_direction fails Cert"
      - "RT-2: mutated OP_OUTCOME op_args fails Cert replay"
      - "RT-3: dropped stochastic_witness.json with stochastic ops fails Cert"
      - "RT-4: determinism N=10 proves no mutable cursor (AC12 compile-time guard via &self)"
      - "Resolve-phase single-candidate assertion on winning path (AC14)"
      - "Witness index mapping exercised with >5 moves (AC13, FG-3)"
      - "Phase-sequence violation negative test (AC17)"
      - "Structural-only verification: slip_count matches, no probabilistic gate (AC16)"
      - "Clippy clean, no new warnings"

acceptance_criteria:
  # --- Basic corridor criteria ---
  - id: AC1
    description: "StochasticGrid world produces valid bundles that pass Base and Cert verification."
    status: pending
  - id: AC2
    description: "Witness stream is precommitted (hashed before search, committed in ByteTrace footer)."
    status: pending
  - id: AC3
    description: "Cert equivalence: re-rendered stochastic_witness.json from tape matches bundle artifact."
    status: pending
  - id: AC4
    description: "Replay invariant checker verifies each transition outcome against witness."
    status: pending
  - id: AC5
    description: "Forged witness (tampered entries) fails Cert verification."
    status: pending
  - id: AC6
    description: "Belt-and-suspenders: tape with any applied OP_INTENT or OP_OUTCOME but missing stochastic_witness_v1 obligation fails Cert."
    status: pending
  - id: AC7
    description: "witness_store_digest in ByteTrace footer binds witness hash into trace corridor."
    status: pending
  - id: AC8
    description: "Existing worlds (RomeMini, ToolKvStore, PartialObs) unaffected — backward compatible."
    status: pending
  - id: AC9
    description: "Search is deterministic: same world + same policy = identical bundle digest (N=10)."
    status: pending
  - id: AC10
    description: "Verification pipeline extended to 24 steps (Steps 22-24 for stochastic witness)."
    status: pending
  - id: AC11
    description: "ADR 0009 committed and referenced."
    status: met

  # --- Stochastic-specific criteria (branching + authority division) ---
  - id: AC12
    description: >-
      World purity under branching: GIVEN the same immutable witness stream
      and the same state input WHEN enumerate_candidates() is called repeatedly
      in different search exploration orders THEN it returns identical candidates
      in the same order. Witness index is derived from state (count of outcome
      slots written), not from a world-global mutable cursor. No interior
      mutability, no RNG calls inside enumerate_candidates().
    status: pending
  - id: AC13
    description: >-
      Witness index mapping is unambiguous in two-phase world: GIVEN a tape
      containing alternating OP_INTENT / OP_OUTCOME applies WHEN the verifier
      replays the winning path THEN each OP_OUTCOME at move i maps to
      witness_stream[i], and each OP_INTENT at move i matches
      witness_stream[i].intended_direction. Witness step = move index =
      outcome count, not operator frame index. i = outcomes_written_so_far;
      intent slot = 2*i; outcome slot = 2*i+1.
    status: pending
  - id: AC14
    description: >-
      Single-legal candidate at resolve steps: GIVEN a state in resolve phase
      (next slot is an outcome slot) WHEN enumerate_candidates() runs THEN it
      emits exactly one OP_OUTCOME candidate determined by witness_stream[i],
      and zero alternative outcomes. The search/scorer cannot "choose" the
      stochastic outcome — truth authority stays in the world.
    status: pending
  - id: AC15
    description: >-
      Cross-binding triangle for witness stream is complete: GIVEN a stochastic
      bundle WHEN verifying in Cert THEN all three bindings must agree:
      (1) ByteTraceFooterV1.witness_store_digest == hash(canonical witness bytes),
      (2) verification_report.stochastic_witness_digest == stochastic_witness.json
      content_hash, (3) stochastic_witness.json bytes == independently re-rendered
      bytes (Cert equivalence). Any one missing or mismatched → Cert fails closed.
    status: pending
  - id: AC16
    description: >-
      Distributional evaluation stays structural, not statistical: GIVEN
      stochastic_witness.json includes slip_probability, slip_count, and entries
      WHEN verifying THEN the verifier checks only structural facts (slip_count
      equals count of slip=true entries, actual_direction consistent with slip
      flag, directions are valid grid directions) AND does not enforce
      probabilistic expectations (e.g. slip_count within tolerance of p*N).
      The committed witness IS the truth; plausibility tests are governance
      artifacts, not Cert gates.
    status: pending
  - id: AC17
    description: >-
      Phase-sequence violations caught on winning path: GIVEN a winning path
      where OP_OUTCOME is applied without a preceding OP_INTENT (or wrong slot
      parity) WHEN StochasticInvariantChecker runs during replay THEN Cert fails
      with a typed invariant error. Phase enforcement is winning-path-only, not
      global-tape, to avoid false positives from legitimate branching.
    status: pending

invariants:
  - >-
    INV-STOCH-01: Witness stream is precommitted. The canonical hash of the
    witness stream bytes is committed in ByteTraceFooterV1.witness_store_digest
    BEFORE search begins. The witness stream is the authoritative randomness
    source — the verifier never needs the seed or PRNG algorithm.
  - >-
    INV-STOCH-02: Each OP_INTENT and OP_OUTCOME writes exactly 1 slot
    (Hole→Provisional). No slot is written twice. Position is implicit
    (computed from outcome history), not stored in state, avoiding
    write-once exceptions. Intent/outcome slots alternate on layer 1.
  - >-
    INV-STOCH-03: OP_INTENT and OP_OUTCOME kernel dispatch handlers do not read
    the witness stream or validate transition correctness. The kernel enforces
    write-surface bounds (1 identity diff, 1 status diff per operator).
    Truth-dependent validation (does the outcome match the witness?) is the
    verifier's job via replay.
  - >-
    INV-STOCH-04: Witness index is derived from state, not from a mutable
    cursor. enumerate_candidates() computes i = count of outcome slots already
    written (Provisional status on odd-indexed layer-1 slots), then reads
    witness_stream[i]. The world object holds the witness stream as immutable
    bytes/Vec — no mutable cursor, no RNG calls, no interior mutability that
    could make output depend on frontier exploration order. At each resolve
    step, exactly one legal OP_OUTCOME candidate exists (determined by
    witness_stream[i]). This is the primary determinism invariant for
    stochastic worlds under branching search.
  - >-
    INV-STOCH-05: Replay invariant checker independently verifies each
    transition outcome against the witness stream. At each OP_INTENT step,
    intended direction matches the witness entry. At each OP_OUTCOME step,
    realized direction matches the witness entry's actual_direction, and
    the implied position update is consistent with the grid geometry.
  - >-
    INV-STOCH-06: Existing worlds with evidence_obligations: [] continue to
    build and verify without changes. witness_store_digest: None is the default.
    No regressions.
  - >-
    INV-STOCH-07: stochastic_witness.json bytes equal independently rendered
    witness bytes (Cert equivalence, downstream binding convention). Witness is
    rendered from tape + committed witness stream.
  - >-
    INV-STOCH-08: Belt-and-suspenders: if tape contains OP_INTENT or OP_OUTCOME
    applied candidates but evidence_obligations does not declare
    "stochastic_witness_v1", Cert fails with ObligationMismatch. Uses the
    reusable check_obligation_belt_and_suspenders() facility. Prevents silent
    obligation stripping.

errors:
  - id: STOCH-ERR-WITNESS-MISMATCH
    variant: "WitnessTransitionMismatch { step_index: usize, expected_direction: String, actual_direction: String }"
    description: >-
      Replay invariant: the OP_INTENT intended direction or OP_OUTCOME realized
      direction does not match the witness stream entry at the corresponding step.

  - id: STOCH-ERR-WITNESS-EXHAUSTED
    variant: "WitnessStreamExhausted { step_index: usize }"
    description: >-
      Replay invariant: the search consumed more steps than the witness stream
      contains entries. Witness stream was too short for the search.

  - id: STOCH-ERR-WITNESS-DIGEST-MISMATCH
    variant: "WitnessStoreDigestMismatch { trace_digest: String, computed_digest: String }"
    description: >-
      ByteTrace footer witness_store_digest does not match the canonical hash
      of the witness stream bytes. Upstream binding violation.

  - id: STOCH-ERR-SLIP-COUNT
    variant: "SlipCountMismatch { declared: usize, actual: usize }"
    description: >-
      Stochastic witness artifact declares a slip_count that does not match
      the number of slip=true entries in the entries array.

  - id: STOCH-ERR-PHASE-SEQUENCE
    variant: "PhaseSequenceViolation { step_index: usize, expected_phase: String, actual_op: String }"
    description: >-
      Winning-path replay: OP_OUTCOME applied without a preceding OP_INTENT,
      or OP_INTENT applied when an outcome slot was expected. Slot parity
      violated on the winning path.

acceptance:
  - id: ACC-STOCH-01
    description: >-
      GIVEN a StochasticGrid world with default parameters (5x5, slip=0.2)
      WHEN run_search() completes
      THEN the bundle passes Base verification AND Cert verification.

  - id: ACC-STOCH-02
    description: >-
      GIVEN a StochasticGrid bundle
      WHEN the stochastic_witness.json artifact is inspected
      THEN it contains schema_version "stochastic_witness.v1", correct world_id,
      grid parameters, ordered entries with step indices, and slip_count matching
      the number of slip=true entries.

  - id: ACC-STOCH-03
    description: >-
      GIVEN a StochasticGrid bundle
      WHEN the ByteTrace footer is inspected
      THEN witness_store_digest is Some(hash) where hash equals
      canonical_hash(DOMAIN_WITNESS_STORE, witness_stream_bytes).

  - id: ACC-STOCH-04
    description: >-
      RT-1: GIVEN a StochasticGrid bundle with one witness entry's
      actual_direction mutated WHEN Cert verification runs THEN verification
      fails with WitnessTransitionMismatch or equivalence mismatch.

  - id: ACC-STOCH-04b
    description: >-
      RT-2: GIVEN a StochasticGrid bundle with one OP_OUTCOME op_args mutated
      in the tape (different direction) WHEN Cert verification runs THEN
      verification fails with ReplayFingerprintMismatch or
      WitnessTransitionMismatch.

  - id: ACC-STOCH-05
    description: >-
      RT-3: GIVEN a StochasticGrid bundle with stochastic_witness.json dropped
      while OP_INTENT/OP_OUTCOME ops remain in tape WHEN Cert verification runs
      THEN verification fails (belt-and-suspenders ObligationMismatch or
      obligation-gated artifact-missing check).

  - id: ACC-STOCH-06
    description: >-
      GIVEN the same StochasticGrid world and policy run N=10 times
      WHEN bundle digests are compared
      THEN all 10 digests are identical (determinism).

  - id: ACC-STOCH-07
    description: >-
      GIVEN existing worlds (RomeMiniSearch, ToolKvStore, PartialObsWorld)
      WHEN run_search() and verify_bundle_with_profile(Cert) are called
      THEN all pass without changes. No stochastic artifacts present.

non_functional:
  a11y: []
  perf:
    note: >-
      Witness stream generation is O(max_steps). Replay cost is O(path_length *
      apply_cost) plus witness lookup (O(1) per step via index). For the default
      5x5 grid with max_steps=50, this is negligible. Witness stream storage is
      O(max_steps * entry_size) — for 50 entries at ~64 bytes each, ~3.2 KB.
      Non-stochastic worlds unaffected (witness_store_digest: None).
  security:
    note: >-
      Witness stream is precommitted and hash-bound into the trace corridor
      (ByteTrace footer). Tampering with the witness changes the trace hash,
      which cascades through fixture_digest → graph metadata → tape header →
      report. The verifier independently checks each transition against the
      witness. The kernel never reads the witness — no semantic leak channel.
      Belt-and-suspenders prevents obligation stripping.

contracts:
  - id: CTR-STOCH-01
    type: kernel_api
    description: >-
      apply() dispatches OP_INTENT and OP_OUTCOME through three-phase check.
      WritesIntent validates 1 identity diff + 1 status diff (intent slot).
      WritesOutcome validates 1 identity diff + 1 status diff (outcome slot).
      No dispatch handler reads the witness stream or validates transition
      correctness. Two-phase mirrors POBS GUESS/FEEDBACK cadence.
    parties: [kernel/operators/apply, kernel/operators/operator_registry]

  - id: CTR-STOCH-02
    type: witness_replay
    description: >-
      replay_winning_path(tape, root_state, registry, checker) re-executes
      the winning path. StochasticInvariantChecker verifies each OP_INTENT
      and OP_OUTCOME pair against the witness stream (direction match, outcome
      match, slip tracking). Generic replay facility reused from POBS-001.
    parties: [harness/witness, harness/bundle]

  - id: CTR-STOCH-03
    type: derived_artifact
    description: >-
      stochastic_witness.json rendered from tape + committed witness stream.
      Downstream binding: normative artifact + report digest + Cert equivalence.
      Upstream binding: ByteTrace footer witness_store_digest.
    parties: [harness/witness, harness/bundle, harness/runner]

  - id: CTR-STOCH-04
    type: backward_compat
    description: >-
      Worlds with evidence_obligations: [] unaffected. witness_store_digest
      remains None. Stochastic verification steps skipped. No regressions.
    parties: [harness/bundle, harness/runner]

open_questions:
  - id: OQ1
    question: >
      Explicit position slot (richer state, requires write-once exception for
      position slot) vs implicit position (simpler kernel, position computed from
      move history during goal check and replay)?
    resolution: >
      Implicit position. Two-phase design (OP_INTENT + OP_OUTCOME) writes only
      history slots (Hole→Provisional). Position is computed from start +
      cumulative outcome history. No write-once exception needed. Consistent
      with every other world. Each operator writes exactly 1 diff, matching
      the simplest existing EffectKind pattern.
    status: closed

  - id: OQ2
    question: >
      Should the witness stream be generated lazily during search (from an
      internal seed) and committed post-search, or pregenerated before search
      begins?
    resolution: >
      Lazy generation + post-search commitment. The world MAY internally use a
      seed + PRNG to generate witness entries during enumerate_candidates(). The
      committed artifact is the STREAM, not the seed. The verifier never sees the
      seed. Evidence surface is identical either way.
    status: closed
