# M2 Claim Catalog

> What Sterling Native is allowed to say after M2 is complete.
> Each claim has a falsifier: a concrete way to disprove it.

## M2-CLAIM-001: Wire round-trip stability

**Statement**: Serializing the M2 canonical trace to `.bst1`, parsing it with the Native reader, and re-serializing produces identical bytes.

**Scope**: This claim covers the canonical fixture trace (1 layer, 2 slots, 3 arg slots, `INITIAL_STATE` → `SET_SLOT`). The round-trip property holds for any well-formed trace accepted by the reader, but the golden fixture is the locked anchor.

**Falsifier**: Write the canonical trace to `.bst1`, read it back, write again. If any byte differs between the first and second serialization, the claim is false.

**Required artifacts**: S1-M2-DETERMINISM-INPROC (round-trip N=10), S1-M2-DETERMINISM-CROSSPROC (binary emits `bst1_hex`).

## M2-CLAIM-002: V1 oracle parity

**Statement**: Native's `.bst1` bytes and payload hash are byte-identical to the v1 Python oracle for the canonical fixture.

**Scope**: This claim covers the full `.bst1` wire bytes (including envelope), not just the payload hash. Envelope serialization stability is part of the M2 wire contract. The payload hash uses the V1-originated domain prefix `DOMAIN_BYTETRACE`. The step-chain digests are Native-originated (v1 has no step chain) and are outside V1 oracle parity.

**Falsifier**: Compare `tests/fixtures/m2_golden_trace.bst1` (generated by v1 Python) to the output of `trace_fixture`. If any byte or the payload hash digest differs, the claim is false.

**Required artifacts**: `m2_golden_trace.bst1`, `m2_golden_trace.json`, S1-M2-GOLDEN, `crossproc_output_matches_v1_oracle`, `v1_bst1_file_parseable_by_native_reader`.

## M2-CLAIM-003: Cross-process determinism

**Statement**: Trace write, payload hash, step chain, and replay verification produce identical output across process environments (different cwd, locale, spurious env vars).

**Falsifier**: Spawn `trace_fixture` under >=3 environment variants. If any output line differs, the claim is false.

**Required artifacts**: S1-M2-DETERMINISM-CROSSPROC (4 env variants in `s1_m2_crossproc.rs`).

## M2-CLAIM-004: Fail-closed strictness

**Statement**: The reader and writer reject malformed wire bytes with typed errors. The system does not repair, normalize, or accept-then-canonicalize.

**Specific rejections**:
- Non-canonical header JSON → `NonCanonical`
- Non-canonical footer JSON → `NonCanonical`
- Trailing bytes after footer → `TrailingBytes`
- Frame 0 not `INITIAL_STATE` sentinel → `BadInitialFrame` (reader + writer)
- Frame 0 with non-zero `op_args` → `BadInitialFrame` (reader + writer)
- Explicit `witness_store_digest: null` → `InvalidFooter`
- Size computation overflow → `DimensionOverflow` (writer)
- Invalid hex digest in step chain → `DigestCorruption`

**Falsifier**: For each rejection case, construct the malformed input and call the reader/writer. If any case returns `Ok`, panics, or produces partial output, the claim is false.

**Required artifacts**: Unit tests in `trace_reader.rs` (`rejects_non_canonical_header`, `rejects_non_canonical_footer`, `rejects_trailing_bytes`, `rejects_bad_initial_frame_sentinel`, `rejects_nonzero_initial_frame_args`, `rejects_null_witness_store_digest`), writer validation in `trace_writer.rs`.

## M2-CLAIM-005: Divergence localization

**Statement**: When a trace frame is mutated, the step-chain diverges at the exact mutated frame index. Preceding frames' chain values are unchanged.

**Scope**: This claim covers the step-chain hash structure. Replay verification (`replay_verify`) separately localizes divergence by re-applying operators, which is the primary verification path. The step chain provides a secondary O(1) localization surface.

**Falsifier**: Mutate frame k in a multi-step trace. If the step chain first diverges at any index other than k, or if preceding chain values change, the claim is false.

**Required artifacts**: S1-M2-DIV-LOCALIZE, `step_chain_localizes_mutation_to_exact_frame`, `step_chain_diverges_at_mutated_frame` in `s1_m2_divergence.rs`.

---

## Admissibility

A claim is admissible only when:
1. All required artifacts exist and pass in CI.
2. Golden fixtures were generated by an oracle outside the Native build graph (v1 Python).
3. The Native code is constrained by the fixtures (would fail if serialization/hashing drifted).
4. No manual steps are required beyond `cargo test --workspace`.
5. Claims apply only to `ByteTraceV1` and the implemented operator set (sentinels + `SET_SLOT`).
