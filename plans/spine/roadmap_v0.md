# SPINE-001 Roadmap: Kernel Spine M0–M3

> Contract deliverable for `.caws/specs/SPINE-001.yaml`.
> This file is the authoritative milestone plan for the kernel spine.

## Milestones

### M0 — Kernel contract surface and repo layout

**Status**: Complete

**Deliverables**:
- Rust workspace (`kernel/`, `tests/lock/`) with pinned toolchain (1.90.0)
- `compile()`, `apply()`, `replay_verify()` API signatures (stubs, logic deferred)
- Carrier types: `Code32`, `ByteStateV1`, `SlotStatus`, `ByteTraceV1`, `SchemaDescriptor`, `RegistrySnapshot`
- Operator types: `OperatorSignature`, `IdentityMaskV1`, `StatusMaskV1`, `OperatorCategory`
- Proof types: `ContentHash`, domain prefix constants, `ReplayVerdict`
- JSON schemas: `bytetrace_descriptor`, `trace_bundle`, `claim`, `schema_descriptor`, `registry_snapshot`, `policy_snapshot`
- S1-M0 lock test: build-graph isolation (no v1 deps in kernel)
- CI workflow: check, clippy, fmt, test, docs lint

**Acceptance**: S1-M0 — no v1 dependency reachable from kernel build graph.

### M1 — ByteState/Code32 + canonical hashing (proof portfolio)

**Status**: Complete

**Completion sentence**: "M1 is complete when the kernel can deterministically compile a Rome payload into ByteState bytes and produce V1-compatible SHA-256 digests that match committed golden fixtures across OSes, while failing closed with typed errors on a mutation suite — and all of this is reproducible without importing or running V1 inside the Native build graph."

#### Claim surface (what M1 allows you to say)

- **M1-CLAIM-001** (Compilation boundary determinism): `compile(payload_bytes, schema_descriptor, registry_snapshot)` is a pure function for the Rome payload shape; identical inputs produce identical `ByteStateV1` bytes.
- **M1-CLAIM-002** (V1 hash parity): All content/state/registry hashing uses SHA-256 with the exact V1 domain-separation prefix bytes, producing `"sha256:<lowercase hex>"` outputs.
- **M1-CLAIM-003** (No second-truth JSON trace): M1 does not introduce an alternate "JSON trace" representation that can diverge from the binary carrier; only descriptors/manifests may be JSON.
- **M1-CLAIM-004** (Fail-closed compilation): Invalid payload/schema/registry inputs do not emit partial ByteState and do not panic; they return typed failures.

These claims are written as a claim catalog at `plans/spine/m1_claims.md`.

#### Deliverables

- `sha2` dependency for canonical hashing (SHA-256, V1-compatible domain prefixes)
- Single `canonical_hash()` implementation — all hashing flows route through it
- Single canonical JSON bytes implementation — all serialization-for-hashing routes through it
- `ByteStateV1` encode/decode with strict round-trip (no truncation acceptance)
- `compile()` implementation for Rome payload shape
- Golden byte fixtures generated from v1 offline, committed as test expectations
- Fail-closed mutation suite with typed `CompilationFailure` variants
- M1 claim catalog (`plans/spine/m1_claims.md`)

#### Acceptance criteria (proof portfolio)

| ID | Category | What it proves |
|----|----------|---------------|
| S1-M1-DETERMINISM-INPROC | Determinism | N>=10 calls in same process → identical bytes + digests |
| S1-M1-DETERMINISM-CROSSPROC | Determinism | Subprocess under >=3 env variants → same golden bytes |
| S1-M1-DETERMINISM-CROSSOS | Determinism | CI on Linux + macOS → identical results against golden fixtures |
| S1-M1-GOLDEN | Golden fixtures | Evidence bytes + digests match committed fixtures bit-for-bit |
| S1-M1-HASH-V1-VECTORS | V1 parity | >=3 sha256(prefix \|\| data) vectors match v1 oracle outputs |
| S1-M1-CANONJSON | Canonicalization | Stable canonical JSON bytes, documented rule set |
| S1-M1-FAILCLOSED | Fail-closed | Invalid inputs → no partial state, no panic, typed failure |
| S1-M1-TYPED-FAILURES | Error taxonomy | Each invalid class → stable error family |
| S1-M1-ORDERING-INVARIANCE | Anti-drift | Reordered JSON keys → identical output |
| S1-M1-REGISTRY-CANON | Registry | Canonical bytes stable, no incidental metadata |
| S1-M1-REGISTRY-HASH-GOLDEN | Registry | Registry digest matches committed golden |
| S1-M1-REGISTRY-VALIDATION | Fail-closed | Unknown Code32 → UnknownConcept, no auto-allocate |
| S1-M1-BYTESTATE-ROUNDTRIP | Encode/decode | evidence_bytes → ByteStateV1 round-trip, strict lengths |
| S1-M1-EQ-SEPARATION-LOCK | Equality | Status-only change: identity_eq true, bitwise_eq false, digests differ |
| S1-M1-NO-V1-DEPS | Isolation | Extends S1-M0 to cover M1 modules |
| S1-M1-NO-PATH-IN-HASH | Determinism | No paths/cwd/username/hostname/timestamps in any hashed surface |
| S1-M1-ONE-CANONICALIZER | Anti-drift | Exactly one canonical JSON implementation in kernel |
| S1-M1-REPRO | Reviewer | `cargo test --workspace` is sufficient, no manual setup |

#### Fixture admissibility rule

A fixture is only admissible if it is (1) generated by an oracle outside the Native build graph, and (2) the Native code is *constrained by it* (i.e., it would fail if canonicalization/hashing drifted).

#### compile() strategy

Rome payload is a canonical JSON representation of initial identity/status planes plus shape metadata. `compile()` parses, validates against registry, produces `ByteStateV1` deterministically. No invented semantics — keep it boring so golden fixtures are derivable from v1.

#### Fixture strategy

v1 is the oracle for wire format bytes and sha256 hashes. Generate fixtures from v1 Python, commit the bytes, validate Native against committed fixtures. Never import v1 into Native build graph. v1 is **not** an oracle for compilation semantics (the payload→state boundary is new).

#### M1 evidence index

Commit range: `2bf0b4a..6a1d05c` (8 commits). 103 tests, all passing.

| Artifact | Path | Role |
|----------|------|------|
| Golden fixture | `tests/fixtures/rome_2x4_golden.json` | V1 oracle bytes + digests |
| Golden fixture tests | `tests/lock/tests/s1_m1_golden_fixtures.rs` | 8 tests constraining compile against oracle |
| Determinism tests | `tests/lock/tests/s1_m1_determinism.rs` | In-proc N=10, ordering invariance, eq separation, one-canonicalizer, no-path-in-hash, no-v1-refs |
| Cross-process tests | `tests/lock/tests/s1_m1_crossproc.rs` | Subprocess under 4 env variants + golden output match |
| CI matrix | `.github/workflows/ci.yml` | `[ubuntu-latest, macos-latest]` for cross-OS |
| Claim catalog | `plans/spine/m1_claims.md` | 4 falsifiable claims with falsifiers |
| Canonical JSON | `kernel/src/proof/canon.rs` | Single canonicalizer (ASCII keys, sorted, compact) |
| Canonical hashing | `kernel/src/proof/hash.rs` | SHA-256 with V1 domain prefixes + compilation payload prefix |
| Registry | `kernel/src/carrier/registry.rs` | Bijective mapping, canonical bytes, golden digest |
| Compile | `kernel/src/carrier/compile.rs` | Rome payload → ByteState, fail-closed |

### M2 — ByteTrace writer + replay verifier

**Status**: Planned

**Deliverables**:
- ByteTrace binary writer (append-only, schema-first header)
- ByteTrace reader
- `replay_verify()` implementation (hashing, monotonicity, snapshot consistency)
- Minimal `apply()` — single operator application primitive
- Single-step replay lock test

**Acceptance**: S1-M2 — replay_verify() verdict matches original execution. S1-M2-DIV — injected divergence localizes to first differing step.

### M3 — Unified World Harness hello world

**Status**: Planned

**Deliverables**:
- World harness contract: `encode_fixture`, `decode_state`, `operator_catalog_data`, `domain_verifier`
- One minimal world (Rome or equivalent toy graph)
- Closed artifact bundle output (inputs/trace/verification/metrics)
- Determinism lock test

**Acceptance**: S1-M3 — harness produces self-contained artifact bundle. S1-M3-DETERMINISM — consecutive runs with identical inputs produce identical ByteTrace digests.

## Non-goals

- Neural model integration (observer/compressor role is post-M3)
- Multi-world orchestration (M3 proves one world only)
- Performance optimization beyond correctness (SIMD, parallelism are post-M3)
- V2 artifact format (blake3, wider Code types — explicitly out of scope for V1)
- Policy enforcement in the kernel (policy lives at the induction/harness layer)

## Design decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Artifact version | V1-compatible | v1 is byte-for-byte oracle for carrier/trace/hashing |
| Hash algorithm | SHA-256 | Matches v1; blake3 reserved for V2 artifact bump |
| `compile()` policy arg | Not present | Policy is induction-layer per v1 |
| `ByteStateV1` Eq/Hash | Not derived | Explicit `identity_eq` prevents conflation bug |
| Operator masks | Full-width packed vectors | SIMD-ready, no API break at M2 |
| Sentinel canonical form | Bytes | u32 view is display-only |
| `compile()` semantics | payload → initial `ByteState` | v1 "compiler" = trace encoder, different concept |
| Fixture oracle | v1 for bytes/hashes only | `compile()` boundary is new — no v1 oracle for that |
