# SPINE-001 Roadmap: Kernel Spine M0–M3

> Contract deliverable for `.caws/specs/SPINE-001.yaml`.
> This file is the authoritative milestone plan for the kernel spine.

## Milestones

### M0 — Kernel contract surface and repo layout

**Status**: Complete

**Deliverables**:
- Rust workspace (`kernel/`, `tests/lock/`) with pinned toolchain (1.90.0)
- `compile()`, `apply()`, `replay_verify()` API signatures (stubs, logic deferred)
- Carrier types: `Code32`, `ByteStateV1`, `SlotStatus`, `ByteTraceV1`, `SchemaDescriptor`, `RegistrySnapshot`
- Operator types: `OperatorSignature`, `IdentityMaskV1`, `StatusMaskV1`, `OperatorCategory`
- Proof types: `ContentHash`, domain prefix constants, `ReplayVerdict`
- JSON schemas: `bytetrace_descriptor`, `trace_bundle`, `claim`, `schema_descriptor`, `registry_snapshot`, `policy_snapshot`
- S1-M0 lock test: build-graph isolation (no v1 deps in kernel)
- CI workflow: check, clippy, fmt, test, docs lint

**Acceptance**: S1-M0 — no v1 dependency reachable from kernel build graph.

### M1 — ByteState/Code32 + canonical hashing (proof portfolio)

**Status**: Complete

**Completion sentence**: "M1 is complete when the kernel can deterministically compile a Rome payload into ByteState bytes and produce V1-compatible SHA-256 digests that match committed golden fixtures across OSes, while failing closed with typed errors on a mutation suite — and all of this is reproducible without importing or running V1 inside the Native build graph."

#### Claim surface (what M1 allows you to say)

- **M1-CLAIM-001** (Compilation boundary determinism): `compile(payload_bytes, schema_descriptor, registry_snapshot)` is a pure function for the Rome payload shape; identical inputs produce identical `ByteStateV1` bytes.
- **M1-CLAIM-002** (V1 hash parity): All content/state/registry hashing uses SHA-256 with the exact V1 domain-separation prefix bytes, producing `"sha256:<lowercase hex>"` outputs.
- **M1-CLAIM-003** (No second-truth JSON trace): M1 does not introduce an alternate "JSON trace" representation that can diverge from the binary carrier; only descriptors/manifests may be JSON.
- **M1-CLAIM-004** (Fail-closed compilation): Invalid payload/schema/registry inputs do not emit partial ByteState and do not panic; they return typed failures.

These claims are written as a claim catalog at `plans/spine/m1_claims.md`.

#### Deliverables

- `sha2` dependency for canonical hashing (SHA-256, V1-compatible domain prefixes)
- Single `canonical_hash()` implementation — all hashing flows route through it
- Single canonical JSON bytes implementation — all serialization-for-hashing routes through it
- `ByteStateV1` encode/decode with strict round-trip (no truncation acceptance)
- `compile()` implementation for Rome payload shape
- Golden byte fixtures generated from v1 offline, committed as test expectations
- Fail-closed mutation suite with typed `CompilationFailure` variants
- M1 claim catalog (`plans/spine/m1_claims.md`)

#### Acceptance criteria (proof portfolio)

| ID | Category | What it proves |
|----|----------|---------------|
| S1-M1-DETERMINISM-INPROC | Determinism | N>=10 calls in same process → identical bytes + digests |
| S1-M1-DETERMINISM-CROSSPROC | Determinism | Subprocess under >=3 env variants → same golden bytes |
| S1-M1-DETERMINISM-CROSSOS | Determinism | CI on Linux + macOS → identical results against golden fixtures |
| S1-M1-GOLDEN | Golden fixtures | Evidence bytes + digests match committed fixtures bit-for-bit |
| S1-M1-HASH-V1-VECTORS | V1 parity | >=3 sha256(prefix \|\| data) vectors match v1 oracle outputs |
| S1-M1-CANONJSON | Canonicalization | Stable canonical JSON bytes, documented rule set |
| S1-M1-FAILCLOSED | Fail-closed | Invalid inputs → no partial state, no panic, typed failure |
| S1-M1-TYPED-FAILURES | Error taxonomy | Each invalid class → stable error family |
| S1-M1-ORDERING-INVARIANCE | Anti-drift | Reordered JSON keys → identical output |
| S1-M1-REGISTRY-CANON | Registry | Canonical bytes stable, no incidental metadata |
| S1-M1-REGISTRY-HASH-GOLDEN | Registry | Registry digest matches committed golden |
| S1-M1-REGISTRY-VALIDATION | Fail-closed | Unknown Code32 → UnknownConcept, no auto-allocate |
| S1-M1-BYTESTATE-ROUNDTRIP | Encode/decode | evidence_bytes → ByteStateV1 round-trip, strict lengths |
| S1-M1-EQ-SEPARATION-LOCK | Equality | Status-only change: identity_eq true, bitwise_eq false, digests differ |
| S1-M1-NO-V1-DEPS | Isolation | Extends S1-M0 to cover M1 modules |
| S1-M1-NO-PATH-IN-HASH | Determinism | No paths/cwd/username/hostname/timestamps in any hashed surface |
| S1-M1-ONE-CANONICALIZER | Anti-drift | Exactly one canonical JSON implementation in kernel |
| S1-M1-REPRO | Reviewer | `cargo test --workspace` is sufficient, no manual setup |

#### Fixture admissibility rule

A fixture is only admissible if it is (1) generated by an oracle outside the Native build graph, and (2) the Native code is *constrained by it* (i.e., it would fail if canonicalization/hashing drifted).

#### compile() strategy

Rome payload is a canonical JSON representation of initial identity/status planes plus shape metadata. `compile()` parses, validates against registry, produces `ByteStateV1` deterministically. No invented semantics — keep it boring so golden fixtures are derivable from v1.

#### Fixture strategy

v1 is the oracle for wire format bytes and sha256 hashes. Generate fixtures from v1 Python, commit the bytes, validate Native against committed fixtures. Never import v1 into Native build graph. v1 is **not** an oracle for compilation semantics (the payload→state boundary is new).

#### M1 evidence index

Commit range: `2bf0b4a..6a1d05c` (8 commits). 103 tests, all passing.

| Artifact | Path | Role |
|----------|------|------|
| Golden fixture | `tests/fixtures/rome_2x4_golden.json` | V1 oracle bytes + digests |
| Golden fixture tests | `tests/lock/tests/s1_m1_golden_fixtures.rs` | 8 tests constraining compile against oracle |
| Determinism tests | `tests/lock/tests/s1_m1_determinism.rs` | In-proc N=10, ordering invariance, eq separation, one-canonicalizer, no-path-in-hash, no-v1-refs |
| Cross-process tests | `tests/lock/tests/s1_m1_crossproc.rs` | Subprocess under 4 env variants + golden output match |
| CI matrix | `.github/workflows/ci.yml` | `[ubuntu-latest, macos-latest]` for cross-OS |
| Claim catalog | `plans/spine/m1_claims.md` | 4 falsifiable claims with falsifiers |
| Canonical JSON | `kernel/src/proof/canon.rs` | Single canonicalizer (ASCII keys, sorted, compact) |
| Canonical hashing | `kernel/src/proof/hash.rs` | SHA-256 with V1 domain prefixes + compilation payload prefix |
| Registry | `kernel/src/carrier/registry.rs` | Bijective mapping, canonical bytes, golden digest |
| Compile | `kernel/src/carrier/compile.rs` | Rome payload → ByteState, fail-closed |

### M2 — ByteTrace writer + replay verifier (proof portfolio)

**Status**: Complete

**Completion sentence**: "M2 is complete when the kernel can write, read, hash, and replay-verify a ByteTrace that is byte-identical to the v1 oracle fixture, with fail-closed rejection of malformed wire bytes, cross-process determinism under environment variants, and divergence localization to the exact mutated frame — all without importing v1 into the build graph."

#### Claim surface (what M2 allows you to say)

- **M2-CLAIM-001** (Wire round-trip stability): Serializing the canonical trace to `.bst1`, parsing it, and re-serializing produces identical bytes.
- **M2-CLAIM-002** (V1 oracle parity): Native's `.bst1` bytes and payload hash are byte-identical to the v1 Python oracle for the canonical fixture.
- **M2-CLAIM-003** (Cross-process determinism): Trace write + hash + replay output is identical across environment variants (cwd, locale, noise env).
- **M2-CLAIM-004** (Fail-closed strictness): Reader/writer reject non-canonical JSON, trailing bytes, bad frame-0 sentinel, null witness digest, and overflow dimensions.
- **M2-CLAIM-005** (Divergence localization): Step-chain diverges at the exact mutated frame index.

These claims are written as a claim catalog at `plans/spine/m2_claims.md`.

#### Deliverables

- `.bst1` writer/reader for `ByteTraceV1` (envelope + magic + canonical header + fixed-stride frames + canonical footer)
- Payload hash: `sha256(DOMAIN_BYTETRACE || magic || header_json || body || footer_json)` — V1-compatible
- Step hash chain: `chain_0 = sha256(DOMAIN_TRACE_STEP || frame_0)`, `chain_i = sha256(DOMAIN_TRACE_STEP_CHAIN || chain_{i-1} || frame_i)` — Native-originated
- `apply()` with `SET_SLOT` operator (identity mutation + status promotion to Provisional)
- `replay_verify()` — frame-by-frame comparison with divergence localization
- Strictness hardening: canonical enforcement at read time (reject, don't normalize), checked arithmetic in writer, frame-0 sentinel in reader + writer, trailing bytes rejection, fail-closed hex decode, null witness rejection

#### Acceptance criteria (proof portfolio)

| ID | Category | What it proves |
|----|----------|---------------|
| S1-M2-GOLDEN | Golden fixtures | `.bst1` bytes + payload hash match v1 oracle bit-for-bit |
| S1-M2-READER-STRICT | Fail-closed | Malformed input rejected with typed errors, no panics, no partial frames |
| S1-M2-REPLAY-1STEP | Replay | Single-step replay verdict matches original execution |
| S1-M2-DIV-LOCALIZE | Divergence | Injected mutation at step k → divergence localization points to step k |
| S1-M2-DETERMINISM-INPROC | Determinism | N>=10 calls → identical `.bst1` bytes + digests |
| S1-M2-DETERMINISM-CROSSPROC | Determinism | Subprocess under 4 env variants → same golden bytes + digests |
| S1-M2-DETERMINISM-CROSSOS | Determinism | CI on Linux + macOS → identical results against golden fixtures |
| S1-M2-NO-SECOND-TRUTH | Anti-drift | No JSON inside frames; JSON only in envelope/header/footer |
| S1-M2-NO-PATH-IN-HASH | Determinism | No paths/cwd/username/hostname/timestamps in hashed sections |
| S1-M2-PAYLOAD-HASH-V1 | V1 parity | `sha256(DOMAIN_BYTETRACE \|\| magic \|\| header \|\| body \|\| footer)` matches v1 |

#### Non-goals (M2 scope boundary)

- Windows `.exe` handling (not a current target)
- Additional operators beyond `SET_SLOT` and sentinels
- Performance tuning beyond correctness + determinism
- Schema evolution beyond V1 wire definition
- Trace compression or streaming writer

#### M2 evidence index

Commit range: `ea8a2d4..9279ad5` (8 commits). 173 tests, all passing.

| Artifact | Path | Role |
|----------|------|------|
| V1 oracle fixture | `tests/fixtures/m2_golden_trace.bst1` | v1-generated `.bst1` bytes |
| V1 oracle metadata | `tests/fixtures/m2_golden_trace.json` | Expected payload hash + hex dumps |
| Fixture generator | `tests/fixtures/generate_m2_golden.py` | v1 Python script (not in build graph) |
| Canonical trace (single source) | `tests/lock/src/m2_canonical_trace.rs` | Shared constructor for binary + tests |
| Determinism tests | `tests/lock/tests/s1_m2_determinism.rs` | In-proc N=10, golden hash locks, independence |
| Divergence tests | `tests/lock/tests/s1_m2_divergence.rs` | 4-step trace, mutation localization, step chain |
| Cross-proc tests | `tests/lock/tests/s1_m2_crossproc.rs` | 4 env variants + v1 oracle parity + `.bst1` read |
| Cross-proc binary | `tests/lock/src/bin/trace_fixture.rs` | Deterministic output: bst1_hex, hashes, verdict |
| Trace writer | `kernel/src/carrier/trace_writer.rs` | Checked arithmetic, frame-0 validation |
| Trace reader | `kernel/src/carrier/trace_reader.rs` | Canonical enforcement, strictness tests |
| Trace hashing | `kernel/src/proof/trace_hash.rs` | Payload hash + step chain (fail-closed) |
| Replay verifier | `kernel/src/proof/replay.rs` | Frame-by-frame comparison |
| Apply operator | `kernel/src/operators/apply.rs` | `SET_SLOT` with precondition checks |
| Trace format spec | `plans/spine/m2_trace_format.md` | Wire format + strictness rules |
| Claim catalog | `plans/spine/m2_claims.md` | 5 falsifiable claims with falsifiers |

#### Stability contract

- **Payload hash stability** is defined by: `magic + canonical header bytes + body bytes + canonical footer bytes` (envelope excluded).
- **Canonical fixture wire stability** additionally commits to full `.bst1` bytes including envelope. The v1 oracle parity test compares the complete byte stream. Changing envelope serialization (field order, formatting, added fields) is treated as a wire break at M2. This is intentional: M2 locks full wire stability, not just payload stability.

### M3 — Unified World Harness hello world

**Status**: Complete

**Completion sentence**: "M3 is complete when the harness crate can orchestrate kernel APIs through a world trait to produce a self-contained in-memory artifact bundle with normative/observational separation, deterministic bundle digests insensitive to observational envelope mutation, explicit replay scope declaration, and cross-process determinism under environment variants — all without importing `sha2` or implementing proof logic outside the kernel."

#### Design pivots (from review feedback)

Three boundary decisions made explicit in M3 to avoid costly backouts:

1. **Normative vs observational artifacts in the bundle manifest.** Each artifact carries a `normative: bool` flag. Bundle digest is computed over normative artifact hashes only (via `digest_basis`). `trace.bst1` is observational because it contains the envelope. Its payload-level commitments (`payload_hash`, `step_chain_digest`) are captured in the normative `verification_report.json`, which binds the trace contents without making envelope bytes normative.
2. **Explicit replay verification scope.** The verification report declares `planes_verified: ["identity", "status"]`. Adding `"evidence"` to `planes_verified` is a claim expansion and must be accompanied by a new lock test + claim catalog bump.
3. **No `sha2` dependency in harness.** All hashing routes through kernel's `canonical_hash(domain, data)` with harness-defined domain prefixes. Prevents a second hashing path.

#### Claim surface (what M3 allows you to say)

- **M3-CLAIM-001** (Bundle determinism): `run(RomeMini)` is a pure function; N=10 in-process runs produce identical bundle digests, artifact bytes, and manifest bytes.
- **M3-CLAIM-002** (Cross-process determinism): The `harness_fixture` binary under 4 environment variants (baseline, different cwd, different locale, spurious env vars) produces identical output.
- **M3-CLAIM-003** (Normative/observational isolation): Mutating `trace.bst1` envelope bytes changes the manifest (which lists all content hashes) but leaves the bundle digest unchanged, because `digest_basis` includes normative artifacts only. `verify_bundle()` mechanically enforces the trace/report binding by recomputing `payload_hash` and `step_chain_digest` from `trace.bst1` and comparing to `verification_report.json`.
- **M3-CLAIM-004** (Replay scope declared): The verification report contains `planes_verified` listing exactly which planes were checked.

These claims are written as a claim catalog at `plans/spine/m3_claims.md`.

#### Deliverables

- `harness/` crate as workspace member (depends on `sterling-kernel`, `serde_json`, `hex` — no `sha2`)
- `WorldHarnessV1` trait: data-only contract (`world_id`, `dimensions`, `encode_payload`, `schema_descriptor`, `registry`, `program`); worlds may not implement hashing, trace writing, replay, or policy
- `ArtifactBundleV1` with normative/observational split: `manifest` (full listing), `digest_basis` (normative projection), `digest` (hash of digest basis)
- `run(world)` pipeline: `encode_payload → compile → [apply × N] → build trace → trace_to_bytes → replay_verify → payload_hash + step_chain → build bundle`
- `RomeMini` world: 1 layer, 2 slots, 3 arg slots, single `SET_SLOT` operation
- 4 harness-originated domain prefixes: `DOMAIN_BUNDLE_ARTIFACT`, `DOMAIN_BUNDLE_DIGEST`, `DOMAIN_HARNESS_FIXTURE`, `DOMAIN_CODEBOOK_HASH` (single source of truth: `harness/src/bundle.rs`)
- Deterministic envelope: fixed epoch timestamp, zero wall_time_ms, deterministic trace_id
- `harness_fixture` cross-process binary
- `verify_bundle()`: bundle verification algorithm that recomputes derived projections (manifest, digest_basis) from artifacts, verifies canonical JSON form, and checks trace/report payload commitments — pure integrity, no replay
- M3 claim catalog (`plans/spine/m3_claims.md`)

#### Acceptance criteria (proof portfolio)

| ID | Category | What it proves |
|----|----------|---------------|
| S1-M3-BUNDLE | Bundle | `run(RomeMini)` returns Ok with 4 artifacts, valid hashes, correct normative/observational flags |
| S1-M3-TRACE-PARSES | Integration | `trace.bst1` artifact parseable by kernel reader |
| S1-M3-REPLAY-MATCH | Integration | Verification report contains `replay_verdict: "Match"` |
| S1-M3-MANIFEST-HASHES | Integrity | Each artifact's `content_hash` matches recomputed hash |
| S1-M3-DIGEST-BASIS | Integrity | `bundle.digest` equals recomputed hash over `digest_basis` |
| S1-M3-FIXTURE-CANONICAL | Canonicalization | `fixture.json` is already canonical JSON (re-canonicalize → identical bytes) |
| S1-M3-PLANES-VERIFIED | Scope | Report lists `planes_verified: ["identity", "status"]` |
| S1-M3-NORMATIVE-CLASS | Classification | `fixture.json`, `compilation_manifest.json`, `verification_report.json` normative; `trace.bst1` observational |
| S1-M3-DETERMINISM-INPROC | Determinism | N=10 runs → identical bundle digest, artifact bytes, manifest bytes, digest_basis bytes |
| S1-M3-OBSERVATIONAL-ISOLATION | Isolation | Mutating `trace.bst1` envelope → bundle digest unchanged, manifest changed |
| S1-M3-DETERMINISM-CROSSPROC | Determinism | `harness_fixture` under 4 env variants → identical output |
| S1-M3-VERIFY-BUNDLE | Integrity | `verify_bundle()` passes on clean bundle (content hashes, derived projections, canonical form, digest) |
| S1-M3-VERIFY-TRACE-BINDING | Integrity | `verify_bundle()` detects payload_hash mismatch when trace body mutated but report unchanged |

#### Non-goals (M3 scope boundary)

- Disk persistence (bundle is in-memory only)
- Policy enforcement (future milestone)
- State decoding or human-readable summaries (future V2 trait)
- Additional operators beyond `SET_SLOT`
- Multi-world orchestration
- Streaming trace writer

#### M3 evidence index

Commit range: `9c734eb..aa36c89` + `verify_bundle` commit. 197 tests, all passing (133 kernel + 8 harness unit + 56 lock).

| Artifact | Path | Role |
|----------|------|------|
| World contract | `harness/src/contract.rs` | `WorldHarnessV1` trait (data-only) |
| Bundle types + verifier | `harness/src/bundle.rs` | `ArtifactBundleV1`, `verify_bundle()`, normative/observational split, domain constants |
| Runner | `harness/src/runner.rs` | Pipeline orchestration (`run()` entry point) |
| RomeMini world | `harness/src/worlds/rome_mini.rs` | Minimal world (1 layer, 2 slots, 1 operator) |
| Harness tests | `tests/lock/tests/s1_m3_harness.rs` | 11 tests: bundle content, hashes, classification, canonical form, `verify_bundle()` clean + trace/report binding |
| Determinism tests | `tests/lock/tests/s1_m3_determinism.rs` | 4 tests: N=10 determinism, observational isolation |
| Cross-proc tests | `tests/lock/tests/s1_m3_crossproc.rs` | 1 test: 4 env variants → identical output |
| Cross-proc binary | `tests/lock/src/bin/harness_fixture.rs` | Deterministic output: bundle_digest, hashes, verdict, count |
| Claim catalog | `plans/spine/m3_claims.md` | 4 falsifiable claims with falsifiers |

#### Domain-prefix ownership

Kernel-owned domains (defined in `kernel/src/proof/hash.rs`) are the only domains used for kernel claim surfaces (compilation, payload hash, step chain, registry). Harness-owned domains (defined in `harness/src/bundle.rs`) use `STERLING::BUNDLE_*` or `STERLING::HARNESS_*` prefixes. No other crate defines domain prefixes. This is the "one canonicalizer" rule applied to domain separation.

## Non-goals

- Neural model integration (observer/compressor role is post-M3)
- Multi-world orchestration (M3 proves one world only)
- Performance optimization beyond correctness (SIMD, parallelism are post-M3)
- V2 artifact format (blake3, wider Code types — explicitly out of scope for V1)
- Policy enforcement in the kernel (policy lives at the induction/harness layer)

## Design decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Artifact version | V1-compatible | v1 is byte-for-byte oracle for carrier/trace/hashing |
| Hash algorithm | SHA-256 | Matches v1; blake3 reserved for V2 artifact bump |
| `compile()` policy arg | Not present | Policy is induction-layer per v1 |
| `ByteStateV1` Eq/Hash | Not derived | Explicit `identity_eq` prevents conflation bug |
| Operator masks | Full-width packed vectors | SIMD-ready, no API break at M2 |
| Sentinel canonical form | Bytes | u32 view is display-only |
| `compile()` semantics | payload → initial `ByteState` | v1 "compiler" = trace encoder, different concept |
| Fixture oracle | v1 for bytes/hashes only | `compile()` boundary is new — no v1 oracle for that |
