//! S1-M1 Golden Fixture Tests: constrain Native against v1 Python oracle.
//!
//! Fixture file: `tests/fixtures/rome_2x4_golden.json`
//! Generated by: `python3 hashlib.sha256 + json.dumps(sort_keys=True, separators=(',',':'))`
//!
//! These tests prove that Native's canonicalization, hashing, and compilation
//! produce byte-for-byte identical outputs to the v1 oracle. If any of these
//! fail, it means canonicalization or hashing has drifted.

use std::path::Path;

use sterling_kernel::carrier::bytestate::SchemaDescriptor;
use sterling_kernel::carrier::code32::Code32;
use sterling_kernel::carrier::compile::compile;
use sterling_kernel::carrier::registry::RegistryV1;
use sterling_kernel::proof::hash::{canonical_hash, DOMAIN_EVIDENCE_PLANE, DOMAIN_IDENTITY_PLANE};

/// Load the golden fixture from the committed JSON file.
fn load_golden_fixture() -> serde_json::Value {
    let workspace_root = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("tests/ exists")
        .parent()
        .expect("workspace root exists");
    let fixture_path = workspace_root.join("tests/fixtures/rome_2x4_golden.json");
    let contents = std::fs::read_to_string(&fixture_path)
        .unwrap_or_else(|e| panic!("cannot read fixture at {}: {e}", fixture_path.display()));
    serde_json::from_str(&contents).expect("fixture is valid JSON")
}

fn golden_registry(fixture: &serde_json::Value) -> RegistryV1 {
    let allocs: Vec<(Code32, String)> = fixture["registry_allocations"]
        .as_array()
        .unwrap()
        .iter()
        .map(|entry| {
            let bytes: Vec<u8> = entry["code32"]
                .as_array()
                .unwrap()
                .iter()
                .map(|v| u8::try_from(v.as_u64().unwrap()).unwrap())
                .collect();
            let code = Code32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
            let concept_id = entry["concept_id"].as_str().unwrap().to_string();
            (code, concept_id)
        })
        .collect();
    RegistryV1::new(
        fixture["registry_epoch"].as_str().unwrap().to_string(),
        allocs,
    )
    .unwrap()
}

// --- S1-M1-GOLDEN: evidence bytes + digests match committed golden fixtures ---

#[test]
fn golden_identity_bytes() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);
    let schema = SchemaDescriptor {
        id: fixture["schema_id"].as_str().unwrap().into(),
        version: fixture["schema_version"].as_str().unwrap().into(),
        hash: "sha256:0000000000000000000000000000000000000000000000000000000000000000".into(),
    };
    let payload = fixture["canonical_payload"].as_str().unwrap();

    let result = compile(payload.as_bytes(), &schema, &registry).unwrap();
    let identity_hex = hex::encode(result.state.identity_bytes());

    assert_eq!(
        identity_hex,
        fixture["identity_bytes_hex"].as_str().unwrap(),
        "identity bytes do not match golden fixture"
    );
}

#[test]
fn golden_status_bytes() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);
    let schema = SchemaDescriptor {
        id: fixture["schema_id"].as_str().unwrap().into(),
        version: fixture["schema_version"].as_str().unwrap().into(),
        hash: "sha256:0000000000000000000000000000000000000000000000000000000000000000".into(),
    };
    let payload = fixture["canonical_payload"].as_str().unwrap();

    let result = compile(payload.as_bytes(), &schema, &registry).unwrap();
    let status_hex = hex::encode(result.state.status_bytes());

    assert_eq!(
        status_hex,
        fixture["status_bytes_hex"].as_str().unwrap(),
        "status bytes do not match golden fixture"
    );
}

#[test]
fn golden_evidence_bytes() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);
    let schema = SchemaDescriptor {
        id: fixture["schema_id"].as_str().unwrap().into(),
        version: fixture["schema_version"].as_str().unwrap().into(),
        hash: "sha256:0000000000000000000000000000000000000000000000000000000000000000".into(),
    };
    let payload = fixture["canonical_payload"].as_str().unwrap();

    let result = compile(payload.as_bytes(), &schema, &registry).unwrap();
    let evidence_hex = hex::encode(result.state.evidence_bytes());

    assert_eq!(
        evidence_hex,
        fixture["evidence_bytes_hex"].as_str().unwrap(),
        "evidence bytes do not match golden fixture"
    );
}

#[test]
fn golden_identity_digest() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);
    let schema = SchemaDescriptor {
        id: fixture["schema_id"].as_str().unwrap().into(),
        version: fixture["schema_version"].as_str().unwrap().into(),
        hash: "sha256:0000000000000000000000000000000000000000000000000000000000000000".into(),
    };
    let payload = fixture["canonical_payload"].as_str().unwrap();

    let result = compile(payload.as_bytes(), &schema, &registry).unwrap();

    assert_eq!(
        result.identity_digest.as_str(),
        fixture["identity_digest"].as_str().unwrap(),
        "identity digest does not match golden fixture"
    );
}

#[test]
fn golden_evidence_digest() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);
    let schema = SchemaDescriptor {
        id: fixture["schema_id"].as_str().unwrap().into(),
        version: fixture["schema_version"].as_str().unwrap().into(),
        hash: "sha256:0000000000000000000000000000000000000000000000000000000000000000".into(),
    };
    let payload = fixture["canonical_payload"].as_str().unwrap();

    let result = compile(payload.as_bytes(), &schema, &registry).unwrap();

    assert_eq!(
        result.evidence_digest.as_str(),
        fixture["evidence_digest"].as_str().unwrap(),
        "evidence digest does not match golden fixture"
    );
}

#[test]
fn golden_registry_digest() {
    let fixture = load_golden_fixture();
    let registry = golden_registry(&fixture);

    let digest = registry.digest().unwrap();
    assert_eq!(
        digest.as_str(),
        fixture["registry_digest"].as_str().unwrap(),
        "registry digest does not match golden fixture"
    );
}

// --- S1-M1-HASH-V1-VECTORS: direct hash parity ---

#[test]
fn golden_identity_hash_direct() {
    let fixture = load_golden_fixture();
    let identity_bytes = hex::decode(fixture["identity_bytes_hex"].as_str().unwrap()).unwrap();
    let h = canonical_hash(DOMAIN_IDENTITY_PLANE, &identity_bytes);
    assert_eq!(
        h.as_str(),
        fixture["identity_digest"].as_str().unwrap(),
        "direct identity hash does not match golden fixture"
    );
}

#[test]
fn golden_evidence_hash_direct() {
    let fixture = load_golden_fixture();
    let evidence_bytes = hex::decode(fixture["evidence_bytes_hex"].as_str().unwrap()).unwrap();
    let h = canonical_hash(DOMAIN_EVIDENCE_PLANE, &evidence_bytes);
    assert_eq!(
        h.as_str(),
        fixture["evidence_digest"].as_str().unwrap(),
        "direct evidence hash does not match golden fixture"
    );
}
