#!/usr/bin/env python3
"""Generate the M2 golden ByteTrace fixture using v1 Python.

This script uses the v1 ByteTrace infrastructure to produce a .bst1 file
and metadata JSON that Native can verify against. It proves that Native's
trace writer, reader, and payload hash produce byte-identical results to v1.

Run from the sterling-native root:
    PYTHONPATH=../sterling python3 tests/fixtures/generate_m2_golden.py

Produces:
    tests/fixtures/m2_golden_trace.bst1      — binary trace
    tests/fixtures/m2_golden_trace.json      — metadata (hashes, hex dumps)
"""

import json
import struct
import sys
from pathlib import Path

# v1 imports
from core.carrier.bytetrace import ByteTraceBuilder, ByteTraceEnvelope
from core.carrier.bytestate import ByteStateSchema, ByteStateV1
from core.carrier.code32 import (
    INITIAL_STATE_SENTINEL,
    PADDING_SENTINEL,
    Code32,
    SlotStatus,
)

# ---------------------------------------------------------------------------
# Parameters matching Native's canonical_test_trace()
# ---------------------------------------------------------------------------

LAYER_COUNT = 1
SLOT_COUNT = 2
ARG_SLOT_COUNT = 3  # SET_SLOT_ARG_COUNT in Native

# SET_SLOT operator: Code32(1, 1, 1) in Native
OP_SET_SLOT = Code32(domain=1, kind=1, local_id=1)

# Value to write: Code32(1, 1, 5) matching Native's canonical test trace
SET_VALUE = Code32(domain=1, kind=1, local_id=5)

# SET_SLOT args: [layer=0, slot=0, value=Code32(1,1,5)]
# Each arg is a u32 LE
SET_SLOT_ARGS = [0, 0, SET_VALUE.to_uint32()]

# Schema (needed for ByteStateV1)
SCHEMA = ByteStateSchema(
    schema_version="1.0",
    domain_id="rome",
    layer_count=LAYER_COUNT,
    slot_count=SLOT_COUNT,
    layer_semantics=("layer0",),
    padding_code=PADDING_SENTINEL,
    ordering_rule="positional",
    byte_order="little",
)

# Header parameters matching Native's canonical_test_trace()
DOMAIN_ID = "rome"
REGISTRY_EPOCH_HASH = "sha256:aaa"
CODEBOOK_HASH = "sha256:bbb"
FIXTURE_HASH = "sha256:ccc"
SUITE_IDENTITY = "sha256:ddd"

ENVELOPE = ByteTraceEnvelope(
    timestamp="2026-01-01T00:00:00Z",
    trace_id="golden-test",
    runner_version="0.0.1",
    wall_time_ms=42,
)


def main() -> None:
    # Build initial state: all PADDING, all HOLE
    initial_identity = PADDING_SENTINEL.to_bytes() * SLOT_COUNT
    initial_status = bytes([SlotStatus.HOLE]) * SLOT_COUNT
    initial = ByteStateV1(
        schema=SCHEMA,
        identity_plane=initial_identity,
        status_plane=initial_status,
    )

    # Apply SET_SLOT: write Code32(1,1,5) at layer=0, slot=0, promote to PROVISIONAL
    # This matches Native's apply() behavior for OP_SET_SLOT
    new_identity = bytearray(initial.identity_plane)
    new_status = bytearray(initial.status_plane)

    # Write value at (layer=0, slot=0)
    offset = 0  # (layer * slot_count + slot) * 4
    new_identity[offset : offset + 4] = SET_VALUE.to_bytes()
    new_status[0] = SlotStatus.PROVISIONAL  # SET_SLOT promotes to PROVISIONAL

    after_set = ByteStateV1(
        schema=SCHEMA,
        identity_plane=bytes(new_identity),
        status_plane=bytes(new_status),
    )

    # Build trace
    builder = ByteTraceBuilder(
        schema=SCHEMA,
        domain_id=DOMAIN_ID,
        registry_epoch_hash=REGISTRY_EPOCH_HASH,
        codebook_hash=CODEBOOK_HASH,
        fixture_hash=FIXTURE_HASH,
        arg_slot_count=ARG_SLOT_COUNT,
    )
    builder.add_initial_state(initial)
    builder.add_step(
        operator_code=OP_SET_SLOT.to_uint32(),
        operator_args=SET_SLOT_ARGS,
        result_state=after_set,
    )

    trace = builder.build(
        suite_identity=SUITE_IDENTITY,
        envelope=ENVELOPE,
    )

    # Serialize
    bst1_bytes = trace.to_bytes()
    payload_hash = trace.compute_payload_hash()

    # Extract header/footer canonical JSON for verification
    header_json = trace.header.to_canonical_json()
    footer_json = trace.footer.to_canonical_json()

    # Write .bst1 file
    out_dir = Path(__file__).parent
    bst1_path = out_dir / "m2_golden_trace.bst1"
    bst1_path.write_bytes(bst1_bytes)

    # Write metadata JSON
    meta = {
        "description": "M2 golden ByteTrace fixture generated by v1 Python",
        "generator": "python3 core.carrier.bytetrace.ByteTraceBuilder",
        "parameters": {
            "layer_count": LAYER_COUNT,
            "slot_count": SLOT_COUNT,
            "arg_slot_count": ARG_SLOT_COUNT,
            "domain_id": DOMAIN_ID,
            "registry_epoch_hash": REGISTRY_EPOCH_HASH,
            "codebook_hash": CODEBOOK_HASH,
            "fixture_hash": FIXTURE_HASH,
            "suite_identity": SUITE_IDENTITY,
            "op_set_slot_code": OP_SET_SLOT.to_uint32(),
            "set_value_code": SET_VALUE.to_uint32(),
        },
        "payload_hash": payload_hash,
        "bst1_hex": bst1_bytes.hex(),
        "bst1_len": len(bst1_bytes),
        "header_json_hex": header_json.hex(),
        "footer_json_hex": footer_json.hex(),
        "frame_stride": trace.header.bytes_per_step,
        "body_len": len(trace.body),
        "initial_identity_hex": initial.identity_plane.hex(),
        "initial_status_hex": initial.status_plane.hex(),
        "after_set_identity_hex": after_set.identity_plane.hex(),
        "after_set_status_hex": after_set.status_plane.hex(),
    }
    meta_path = out_dir / "m2_golden_trace.json"
    meta_path.write_text(json.dumps(meta, indent=2, sort_keys=True) + "\n")

    print(f"Generated: {bst1_path} ({len(bst1_bytes)} bytes)")
    print(f"Generated: {meta_path}")
    print(f"Payload hash: {payload_hash}")
    print(f"Frame stride: {trace.header.bytes_per_step}")
    print(f"Body length: {len(trace.body)}")
    print(f"BST1 hex: {bst1_bytes.hex()}")


if __name__ == "__main__":
    main()
